<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>zhisheng的博客</title>
  
  <subtitle>坑要一个个填，路要一步步走！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-05-02T15:15:33.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>zhisheng</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Spring Boot 2.0系列文章(七)：SpringApplication 深入探索</title>
    <link href="http://yoursite.com/2018/04/30/springboot_SpringApplication/"/>
    <id>http://yoursite.com/2018/04/30/springboot_SpringApplication/</id>
    <published>2018-04-29T16:00:00.000Z</published>
    <updated>2018-05-02T15:15:33.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fqxbkmfds2j31hc0oegze.jpg" alt="sunset-3325080_1920"></p><a id="more"></a><h3 id="关注我"><a href="#关注我" class="headerlink" title="关注我"></a>关注我</h3><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180103/C6LG3mGa12.jpg" alt="mark"></p><p>转载请务必注明原创地址为：<a href="http://www.54tianzhisheng.cn/2018/04/30/springboot_SpringApplication/" target="_blank" rel="noopener">http://www.54tianzhisheng.cn/2018/04/30/springboot_SpringApplication/</a></p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在 Spring Boot 项目的启动类中常见代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringbotApplication</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">SpringApplication.run(SpringbotApplication.class, args);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中也就两个比较引人注意的地方：</p><ul><li><code>@SpringBootApplication</code></li><li><code>SpringApplication.run()</code></li></ul><p>对于第一个注解 <code>@SpringBootApplication</code>，我已经在博客 <a href="http://www.54tianzhisheng.cn/2018/04/19/SpringBootApplication-annotation/" target="_blank" rel="noopener">Spring Boot 2.0系列文章(六)：Spring Boot 2.0中SpringBootApplication注解详解</a> 中详细的讲解了。接下来就是深入探究第二个了 <code>SpringApplication.run()</code> 。</p><h3 id="换个姿势"><a href="#换个姿势" class="headerlink" title="换个姿势"></a>换个姿势</h3><p>上面的姿势太简单了，只一行代码就完事了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SpringApplication.run(SpringbotApplication.class, args);</span><br></pre></td></tr></table></figure><p>其实是支持做一些个性化的设置，接下来我们换个姿势瞧瞧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringbotApplication</span> </span>&#123;  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">SpringApplication app = <span class="keyword">new</span> SpringApplication(SpringbotApplication.class);</span><br><span class="line"> <span class="comment">// 自定义应用程序的配置</span></span><br><span class="line"> <span class="comment">//app.setXxx()</span></span><br><span class="line"> app.run(args)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没错，就是通过一个构造函数，然后设置相关的属性，从而达到定制化服务。有哪些属性呢？</p><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fqx6tttpf2j312618mn4w.jpg" alt="SpringApplicationFileds"></p><p>属性对应的 get／set 方法</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fqx6tz1wmyj31kw1f3qeo.jpg" alt="springapplication_getset"></p><p>看到没，还很多呢！</p><p>举个例子：你想把 Spring Boot 项目的默认 Banner 换成你自己的，就需要在这里如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//SpringApplication.run(Springboot2Application.class, args);</span></span><br><span class="line">  SpringApplication application = <span class="keyword">new</span> SpringApplication(Springboot2Application.class);</span><br><span class="line">  application.setBanner((environment, sourceClass, out) -&gt; &#123;</span><br><span class="line">    <span class="comment">//这里打印一个logo</span></span><br><span class="line">    System.out.println(<span class="string">"      _      _       _\n"</span> +</span><br><span class="line">                       <span class="string">"     | |    (_)     | |\n"</span> +</span><br><span class="line">                       <span class="string">" ____| |__   _  ___ | |__    ___  _ __    __ _\n"</span> +</span><br><span class="line">                       <span class="string">"|_  /| '_ \\ | |/ __|| '_ \\  / _ \\| '_ \\  / _` |\n"</span> +</span><br><span class="line">                       <span class="string">" / / | | | || |\\__ \\| | | ||  __/| | | || (_| |\n"</span> +</span><br><span class="line">                       <span class="string">"/___||_| |_||_||___/|_| |_| \\___||_| |_| \\__, |\n"</span> +</span><br><span class="line">                       <span class="string">"                                          __/ |\n"</span> +</span><br><span class="line">                       <span class="string">"                                         |___/\n"</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  application.setBannerMode(Banner.Mode.CONSOLE);</span><br><span class="line">  <span class="comment">//你还可以干其他的定制化初始设置</span></span><br><span class="line">  application.run(args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在重启项目，你就会发现，控制台的 logo 已经换成你自己的了。</p><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fqx6tuvk6lj31kw1a6qio.jpg" alt="banner"></p><p>当然了，你可能会觉得这样写有点复杂，嗯嗯，确实，这样硬编码在代码里确实不太友好。你还可以在<code>src/main/resources</code>路径下新建一个<code>banner.txt</code>文件，<code>banner.txt</code>中填写好需要打印的字符串内容即可。</p><p>从该类中可以看到在 Spring Boot 2 中引入了个新的 WebApplicationType 和 WebEnvironment。</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fqx6tvo4l3j31ke1fads1.jpg" alt="springapplication-002"></p><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fqx6tyfizgj31be13ujws.jpg" alt="webapplicationtype"></p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fqx6tmcuslj31im0yigtw.jpg" alt="springapplication-003"></p><p>确实，这也是 Spring Boot 2 中比较大的特性，它是支持响应式编程的。我之前在文章 <a href="http://www.54tianzhisheng.cn/2018/03/06/SpringBoot2-new-features/" target="_blank" rel="noopener">Spring Boot 2.0系列文章(二)：Spring Boot 2.0 新特性详解</a> 中也介绍过，以后有机会会介绍它的，这里我先卖个关子。</p><h3 id="SpringApplication-初始化"><a href="#SpringApplication-初始化" class="headerlink" title="SpringApplication 初始化"></a>SpringApplication 初始化</h3><p><code>SpringApplication.run()</code>  的实现才是我们要深入探究的主角，该方法代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//静态方法，可用于使用默认配置运行 SpringApplication</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(Class&lt;?&gt; primarySource,</span></span></span><br><span class="line"><span class="function"><span class="params">      String... args)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> run(<span class="keyword">new</span> Class&lt;?&gt;[] &#123; primarySource &#125;, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(Class&lt;?&gt;[] primarySources,</span></span></span><br><span class="line"><span class="function"><span class="params">String[] args)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> SpringApplication(primarySources).run(args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个静态方法中，创建 SpringApplication 对象，并调用该对象的 run 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SpringApplication</span><span class="params">(Class&lt;?&gt;... primarySources)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>(<span class="keyword">null</span>, primarySources);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建一个 SpringApplication 实例，应用上下文会根据指定的主要资源加载 beans ，实例在调用 run 方法之前可以定制化</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(&#123; <span class="string">"unchecked"</span>, <span class="string">"rawtypes"</span> &#125;)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SpringApplication</span><span class="params">(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.resourceLoader = resourceLoader;</span><br><span class="line">  Assert.notNull(primarySources, <span class="string">"PrimarySources must not be null"</span>);</span><br><span class="line">  <span class="keyword">this</span>.primarySources = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(Arrays.asList(primarySources));</span><br><span class="line">  <span class="keyword">this</span>.webApplicationType = deduceWebApplicationType();</span><br><span class="line">  setInitializers((Collection) getSpringFactoriesInstances(</span><br><span class="line">    ApplicationContextInitializer.class));</span><br><span class="line">  setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));</span><br><span class="line">  <span class="keyword">this</span>.mainApplicationClass = deduceMainApplicationClass();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先是进入单个参数的构造方法，然后进入两参数的构造方法（ResourceLoader 为 null），然后进行初始化。</p><p><strong>1、deduceWebApplicationType()</strong> : 推断应用的类型 ，创建的是一个 SERVLET 应用还是 REACTIVE应用或者是 NONE</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String REACTIVE_WEB_ENVIRONMENT_CLASS = <span class="string">"org.springframework.web.reactive.DispatcherHandler"</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String MVC_WEB_ENVIRONMENT_CLASS = <span class="string">"org.springframework.web.servlet.DispatcherServlet"</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] WEB_ENVIRONMENT_CLASSES = &#123; <span class="string">"javax.servlet.Servlet"</span>,</span><br><span class="line"><span class="string">"org.springframework.web.context.ConfigurableWebApplicationContext"</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> WebApplicationType <span class="title">deduceWebApplicationType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (ClassUtils.isPresent(REACTIVE_WEB_ENVIRONMENT_CLASS, <span class="keyword">null</span>)</span><br><span class="line">      &amp;&amp; !ClassUtils.isPresent(MVC_WEB_ENVIRONMENT_CLASS, <span class="keyword">null</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> WebApplicationType.REACTIVE;<span class="comment">//该程序是 REACTIVE 程序</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (String className : WEB_ENVIRONMENT_CLASSES) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!ClassUtils.isPresent(className, <span class="keyword">null</span>)) &#123;</span><br><span class="line">      <span class="keyword">return</span> WebApplicationType.NONE;<span class="comment">//该程序为 NONE</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> WebApplicationType.SERVLET;<span class="comment">//默认返回是 SERVLET 程序</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2、setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class))</strong>：初始化 classpath 下的所有的可用的 ApplicationContextInitializer。</p><p>1）、getSpringFactoriesInstances()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">Collection&lt;T&gt; <span class="title">getSpringFactoriesInstances</span><span class="params">(Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> getSpringFactoriesInstances(type, <span class="keyword">new</span> Class&lt;?&gt;[] &#123;&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取所有的 Spring 工厂实例</span></span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">Collection&lt;T&gt; <span class="title">getSpringFactoriesInstances</span><span class="params">(Class&lt;T&gt; type,</span></span></span><br><span class="line"><span class="function"><span class="params">Class&lt;?&gt;[] parameterTypes, Object... args)</span> </span>&#123;</span><br><span class="line">  ClassLoader classLoader = Thread.currentThread().getContextClassLoader();</span><br><span class="line">  <span class="comment">// Use names and ensure unique to protect against duplicates</span></span><br><span class="line">  Set&lt;String&gt; names = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(SpringFactoriesLoader.loadFactoryNames(type, classLoader)); <span class="comment">//获取所有 Spring Factories 的名字</span></span><br><span class="line">  List&lt;T&gt; instances = createSpringFactoriesInstances(type, parameterTypes,</span><br><span class="line">                                                     classLoader, args, names);</span><br><span class="line">  AnnotationAwareOrderComparator.sort(instances); <span class="comment">//Spring 工厂实例排序</span></span><br><span class="line">  <span class="keyword">return</span> instances;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//根据读取到的名字创建对象（Spring 工厂实例）</span></span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">createSpringFactoriesInstances</span><span class="params">(Class&lt;T&gt; type,</span></span></span><br><span class="line"><span class="function"><span class="params"> Class&lt;?&gt;[] parameterTypes, ClassLoader classLoader, Object[] args, Set&lt;String&gt; names)</span> </span>&#123;</span><br><span class="line">  List&lt;T&gt; instances = <span class="keyword">new</span> ArrayList&lt;&gt;(names.size());</span><br><span class="line">  <span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Class&lt;?&gt; instanceClass = ClassUtils.forName(name, classLoader);</span><br><span class="line">      Assert.isAssignable(type, instanceClass);</span><br><span class="line">      Constructor&lt;?&gt; constructor = instanceClass.getDeclaredConstructor(parameterTypes);</span><br><span class="line">      T instance = (T) BeanUtils.instantiateClass(constructor, args);</span><br><span class="line">      instances.add(instance);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">        <span class="string">"Cannot instantiate "</span> + type + <span class="string">" : "</span> + name, ex);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> instances;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的 SpringFactoriesLoader.loadFactoryNames() ，是从  META-INF/spring.factories 的资源文件中，读取 key 为org.springframework.context.ApplicationContextInitializer 的 value。</p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fqx6xo1yhjj31kw1cinbe.jpg" alt="springfactoriesloader"></p><p>而 spring.factories 的部分内容如下：</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fqx6tt63ojj31kw0kotk4.jpg" alt="2018-05-01_22-21-20"></p><p>可以看到，最近的得到的，是 ConfigurationWarningsApplicationContextInitializer，ContextIdApplicationContextInitializer，DelegatingApplicationContextInitializer，ServerPortInfoApplicationContextInitializer 这四个类的名字。</p><p>2）、setInitializers()：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setInitializers</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">Collection&lt;? extends ApplicationContextInitializer&lt;?&gt;&gt; initializers)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.initializers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  <span class="keyword">this</span>.initializers.addAll(initializers);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，这里 setInitializers() 所得到的成员变量 initializers 就被初始化为ConfigurationWarningsApplicationContextInitializer，ContextIdApplicationContextInitializer，DelegatingApplicationContextInitializer，ServerPortInfoApplicationContextInitializer 这四个类的对象组成的 list。</p><p><strong>3、setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class))</strong>：初始化 classpath 下的所有的可用的 ApplicationListener。</p><p>1）、getSpringFactoriesInstances() 和上面的类似，但是它是从  META-INF/spring.factories 的资源文件中，获取到 key 为 org.springframework.context.ApplicationListener 的 value。</p><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fqx6ty24gvj31kw0l3n7h.jpg" alt="2018-05-01_22-33-56"></p><p>2）、setListeners()：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setListeners</span><span class="params">(Collection&lt;? extends ApplicationListener&lt;?&gt;&gt; listeners)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.listeners = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  <span class="keyword">this</span>.listeners.addAll(listeners);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，这里 setListeners() 所得到的成员变量 listeners 就被初始化为 ClearCachesApplicationListener，ParentContextCloserApplicationListener，FileEncodingApplicationListener，AnsiOutputApplicationListener ，ConfigFileApplicationListener，DelegatingApplicationListener，ClasspathLoggingApplicationListener，LoggingApplicationListener，LiquibaseServiceLocatorApplicationListener  这九个类的对象组成的 list。</p><p><strong>4、deduceMainApplicationClass()</strong> ：根据调用栈，推断出 main 方法的类名</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Class&lt;?&gt; deduceMainApplicationClass() &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    StackTraceElement[] stackTrace = <span class="keyword">new</span> RuntimeException().getStackTrace();</span><br><span class="line">    <span class="keyword">for</span> (StackTraceElement stackTraceElement : stackTrace) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="string">"main"</span>.equals(stackTraceElement.getMethodName())) &#123;</span><br><span class="line">        <span class="keyword">return</span> Class.forName(stackTraceElement.getClassName());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">    <span class="comment">// Swallow and continue</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="run-方法背后的秘密"><a href="#run-方法背后的秘密" class="headerlink" title="run 方法背后的秘密"></a>run 方法背后的秘密</h3><p>上面看完了构造方法后，已经初始化了一个 SpringApplication 对象，接下来调用其 run 方法，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//运行 Spring 应用程序，创建并刷新一个新的 ApplicationContext</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">StopWatch stopWatch = <span class="keyword">new</span> StopWatch();</span><br><span class="line">stopWatch.start();</span><br><span class="line">ConfigurableApplicationContext context = <span class="keyword">null</span>;</span><br><span class="line">Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">configureHeadlessProperty();</span><br><span class="line">SpringApplicationRunListeners listeners = getRunListeners(args);</span><br><span class="line">listeners.starting();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">ApplicationArguments applicationArguments = <span class="keyword">new</span> DefaultApplicationArguments(</span><br><span class="line">args);</span><br><span class="line">ConfigurableEnvironment environment = prepareEnvironment(listeners,</span><br><span class="line">applicationArguments);</span><br><span class="line">configureIgnoreBeanInfo(environment);</span><br><span class="line">Banner printedBanner = printBanner(environment);</span><br><span class="line">context = createApplicationContext();</span><br><span class="line">exceptionReporters = getSpringFactoriesInstances(</span><br><span class="line">SpringBootExceptionReporter.class,</span><br><span class="line"><span class="keyword">new</span> Class[] &#123; ConfigurableApplicationContext.class &#125;, context);</span><br><span class="line">prepareContext(context, environment, listeners, applicationArguments,</span><br><span class="line">printedBanner);</span><br><span class="line">refreshContext(context);</span><br><span class="line">afterRefresh(context, applicationArguments);</span><br><span class="line">stopWatch.stop();</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.logStartupInfo) &#123;</span><br><span class="line"><span class="keyword">new</span> StartupInfoLogger(<span class="keyword">this</span>.mainApplicationClass)</span><br><span class="line">.logStarted(getApplicationLog(), stopWatch);</span><br><span class="line">&#125;</span><br><span class="line">listeners.started(context);</span><br><span class="line">callRunners(context, applicationArguments);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">handleRunFailure(context, ex, exceptionReporters, listeners);</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">listeners.running(context);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">handleRunFailure(context, ex, exceptionReporters, <span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> context;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可变个数参数 args 即是我们整个应用程序的入口 main 方法的参数。StopWatch 是来自 org.springframework.util 的工具类，可以用来方便的记录程序的运行时间。</p><p>再来看看 1.5.12 与 2.0.1 版本的 run 方法 有什么不一样的地方？</p><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fqx6u0khy1j31kw0wuhar.jpg" alt="difference-1.5-2.0"></p><p>接下来好好分析上面新版本（2.0.1）的 run 方法的代码并配合比较旧版本（1.5.12）。</p><p><strong>1、configureHeadlessProperty()</strong>：设置 headless 模式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SYSTEM_PROPERTY_JAVA_AWT_HEADLESS = <span class="string">"java.awt.headless"</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> headless = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">configureHeadlessProperty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  System.setProperty(SYSTEM_PROPERTY_JAVA_AWT_HEADLESS, System.getProperty(</span><br><span class="line">    SYSTEM_PROPERTY_JAVA_AWT_HEADLESS, Boolean.toString(<span class="keyword">this</span>.headless)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上是就是设置系统属性 java.awt.headless，该属性会被设置为 true。</p><p><strong>2、getRunListeners()</strong>：加载 SpringApplicationRunListener 对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//<span class="doctag">TODO:</span>  xxx</span></span><br><span class="line">SpringApplicationRunListeners listeners = getRunListeners(args);<span class="comment">//初始化监听器</span></span><br><span class="line">listeners.starting();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  prepareContext(context, environment, listeners, applicationArguments, printedBanner);</span><br><span class="line">  refreshContext(context);</span><br><span class="line">  afterRefresh(context, applicationArguments);</span><br><span class="line">  listeners.started(context);</span><br><span class="line">  callRunners(context, applicationArguments);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  listeners.running(context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> SpringApplicationRunListeners <span class="title">getRunListeners</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  Class&lt;?&gt;[] types = <span class="keyword">new</span> Class&lt;?&gt;[] &#123; SpringApplication.class, String[].class &#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> SpringApplicationRunListeners(logger, getSpringFactoriesInstances(</span><br><span class="line">    SpringApplicationRunListener.class, types, <span class="keyword">this</span>, args));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的 getRunListeners() 中也利用 SpringFactoriesLoader 加载 META-INF/spring.factories 中 key 为 SpringApplicationRunListener 的值，然后再将获取到的值作为参数传递到 SpringApplicationRunListeners 的构造方法中去创建对象。</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fqxei8t4u6j31do0ow0z9.jpg" alt="2018-05-02_23-11-01"></p><p><strong>3、new DefaultApplicationArguments(args)</strong> ：获取启动时传入参数 args（main 方法传进来的参数） 并初始化为 ApplicationArguments 对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DefaultApplicationArguments</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  Assert.notNull(args, <span class="string">"Args must not be null"</span>);</span><br><span class="line">  <span class="keyword">this</span>.source = <span class="keyword">new</span> Source(args);</span><br><span class="line">  <span class="keyword">this</span>.args = args;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4、prepareEnvironment(listeners, applicationArguments)</strong>：根据 listeners 和 applicationArguments 配置SpringBoot 应用的环境。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ConfigurableEnvironment <span class="title">prepareEnvironment</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  SpringApplicationRunListeners listeners, ApplicationArguments applicationArguments)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Create and configure the environment</span></span><br><span class="line">  ConfigurableEnvironment environment = getOrCreateEnvironment();</span><br><span class="line">  configureEnvironment(environment, applicationArguments.getSourceArgs());</span><br><span class="line">  listeners.environmentPrepared(environment);</span><br><span class="line">  bindToSpringApplication(environment);</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.webApplicationType == WebApplicationType.NONE) &#123;</span><br><span class="line">    environment = <span class="keyword">new</span> EnvironmentConverter(getClassLoader())</span><br><span class="line">      .convertToStandardEnvironmentIfNecessary(environment);</span><br><span class="line">  &#125;</span><br><span class="line">  ConfigurationPropertySources.attach(environment);</span><br><span class="line">  <span class="keyword">return</span> environment;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果 environment 不为空，直接 get 到，否则创建</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> ConfigurableEnvironment <span class="title">getOrCreateEnvironment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.environment != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.environment;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.webApplicationType == WebApplicationType.SERVLET) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> StandardServletEnvironment();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> StandardEnvironment();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//配置环境</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configureEnvironment</span><span class="params">(ConfigurableEnvironment environment,String[] args)</span> </span>&#123;</span><br><span class="line">  configurePropertySources(environment, args);<span class="comment">//配置要使用的PropertySources</span></span><br><span class="line">  configureProfiles(environment, args);<span class="comment">//配置要使用的Profiles</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将环境绑定到 SpringApplication</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">bindToSpringApplication</span><span class="params">(ConfigurableEnvironment environment)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    Binder.get(environment).bind(<span class="string">"spring.main"</span>, Bindable.ofInstance(<span class="keyword">this</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Cannot bind to SpringApplication"</span>, ex);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>5、configureIgnoreBeanInfo(environment)</strong>：根据环境信息配置要忽略的 bean 信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String IGNORE_BEANINFO_PROPERTY_NAME = <span class="string">"spring.beaninfo.ignore"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">configureIgnoreBeanInfo</span><span class="params">(ConfigurableEnvironment environment)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (System.getProperty(</span><br><span class="line">    CachedIntrospectionResults.IGNORE_BEANINFO_PROPERTY_NAME) == <span class="keyword">null</span>) &#123;</span><br><span class="line">    Boolean ignore = environment.getProperty(<span class="string">"spring.beaninfo.ignore"</span>,</span><br><span class="line">                                             Boolean.class, Boolean.TRUE);</span><br><span class="line">    System.setProperty(CachedIntrospectionResults.IGNORE_BEANINFO_PROPERTY_NAME,</span><br><span class="line">                       ignore.toString());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>6、printBanner(environment)</strong>：打印标志，上面我已经说过了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Banner <span class="title">printBanner</span><span class="params">(ConfigurableEnvironment environment)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.bannerMode == Banner.Mode.OFF) &#123;<span class="comment">//如果设置为 off，不打印 Banner</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ResourceLoader resourceLoader = <span class="keyword">this</span>.resourceLoader != <span class="keyword">null</span> ? <span class="keyword">this</span>.resourceLoader</span><br><span class="line">    : <span class="keyword">new</span> DefaultResourceLoader(getClassLoader());</span><br><span class="line">  SpringApplicationBannerPrinter bannerPrinter = <span class="keyword">new</span> SpringApplicationBannerPrinter(</span><br><span class="line">    resourceLoader, <span class="keyword">this</span>.banner);</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.bannerMode == Mode.LOG) &#123;</span><br><span class="line">    <span class="keyword">return</span> bannerPrinter.print(environment, <span class="keyword">this</span>.mainApplicationClass, logger);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> bannerPrinter.print(environment, <span class="keyword">this</span>.mainApplicationClass, System.out);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>7、createApplicationContext()</strong>：根据应用类型来确定该 Spring Boot 项目应该创建什么类型的 ApplicationContext ，默认情况下，如果没有明确设置的应用程序上下文或应用程序上下文类，该方法会在返回合适的默认值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_WEB_CONTEXT_CLASS = <span class="string">"org.springframework.boot.web.servlet.context.AnnotationConfigServletWebServerApplicationContext"</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_REACTIVE_WEB_CONTEXT_CLASS = <span class="string">"org.springframework.boot.web.reactive.context.AnnotationConfigReactiveWebServerApplicationContext"</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_CONTEXT_CLASS = <span class="string">"org.springframework.context.annotation.AnnotationConfigApplicationContext"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ConfigurableApplicationContext <span class="title">createApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Class&lt;?&gt; contextClass = <span class="keyword">this</span>.applicationContextClass;</span><br><span class="line">  <span class="keyword">if</span> (contextClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">switch</span> (<span class="keyword">this</span>.webApplicationType) &#123;<span class="comment">//根据应用程序的类型来初始化容器</span></span><br><span class="line">        <span class="keyword">case</span> SERVLET:<span class="comment">//servlet 应用程序</span></span><br><span class="line">          contextClass = Class.forName(DEFAULT_WEB_CONTEXT_CLASS);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> REACTIVE:<span class="comment">//reactive 应用程序</span></span><br><span class="line">          contextClass = Class.forName(DEFAULT_REACTIVE_WEB_CONTEXT_CLASS);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:<span class="comment">//默认</span></span><br><span class="line">          contextClass = Class.forName(DEFAULT_CONTEXT_CLASS);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">    <span class="string">"Unable create a default ApplicationContext,please specify an     ApplicationContextClass"</span>,ex);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//最后通过Spring的工具类 BeanUtils 初始化容器类 bean</span></span><br><span class="line">  <span class="keyword">return</span> (ConfigurableApplicationContext) BeanUtils.instantiateClass(contextClass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>来看看在 1.5.12 中是怎么样的？</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fqx6tx7lchj31kw0nw4gr.jpg" alt="createApplicationContext"></p><p><strong>8、exceptionReporters = getSpringFactoriesInstances(      SpringBootExceptionReporter.class,      new Class[] { ConfigurableApplicationContext.class }, context)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">Collection&lt;T&gt; <span class="title">getSpringFactoriesInstances</span><span class="params">(Class&lt;T&gt; type,</span></span></span><br><span class="line"><span class="function"><span class="params">            Class&lt;?&gt;[] parameterTypes, Object... args)</span> </span>&#123;</span><br><span class="line">  ClassLoader classLoader = Thread.currentThread().getContextClassLoader();</span><br><span class="line">  <span class="comment">// Use names and ensure unique to protect against duplicates</span></span><br><span class="line">  Set&lt;String&gt; names = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(</span><br><span class="line">    SpringFactoriesLoader.loadFactoryNames(type, classLoader));</span><br><span class="line">  List&lt;T&gt; instances = createSpringFactoriesInstances(type, parameterTypes,</span><br><span class="line">       classLoader, args, names);<span class="comment">//根据类型 key 为 SpringBootExceptionReporter 去加载</span></span><br><span class="line">  AnnotationAwareOrderComparator.sort(instances);<span class="comment">//对实例排序</span></span><br><span class="line">  <span class="keyword">return</span> instances;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里也是通过 SpringFactoriesLoader 加载 META-INF/spring.factories 中 key 为 SpringBootExceptionReporter 的全类名的 value 值。</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fqx6tp9y81j31kw0tfdqv.jpg" alt="springbootexception"></p><p><strong>9、prepareContext(context, environment, listeners, applicationArguments, printedBanner)</strong>：完成整个容器的创建与启动以及 bean 的注入功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//装配 Context</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">prepareContext</span><span class="params">(ConfigurableApplicationContext context,</span></span></span><br><span class="line"><span class="function"><span class="params">   ConfigurableEnvironment environment, SpringApplicationRunListeners listeners,</span></span></span><br><span class="line"><span class="function"><span class="params">   ApplicationArguments applicationArguments, Banner printedBanner)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//将之前准备好的 environment 设置给创建好的 ApplicationContext 使用</span></span><br><span class="line">  context.setEnvironment(environment);</span><br><span class="line">  <span class="comment">//1、</span></span><br><span class="line">  postProcessApplicationContext(context);</span><br><span class="line">  <span class="comment">//2、</span></span><br><span class="line">  applyInitializers(context);</span><br><span class="line">  listeners.contextPrepared(context);</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.logStartupInfo) &#123;<span class="comment">//启动日志</span></span><br><span class="line">    logStartupInfo(context.getParent() == <span class="keyword">null</span>);</span><br><span class="line">    logStartupProfileInfo(context);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Add boot specific singleton beans</span></span><br><span class="line">  context.getBeanFactory().registerSingleton(<span class="string">"springApplicationArguments"</span>,</span><br><span class="line">                                             applicationArguments);</span><br><span class="line">  <span class="keyword">if</span> (printedBanner != <span class="keyword">null</span>) &#123;</span><br><span class="line">    context.getBeanFactory().registerSingleton(<span class="string">"springBootBanner"</span>, printedBanner);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Load the sources</span></span><br><span class="line">  Set&lt;Object&gt; sources = getAllSources();</span><br><span class="line">  Assert.notEmpty(sources, <span class="string">"Sources must not be empty"</span>);</span><br><span class="line">  <span class="comment">//3、</span></span><br><span class="line">  load(context, sources.toArray(<span class="keyword">new</span> Object[<span class="number">0</span>]));</span><br><span class="line">  listeners.contextLoaded(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>1）、postProcessApplicationContext(context)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String CONFIGURATION_BEAN_NAME_GENERATOR = <span class="string">"org.springframework.context.annotation.internalConfigurationBeanNameGenerator"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">postProcessApplicationContext</span><span class="params">(ConfigurableApplicationContext context)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.beanNameGenerator != <span class="keyword">null</span>) &#123;</span><br><span class="line">    context.getBeanFactory().registerSingleton(</span><br><span class="line">      AnnotationConfigUtils.CONFIGURATION_BEAN_NAME_GENERATOR,</span><br><span class="line">      <span class="keyword">this</span>.beanNameGenerator);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.resourceLoader != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (context <span class="keyword">instanceof</span> GenericApplicationContext) &#123;</span><br><span class="line">      ((GenericApplicationContext) context)</span><br><span class="line">      .setResourceLoader(<span class="keyword">this</span>.resourceLoader);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (context <span class="keyword">instanceof</span> DefaultResourceLoader) &#123;</span><br><span class="line">      ((DefaultResourceLoader) context)</span><br><span class="line">      .setClassLoader(<span class="keyword">this</span>.resourceLoader.getClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法对 context 进行了预设置，设置了 ResourceLoader 和 ClassLoader，并向 bean 工厂中添加了一个beanNameGenerator 。</p><p><strong>2）、applyInitializers(context)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">applyInitializers</span><span class="params">(ConfigurableApplicationContext context)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (ApplicationContextInitializer initializer : getInitializers()) &#123;</span><br><span class="line">    Class&lt;?&gt; requiredType = GenericTypeResolver.resolveTypeArgument(</span><br><span class="line">      initializer.getClass(), ApplicationContextInitializer.class);</span><br><span class="line">    Assert.isInstanceOf(requiredType, context, <span class="string">"Unable to call initializer."</span>);</span><br><span class="line">    initializer.initialize(context);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在刷新之前将任何 ApplicationContextInitializer 应用于上下文</p><p><strong>3)、load(context, sources.toArray(new Object[0]))</strong></p><p>主要是加载各种 beans 到 ApplicationContext 对象中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">load</span><span class="params">(ApplicationContext context, Object[] sources)</span> </span>&#123;</span><br><span class="line">  BeanDefinitionLoader loader = createBeanDefinitionLoader( <span class="comment">//2</span></span><br><span class="line">    getBeanDefinitionRegistry(context), sources);<span class="comment">// 1</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.beanNameGenerator != <span class="keyword">null</span>) &#123;</span><br><span class="line">    loader.setBeanNameGenerator(<span class="keyword">this</span>.beanNameGenerator);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.resourceLoader != <span class="keyword">null</span>) &#123;</span><br><span class="line">    loader.setResourceLoader(<span class="keyword">this</span>.resourceLoader);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.environment != <span class="keyword">null</span>) &#123;</span><br><span class="line">    loader.setEnvironment(<span class="keyword">this</span>.environment);</span><br><span class="line">  &#125;</span><br><span class="line">  loader.load();<span class="comment">//3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>(1)、getBeanDefinitionRegistry(context)</strong></p><p>获取 bean 定义注册表</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> BeanDefinitionRegistry <span class="title">getBeanDefinitionRegistry</span><span class="params">(ApplicationContext context)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (context <span class="keyword">instanceof</span> BeanDefinitionRegistry) &#123;</span><br><span class="line">    <span class="keyword">return</span> (BeanDefinitionRegistry) context;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (context <span class="keyword">instanceof</span> AbstractApplicationContext) &#123;</span><br><span class="line">    <span class="keyword">return</span> (BeanDefinitionRegistry) ((AbstractApplicationContext) context)</span><br><span class="line">      .getBeanFactory();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Could not locate BeanDefinitionRegistry"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>(2)、createBeanDefinitionLoader()</strong></p><p>通过 BeanDefinitionLoader 的构造方法把参数（注册表、资源）传进去，然后创建 BeanDefinitionLoader。</p><p><strong>(3)、load()</strong></p><p>把资源全部加载。</p><p><strong>10、refreshContext(context)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">refreshContext</span><span class="params">(ConfigurableApplicationContext context)</span> </span>&#123;</span><br><span class="line">  refresh(context);<span class="comment">//1</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.registerShutdownHook) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      context.registerShutdownHook();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (AccessControlException ex) &#123;</span><br><span class="line">      <span class="comment">// Not allowed in some environments.</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//刷新底层的 ApplicationContext</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">(ApplicationContext applicationContext)</span> </span>&#123;</span><br><span class="line">  Assert.isInstanceOf(AbstractApplicationContext.class, applicationContext);</span><br><span class="line">  ((AbstractApplicationContext) applicationContext).refresh();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>refreshContext(context) 方法又调用了 refresh(context)。在调用了 refresh(context) 方法之后，调用了 registerShutdownHook 方法。继续看它的 refresh 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">    <span class="comment">// Prepare this context for refreshing.</span></span><br><span class="line">    prepareRefresh();</span><br><span class="line">    <span class="comment">// Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line">    ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line">    <span class="comment">// Prepare the bean factory for use in this context.</span></span><br><span class="line">    prepareBeanFactory(beanFactory);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// Allows post-processing of the bean factory in context subclasses.</span></span><br><span class="line">      postProcessBeanFactory(beanFactory);</span><br><span class="line">      <span class="comment">// Invoke factory processors registered as beans in the context.</span></span><br><span class="line">      invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line">      <span class="comment">// Register bean processors that intercept bean creation.</span></span><br><span class="line">      registerBeanPostProcessors(beanFactory);</span><br><span class="line">      <span class="comment">// Initialize message source for this context.</span></span><br><span class="line">      initMessageSource();</span><br><span class="line">      <span class="comment">// Initialize event multicaster for this context.</span></span><br><span class="line">      initApplicationEventMulticaster();</span><br><span class="line">      <span class="comment">// Initialize other special beans in specific context subclasses.</span></span><br><span class="line">      onRefresh();</span><br><span class="line">      <span class="comment">// Check for listener beans and register them.</span></span><br><span class="line">      registerListeners();</span><br><span class="line">      <span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">      finishBeanFactoryInitialization(beanFactory); <span class="comment">//1</span></span><br><span class="line">      <span class="comment">// Last step: publish corresponding event.</span></span><br><span class="line">      finishRefresh();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">      。。。</span><br><span class="line">        <span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">        destroyBeans();</span><br><span class="line">      <span class="comment">// Reset 'active' flag.</span></span><br><span class="line">      cancelRefresh(ex);</span><br><span class="line">      <span class="comment">// Propagate exception to caller.</span></span><br><span class="line">      <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">// Reset common introspection caches in Spring's core, since we</span></span><br><span class="line">      <span class="comment">// might not ever need metadata for singleton beans anymore...</span></span><br><span class="line">      resetCommonCaches();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里，我们就看见重点了，仔细看上的注释，正在做各种初始化工作，而今天我们关注的重点就是方法 finishBeanFactoryInitialization(beanFactory)。该方法进行了非懒加载 beans 的初始化工作。现在我们进入该方法内部，一探究竟。</p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fqx6tli7pjj31kw1757h0.jpg" alt="finishbeanFactoryini"></p><p>看上图方法中的最后一步，调用了 beanFactory 的 preInstantiateSingletons() 方法。此处的 beanFactory 是哪个类的实例对象呢？</p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fqx6xir0iaj31kw0urjuy.jpg" alt="2018-05-02_16-17-50"></p><p>可以看到 ConfigurableListableBeanFactory 接口的实现类只有 DefaultListableBeanFactory，我们看下实现类中的 preInstantiateSingletons 方法是怎么做的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preInstantiateSingletons</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">  <span class="comment">// Iterate over a copy to allow for init methods which in turn register new bean definitions.</span></span><br><span class="line">  <span class="comment">// While this may not be part of the regular factory bootstrap, it does otherwise work fine.</span></span><br><span class="line">  List&lt;String&gt; beanNames = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="keyword">this</span>.beanDefinitionNames);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Trigger initialization of all non-lazy singleton beans...</span></span><br><span class="line">  <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">    RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">    <span class="keyword">if</span> (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isFactoryBean(beanName)) &#123;</span><br><span class="line">        Object bean = getBean(FACTORY_BEAN_PREFIX + beanName);</span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> FactoryBean) &#123;</span><br><span class="line">          <span class="keyword">final</span> FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) bean;</span><br><span class="line">          <span class="keyword">boolean</span> isEagerInit;</span><br><span class="line">         <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span> &amp;&amp; factory <span class="keyword">instanceof</span> SmartFactoryBean)&#123;</span><br><span class="line">            isEagerInit = AccessController.doPrivileged((PrivilegedAction&lt;Boolean&gt;)</span><br><span class="line">             ((SmartFactoryBean&lt;?&gt;) factory)::isEagerInit, getAccessControlContext());</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            isEagerInit = (factory <span class="keyword">instanceof</span> SmartFactoryBean &amp;&amp;</span><br><span class="line">                           ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit());</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (isEagerInit) &#123;</span><br><span class="line">            getBean(beanName);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        getBean(beanName);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Trigger post-initialization callback for all applicable beans...</span></span><br><span class="line">  <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">    Object singletonInstance = getSingleton(beanName);</span><br><span class="line">    <span class="keyword">if</span> (singletonInstance <span class="keyword">instanceof</span> SmartInitializingSingleton) &#123;</span><br><span class="line">      <span class="keyword">final</span> SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance;</span><br><span class="line">      <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">          smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;, getAccessControlContext());</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码中可以看到很多调用了 getBean(beanName) 方法，跟踪此方法进去后，最终发现 getBean 调用了AbstractBeanFactory 类的 doGetBean(xxx) 方法，doGetBean(xxx) 方法中有这么一段代码：</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fqx6tr2ukqj31je1fegwm.jpg" alt="2018-05-02_17-17-39"></p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fqx6xjtn0hj31ja17g15o.jpg" alt="2018-05-02_17-19-31"></p><p>但是 createBean() 方法并没有得到实现，实现类在 AbstractAutowireCapableBeanFactory 中。这才是创建 bean 的核心方法。</p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fqx6toc4dxj31kw1bana4.jpg" alt="createBean"></p><p>不知不觉，代码看的越来越深，感觉思维都差点回不去 run 方法了，切回大脑的上下文线程到 run 方法去。</p><p><strong>11、afterRefresh(context, applicationArguments)</strong>：在上下文刷新后调用该方法，其内部没有做任何操作。</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fqx6tnnz8vj31bs0pkgrg.jpg" alt="2018-05-02_17-43-23"></p><p>发现没做任何操作了之后，就觉得有点奇怪，所以把当前版本和 1.5.12  对比了下，发现：</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fqx6ts33l2j31kw0witww.jpg" alt="afterRefresh"></p><p>在 1.5.12 中的 afterRefresh() 方法中调用了 callRunners() 方法，但是在 2.0.1 版本中的 run 方法中调用了 callRunners () 方法:</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fqx6xmgbpvj31kw0x8hc4.jpg" alt="2018-05-02_17-57-52"></p><p>这里不得不说 SpringApplicationRunListeners 在 2.0.1 中的改变：</p><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fqx6tq6fzhj31kw0y5azk.jpg" alt="2018-05-02_18-28-17"></p><p>可以发现在 run 方法中，SpringApplicationRunListeners 监听器的状态花生了变化，这也是通过对比不同版本的代码才知道的区别，所以说我们看源码需要多对比着看。</p><p>so，我们来看下这个 SpringApplicationRunListeners 这个接口：</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fqx6xla7afj31kw0unx1j.jpg" alt="2018-05-02_18-33-20"></p><p>started 状态：The context has been refreshed and the application has started but CommandLineRunner and ApplicationRunner have not been called</p><p>running 状态：Called immediately before the run method finishes, when the application context has been refreshed and all CommandLineRunner and ApplicationRunners have been called.</p><h3 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h3><p>1、<a href="http://www.54tianzhisheng.cn/2018/03/06/SpringBoot2-Migration-Guide/" target="_blank" rel="noopener">Spring Boot 2.0系列文章(一)：Spring Boot 2.0 迁移指南</a></p><p>2、<a href="http://www.54tianzhisheng.cn/2018/03/06/SpringBoot2-new-features/" target="_blank" rel="noopener">Spring Boot 2.0系列文章(二)：Spring Boot 2.0 新特性详解</a></p><p>3、<a href="http://www.54tianzhisheng.cn/2018/04/13/Spring_Boot_2.0_Configuration_Changelog/" target="_blank" rel="noopener">Spring Boot 2.0系列文章(三)：Spring Boot 2.0 配置改变</a></p><p>4、<a href="http://www.54tianzhisheng.cn/2018/04/15/springboot2_code/" target="_blank" rel="noopener">Spring Boot 2.0系列文章(四)：Spring Boot 2.0 源码阅读环境搭建</a></p><p>5、<a href="http://www.54tianzhisheng.cn/2018/04/18/spring_boot2_project/" target="_blank" rel="noopener">Spring Boot 2.0系列文章(五)：Spring Boot 2.0 项目源码结构预览</a></p><p>6、<a href="http://www.54tianzhisheng.cn/2018/04/19/SpringBootApplication-annotation/" target="_blank" rel="noopener">Spring Boot 2.0系列文章(六)：Spring boot 2.0 中 SpringBootApplication 注解详解</a></p><p>7、<a href="http://www.54tianzhisheng.cn/2018/04/30/springboot_SpringApplication/" target="_blank" rel="noopener">Spring Boot 2.0系列文章(七)：SpringApplication 深入探索</a></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文从源码级别分析了 Spring Boot 应用程序的启动过程，着重看了 SpringApplication 类中的构造函数的初始化和其 run 方法内部实现，并把涉及到的流程代码都过了一遍。</p><p>感悟：有时候跟代码跟着跟着，发现越陷越深，好难跳出来！后面还需多向别人请教阅读源码的技巧！</p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>虽然源码很难，但随着不断的探索，源码在你面前将会一览无遗，享受这种探索后的成就感！加油！骚年！</p><p>自己本人能力有限，源码看的不多，上面如有不对的还请留言交流。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://ws3.sinaimg.cn/large/006tKfTcgy1fqxbkmfds2j31hc0oegze.jpg&quot; alt=&quot;sunset-3325080_1920&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="SpringBoot" scheme="http://yoursite.com/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>分布式锁看这篇就够了</title>
    <link href="http://yoursite.com/2018/04/24/Distributed_lock/"/>
    <id>http://yoursite.com/2018/04/24/Distributed_lock/</id>
    <published>2018-04-23T16:00:00.000Z</published>
    <updated>2018-05-02T13:21:14.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fqp2lqscrwj31hc0zk46a.jpg" alt="meadow-811339_1920"></p><a id="more"></a><h3 id="关注我"><a href="#关注我" class="headerlink" title="关注我"></a>关注我</h3><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180103/C6LG3mGa12.jpg" alt="mark"></p><p>转载请务必注明原创地址为：<a href="http://www.54tianzhisheng.cn/2018/04/24/Distributed_lock/" target="_blank" rel="noopener">http://www.54tianzhisheng.cn/2018/04/24/Distributed_lock/</a></p><h3 id="什么是锁？"><a href="#什么是锁？" class="headerlink" title="什么是锁？"></a>什么是锁？</h3><ul><li>在单进程的系统中，当存在多个线程可以同时改变某个变量（可变共享变量）时，就需要对变量或代码块做同步，使其在修改这种变量时能够线性执行消除并发修改变量。</li><li>而同步的本质是通过锁来实现的。为了实现多个线程在一个时刻同一个代码块只能有一个线程可执行，那么需要在某个地方做个标记，这个标记必须每个线程都能看到，当标记不存在时可以设置该标记，其余后续线程发现已经有标记了则等待拥有标记的线程结束同步代码块取消标记后再去尝试设置标记。这个标记可以理解为锁。</li><li>不同地方实现锁的方式也不一样，只要能满足所有线程都能看得到标记即可。如 Java 中 synchronize 是在对象头设置标记，Lock 接口的实现类基本上都只是某一个 volitile 修饰的 int 型变量其保证每个线程都能拥有对该 int 的可见性和原子修改，linux 内核中也是利用互斥量或信号量等内存数据做标记。</li><li>除了利用内存数据做锁其实任何互斥的都能做锁（只考虑互斥情况），如流水表中流水号与时间结合做幂等校验可以看作是一个不会释放的锁，或者使用某个文件是否存在作为锁等。只需要满足在对标记进行修改能保证原子性和内存可见性即可。</li></ul><h3 id="什么是分布式？"><a href="#什么是分布式？" class="headerlink" title="什么是分布式？"></a>什么是分布式？</h3><p>分布式的 CAP 理论告诉我们:</p><blockquote><p>任何一个分布式系统都无法同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance），最多只能同时满足两项。</p></blockquote><p>目前很多大型网站及应用都是分布式部署的，分布式场景中的数据一致性问题一直是一个比较重要的话题。基于 CAP理论，很多系统在设计之初就要对这三者做出取舍。在互联网领域的绝大多数的场景中，都需要牺牲强一致性来换取系统的高可用性，系统往往只需要保证最终一致性。</p><h4 id="分布式场景"><a href="#分布式场景" class="headerlink" title="分布式场景"></a>分布式场景</h4><blockquote><p>此处主要指集群模式下，多个相同服务同时开启.</p></blockquote><p>在许多的场景中，我们为了保证数据的最终一致性，需要很多的技术方案来支持，比如<strong>分布式事务</strong>、<strong>分布式锁</strong>等。很多时候我们需要保证一个方法在同一时间内只能被同一个线程执行。在单机环境中，通过 Java 提供的并发 API 我们可以解决，但是在分布式环境下，就没有那么简单啦。</p><ul><li>分布式与单机情况下最大的不同在于其不是多线程而是<strong>多进程</strong>。</li><li>多线程由于可以共享堆内存，因此可以简单的采取内存作为标记存储位置。而进程之间甚至可能都不在同一台物理机上，因此需要将标记存储在一个所有进程都能看到的地方。</li></ul><h4 id="什么是分布式锁？"><a href="#什么是分布式锁？" class="headerlink" title="什么是分布式锁？"></a>什么是分布式锁？</h4><ul><li>当在分布式模型下，数据只有一份（或有限制），此时需要利用锁的技术控制某一时刻修改数据的进程数。</li><li>与单机模式下的锁不仅需要保证进程可见，还需要考虑进程与锁之间的网络问题。（我觉得分布式情况下之所以问题变得复杂，主要就是需要考虑到<strong>网络的延时和不可靠</strong>。。。一个大坑）</li><li>分布式锁还是可以将标记存在内存，只是该内存不是某个进程分配的内存而是公共内存如 Redis、Memcache。至于利用数据库、文件等做锁与单机的实现是一样的，只要保证标记能互斥就行。</li></ul><h3 id="我们需要怎样的分布式锁？"><a href="#我们需要怎样的分布式锁？" class="headerlink" title="我们需要怎样的分布式锁？"></a>我们需要怎样的分布式锁？</h3><ul><li>可以保证在分布式部署的应用集群中，同一个方法在同一时间只能被一台机器上的一个线程执行。</li><li>这把锁要是一把可重入锁（避免死锁）</li><li>这把锁最好是一把阻塞锁（根据业务需求考虑要不要这条）</li><li>这把锁最好是一把公平锁（根据业务需求考虑要不要这条）</li><li>有高可用的获取锁和释放锁功能</li><li>获取锁和释放锁的性能要好</li></ul><h3 id="基于数据库做分布式锁"><a href="#基于数据库做分布式锁" class="headerlink" title="基于数据库做分布式锁"></a>基于数据库做分布式锁</h3><blockquote><p>基于乐观锁</p></blockquote><h4 id="基于表主键唯一做分布式锁"><a href="#基于表主键唯一做分布式锁" class="headerlink" title="基于表主键唯一做分布式锁"></a>基于表主键唯一做分布式锁</h4><p>利用主键唯一的特性，如果有多个请求同时提交到数据库的话，数据库会保证只有一个操作可以成功，那么我们就可以认为操作成功的那个线程获得了该方法的锁，当方法执行完毕之后，想要释放锁的话，删除这条数据库记录即可。</p><p>上面这种简单的实现有以下几个问题：</p><ul><li>这把锁强依赖数据库的可用性，数据库是一个单点，一旦数据库挂掉，会导致业务系统不可用。</li><li>这把锁没有失效时间，一旦解锁操作失败，就会导致锁记录一直在数据库中，其他线程无法再获得到锁。</li><li>这把锁只能是非阻塞的，因为数据的 insert 操作，一旦插入失败就会直接报错。没有获得锁的线程并不会进入排队队列，要想再次获得锁就要再次触发获得锁操作。</li><li>这把锁是非重入的，同一个线程在没有释放锁之前无法再次获得该锁。因为数据中数据已经存在了。</li><li>这把锁是非公平锁，所有等待锁的线程凭运气去争夺锁。</li><li>在 MySQL 数据库中采用主键冲突防重，在大并发情况下有可能会造成锁表现象。</li></ul><p>当然，我们也可以有其他方式解决上面的问题。</p><ul><li>数据库是单点？搞两个数据库，数据之前双向同步，一旦挂掉快速切换到备库上。</li><li>没有失效时间？只要做一个定时任务，每隔一定时间把数据库中的超时数据清理一遍。</li><li>非阻塞的？搞一个 while 循环，直到 insert 成功再返回成功。</li><li>非重入的？在数据库表中加个字段，记录当前获得锁的机器的主机信息和线程信息，那么下次再获取锁的时候先查询数据库，如果当前机器的主机信息和线程信息在数据库可以查到的话，直接把锁分配给他就可以了。</li><li>非公平的？再建一张中间表，将等待锁的线程全记录下来，并根据创建时间排序，只有最先创建的允许获取锁。</li><li>比较好的办法是在程序中生产主键进行防重。</li></ul><h4 id="基于表字段版本号做分布式锁"><a href="#基于表字段版本号做分布式锁" class="headerlink" title="基于表字段版本号做分布式锁"></a>基于表字段版本号做分布式锁</h4><p>这个策略源于 mysql 的 mvcc 机制，使用这个策略其实本身没有什么问题，唯一的问题就是对数据表侵入较大，我们要为每个表设计一个版本号字段，然后写一条判断 sql 每次进行判断，增加了数据库操作的次数，在高并发的要求下，对数据库连接的开销也是无法忍受的。</p><blockquote><p>基于悲观锁</p></blockquote><h4 id="基于数据库排他锁做分布式锁"><a href="#基于数据库排他锁做分布式锁" class="headerlink" title="基于数据库排他锁做分布式锁"></a>基于数据库排他锁做分布式锁</h4><p>在查询语句后面增加<code>for update</code>，数据库会在查询过程中给数据库表增加排他锁 (注意： InnoDB 引擎在加锁的时候，只有通过索引进行检索的时候才会使用行级锁，否则会使用表级锁。这里我们希望使用行级锁，就要给要执行的方法字段名添加索引，值得注意的是，这个索引一定要创建成唯一索引，否则会出现多个重载方法之间无法同时被访问的问题。重载方法的话建议把参数类型也加上。)。当某条记录被加上排他锁之后，其他线程无法再在该行记录上增加排他锁。</p><p>我们可以认为获得排他锁的线程即可获得分布式锁，当获取到锁之后，可以执行方法的业务逻辑，执行完方法之后，通过<code>connection.commit()</code>操作来释放锁。</p><p>这种方法可以有效的解决上面提到的无法释放锁和阻塞锁的问题。</p><ul><li>阻塞锁？ <code>for update</code>语句会在执行成功后立即返回，在执行失败时一直处于阻塞状态，直到成功。</li><li>锁定之后服务宕机，无法释放？使用这种方式，服务宕机之后数据库会自己把锁释放掉。</li></ul><p>但是还是无法直接解决数据库单点和可重入问题。</p><p>这里还可能存在另外一个问题，虽然我们对方法字段名使用了唯一索引，并且显示使用 for update 来使用行级锁。但是，MySQL 会对查询进行优化，即便在条件中使用了索引字段，但是否使用索引来检索数据是由 MySQL 通过判断不同执行计划的代价来决定的，如果 MySQL 认为全表扫效率更高，比如对一些很小的表，它就不会使用索引，这种情况下 InnoDB 将使用表锁，而不是行锁。如果发生这种情况就悲剧了。。。</p><p>还有一个问题，就是我们要使用排他锁来进行分布式锁的 lock，那么一个排他锁长时间不提交，就会占用数据库连接。一旦类似的连接变得多了，就可能把数据库连接池撑爆。</p><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p><strong>优点</strong>：简单，易于理解</p><p><strong>缺点</strong>：会有各种各样的问题（操作数据库需要一定的开销，使用数据库的行级锁并不一定靠谱，性能不靠谱）</p><h3 id="基于-Redis-做分布式锁"><a href="#基于-Redis-做分布式锁" class="headerlink" title="基于 Redis 做分布式锁"></a>基于 Redis 做分布式锁</h3><h4 id="基于-redis-的-setnx-、expire-方法做分布式锁"><a href="#基于-redis-的-setnx-、expire-方法做分布式锁" class="headerlink" title="基于 redis 的 setnx()、expire() 方法做分布式锁"></a>基于 redis 的 setnx()、expire() 方法做分布式锁</h4><h5 id="setnx"><a href="#setnx" class="headerlink" title="setnx()"></a>setnx()</h5><p>setnx 的含义就是 SET if Not Exists，其主要有两个参数 setnx(key, value)。该方法是原子的，如果 key 不存在，则设置当前 key 成功，返回 1；如果当前 key 已经存在，则设置当前 key 失败，返回 0。</p><h5 id="expire"><a href="#expire" class="headerlink" title="expire()"></a>expire()</h5><p>expire 设置过期时间，要注意的是 setnx 命令不能设置 key 的超时时间，只能通过 expire() 来对 key 设置。</p><h5 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h5><p>1、setnx(lockkey, 1)  如果返回 0，则说明占位失败；如果返回 1，则说明占位成功</p><p>2、expire() 命令对 lockkey 设置超时时间，为的是避免死锁问题。</p><p>3、执行完业务代码后，可以通过 delete 命令删除 key。</p><p>这个方案其实是可以解决日常工作中的需求的，但从技术方案的探讨上来说，可能还有一些可以完善的地方。<strong>比如，如果在第一步 setnx 执行成功后，在 expire() 命令执行成功前，发生了宕机的现象，那么就依然会出现死锁的问题，所以如果要对其进行完善的话，可以使用 redis 的 setnx()、get() 和 getset() 方法来实现分布式锁。</strong></p><h4 id="基于-redis-的-setnx-、get-、getset-方法做分布式锁"><a href="#基于-redis-的-setnx-、get-、getset-方法做分布式锁" class="headerlink" title="基于 redis 的 setnx()、get()、getset()方法做分布式锁"></a>基于 redis 的 setnx()、get()、getset()方法做分布式锁</h4><p>这个方案的背景主要是在 setnx() 和 expire() 的方案上针对可能存在的死锁问题，做了一些优化。</p><h5 id="getset"><a href="#getset" class="headerlink" title="getset()"></a>getset()</h5><p>这个命令主要有两个参数 getset(key，newValue)。该方法是原子的，对 key 设置 newValue 这个值，并且返回 key 原来的旧值。假设 key 原来是不存在的，那么多次执行这个命令，会出现下边的效果：</p><ol><li>getset(key, “value1”)  返回 null   此时 key 的值会被设置为 value1</li><li>getset(key, “value2”)  返回 value1   此时 key 的值会被设置为 value2</li><li>依次类推！</li></ol><h5 id="使用步骤-1"><a href="#使用步骤-1" class="headerlink" title="使用步骤"></a>使用步骤</h5><ol><li>setnx(lockkey, 当前时间+过期超时时间)，如果返回 1，则获取锁成功；如果返回 0 则没有获取到锁，转向 2。</li><li>get(lockkey) 获取值 oldExpireTime ，并将这个 value 值与当前的系统时间进行比较，如果小于当前系统时间，则认为这个锁已经超时，可以允许别的请求重新获取，转向 3。</li><li>计算 newExpireTime = 当前时间+过期超时时间，然后 getset(lockkey, newExpireTime) 会返回当前 lockkey 的值currentExpireTime。</li><li>判断 currentExpireTime 与 oldExpireTime 是否相等，如果相等，说明当前 getset 设置成功，获取到了锁。如果不相等，说明这个锁又被别的请求获取走了，那么当前请求可以直接返回失败，或者继续重试。</li><li>在获取到锁之后，当前线程可以开始自己的业务处理，当处理完毕后，比较自己的处理时间和对于锁设置的超时时间，如果小于锁设置的超时时间，则直接执行 delete 释放锁；如果大于锁设置的超时时间，则不需要再锁进行处理。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cn.com.tpig.cache.redis.RedisService;</span><br><span class="line"><span class="keyword">import</span> cn.com.tpig.utils.SpringUtils;</span><br><span class="line"></span><br><span class="line"><span class="comment">//redis分布式锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisLockUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> defaultExpire = <span class="number">60</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">RedisLockUtil</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key redis key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> expire 过期时间，单位秒</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true:加锁成功，false，加锁失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">lock</span><span class="params">(String key, <span class="keyword">int</span> expire)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        RedisService redisService = SpringUtils.getBean(RedisService.class);</span><br><span class="line">        <span class="keyword">long</span> status = redisService.setnx(key, <span class="string">"1"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(status == <span class="number">1</span>) &#123;</span><br><span class="line">            redisService.expire(key, expire);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">lock</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lock2(key, defaultExpire);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key redis key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> expire 过期时间，单位秒</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true:加锁成功，false，加锁失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">lock2</span><span class="params">(String key, <span class="keyword">int</span> expire)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        RedisService redisService = SpringUtils.getBean(RedisService.class);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> value = System.currentTimeMillis() + expire;</span><br><span class="line">        <span class="keyword">long</span> status = redisService.setnx(key, String.valueOf(value));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(status == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> oldExpireTime = Long.parseLong(redisService.get(key, <span class="string">"0"</span>));</span><br><span class="line">        <span class="keyword">if</span>(oldExpireTime &lt; System.currentTimeMillis()) &#123;</span><br><span class="line">            <span class="comment">//超时</span></span><br><span class="line">            <span class="keyword">long</span> newExpireTime = System.currentTimeMillis() + expire;</span><br><span class="line">            <span class="keyword">long</span> currentExpireTime = Long.parseLong(redisService.getSet(key, String.valueOf(newExpireTime)));</span><br><span class="line">            <span class="keyword">if</span>(currentExpireTime == oldExpireTime) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">unLock1</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        RedisService redisService = SpringUtils.getBean(RedisService.class);</span><br><span class="line">        redisService.del(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">unLock2</span><span class="params">(String key)</span> </span>&#123;    </span><br><span class="line">        RedisService redisService = SpringUtils.getBean(RedisService.class);    </span><br><span class="line">        <span class="keyword">long</span> oldExpireTime = Long.parseLong(redisService.get(key, <span class="string">"0"</span>));   </span><br><span class="line">        <span class="keyword">if</span>(oldExpireTime &gt; System.currentTimeMillis()) &#123;        </span><br><span class="line">            redisService.del(key);    </span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawRedPacket</span><span class="params">(<span class="keyword">long</span> userId)</span> </span>&#123;</span><br><span class="line">    String key = <span class="string">"draw.redpacket.userid:"</span> + userId;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> lock = RedisLockUtil.lock2(key, <span class="number">60</span>);</span><br><span class="line">    <span class="keyword">if</span>(lock) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//领取操作</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//释放锁</span></span><br><span class="line">            RedisLockUtil.unLock(key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> RuntimeException(<span class="string">"重复领取奖励"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="基于-Redlock-做分布式锁"><a href="#基于-Redlock-做分布式锁" class="headerlink" title="基于 Redlock 做分布式锁"></a>基于 Redlock 做分布式锁</h4><p>Redlock 是 Redis 的作者 antirez 给出的集群模式的 Redis 分布式锁，它基于 N 个完全独立的 Redis 节点（通常情况下 N 可以设置成 5）。</p><p>算法的步骤如下：</p><ul><li>1、客户端获取当前时间，以毫秒为单位。</li><li>2、客户端尝试获取 N 个节点的锁，（每个节点获取锁的方式和前面说的缓存锁一样），N 个节点以相同的 key 和 value 获取锁。客户端需要设置接口访问超时，接口超时时间需要远远小于锁超时时间，比如锁自动释放的时间是 10s，那么接口超时大概设置 5-50ms。这样可以在有 redis 节点宕机后，访问该节点时能尽快超时，而减小锁的正常使用。</li><li>3、客户端计算在获得锁的时候花费了多少时间，方法是用当前时间减去在步骤一获取的时间，只有客户端获得了超过 3 个节点的锁，而且获取锁的时间小于锁的超时时间，客户端才获得了分布式锁。</li><li>4、客户端获取的锁的时间为设置的锁超时时间减去步骤三计算出的获取锁花费时间。</li><li>5、如果客户端获取锁失败了，客户端会依次删除所有的锁。<br>使用 Redlock 算法，可以保证在挂掉最多 2 个节点的时候，分布式锁服务仍然能工作，这相比之前的数据库锁和缓存锁大大提高了可用性，由于 redis 的高效性能，分布式缓存锁性能并不比数据库锁差。</li></ul><p>但是，有一位分布式的专家写了一篇文章《How to do distributed locking》，质疑 Redlock 的正确性。</p><p><a href="">https://mp.weixin.qq.com/s/1bPLk_VZhZ0QYNZS8LkviA</a></p><p><a href="">https://blog.csdn.net/jek123456/article/details/72954106</a></p><h4 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h4><p><strong>优点：</strong></p><p>性能高</p><p><strong>缺点：</strong></p><p>失效时间设置多长时间为好？如何设置的失效时间太短，方法没等执行完，锁就自动释放了，那么就会产生并发问题。如果设置的时间太长，其他获取锁的线程就可能要平白的多等一段时间。</p><h4 id="基于-redisson-做分布式锁"><a href="#基于-redisson-做分布式锁" class="headerlink" title="基于 redisson 做分布式锁"></a>基于 redisson 做分布式锁</h4><p>redisson 是 redis 官方的分布式锁组件。GitHub 地址：<a href="">https://github.com/redisson/redisson</a></p><p>上面的这个问题 ——&gt; 失效时间设置多长时间为好？这个问题在 redisson 的做法是：每获得一个锁时，只设置一个很短的超时时间，同时起一个线程在每次快要到超时时间时去刷新锁的超时时间。在释放锁的同时结束这个线程。</p><h3 id="基于-ZooKeeper-做分布式锁"><a href="#基于-ZooKeeper-做分布式锁" class="headerlink" title="基于 ZooKeeper 做分布式锁"></a>基于 ZooKeeper 做分布式锁</h3><h4 id="zookeeper-锁相关基础知识"><a href="#zookeeper-锁相关基础知识" class="headerlink" title="zookeeper 锁相关基础知识"></a>zookeeper 锁相关基础知识</h4><ul><li>zk 一般由多个节点构成（单数），采用 zab 一致性协议。因此可以将 zk 看成一个单点结构，对其修改数据其内部自动将所有节点数据进行修改而后才提供查询服务。</li><li>zk 的数据以目录树的形式，每个目录称为  znode， znode 中可存储数据（一般不超过 1M），还可以在其中增加子节点。</li><li>子节点有三种类型。序列化节点，每在该节点下增加一个节点自动给该节点的名称上自增。临时节点，一旦创建这个 znode 的客户端与服务器失去联系，这个 znode 也将自动删除。最后就是普通节点。</li><li>Watch 机制，client 可以监控每个节点的变化，当产生变化会给 client 产生一个事件。</li></ul><h4 id="zk-基本锁"><a href="#zk-基本锁" class="headerlink" title="zk 基本锁"></a>zk 基本锁</h4><ul><li>原理：利用临时节点与 watch 机制。每个锁占用一个普通节点 /lock，当需要获取锁时在 /lock 目录下创建一个临时节点，创建成功则表示获取锁成功，失败则 watch/lock 节点，有删除操作后再去争锁。临时节点好处在于当进程挂掉后能自动上锁的节点自动删除即取消锁。</li><li>缺点：所有取锁失败的进程都监听父节点，很容易发生羊群效应，即当释放锁后所有等待进程一起来创建节点，并发量很大。</li></ul><h4 id="zk-锁优化"><a href="#zk-锁优化" class="headerlink" title="zk 锁优化"></a>zk 锁优化</h4><ul><li>原理：上锁改为创建临时有序节点，每个上锁的节点均能创建节点成功，只是其序号不同。只有序号最小的可以拥有锁，如果这个节点序号不是最小的则 watch 序号比本身小的前一个节点 (公平锁)。</li><li>步骤：</li></ul><ol><li>在 /lock 节点下创建一个有序临时节点 (EPHEMERAL_SEQUENTIAL)。</li><li>判断创建的节点序号是否最小，如果是最小则获取锁成功。不是则取锁失败，然后 watch 序号比本身小的前一个节点。</li><li>当取锁失败，设置 watch 后则等待 watch 事件到来后，再次判断是否序号最小。</li><li>取锁成功则执行代码，最后释放锁（删除该节点）。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.CreateMode;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.KeeperException;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.WatchedEvent;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.Watcher;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.ZooDefs;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.ZooKeeper;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.data.Stat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DistributedLock</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">Watcher</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ZooKeeper zk;</span><br><span class="line">    <span class="keyword">private</span> String root = <span class="string">"/locks"</span>;<span class="comment">//根</span></span><br><span class="line">    <span class="keyword">private</span> String lockName;<span class="comment">//竞争资源的标志</span></span><br><span class="line">    <span class="keyword">private</span> String waitNode;<span class="comment">//等待前一个锁</span></span><br><span class="line">    <span class="keyword">private</span> String myZnode;<span class="comment">//当前锁</span></span><br><span class="line">    <span class="keyword">private</span> CountDownLatch latch;<span class="comment">//计数器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> sessionTimeout = <span class="number">30000</span>;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Exception&gt; exception = <span class="keyword">new</span> ArrayList&lt;Exception&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建分布式锁,使用前请确认config配置的zookeeper服务可用</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> config 127.0.0.1:2181</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lockName 竞争资源标志,lockName中不能包含单词lock</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DistributedLock</span><span class="params">(String config, String lockName)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lockName = lockName;</span><br><span class="line">        <span class="comment">// 创建一个与服务器的连接</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            zk = <span class="keyword">new</span> ZooKeeper(config, sessionTimeout, <span class="keyword">this</span>);</span><br><span class="line">            Stat stat = zk.exists(root, <span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">if</span>(stat == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="comment">// 创建根节点</span></span><br><span class="line">                zk.create(root, <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>], ZooDefs.Ids.OPEN_ACL_UNSAFE,CreateMode.PERSISTENT);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            exception.add(e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (KeeperException e) &#123;</span><br><span class="line">            exception.add(e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            exception.add(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * zookeeper节点的监视器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.latch != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.latch.countDown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(exception.size() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> LockException(exception.get(<span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.tryLock())&#123;</span><br><span class="line">                System.out.println(<span class="string">"Thread "</span> + Thread.currentThread().getId() + <span class="string">" "</span> +myZnode + <span class="string">" get lock true"</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                waitForLock(waitNode, sessionTimeout);<span class="comment">//等待锁</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (KeeperException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> LockException(e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> LockException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String splitStr = <span class="string">"_lock_"</span>;</span><br><span class="line">            <span class="keyword">if</span>(lockName.contains(splitStr))</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> LockException(<span class="string">"lockName can not contains \\u000B"</span>);</span><br><span class="line">            <span class="comment">//创建临时子节点</span></span><br><span class="line">            myZnode = zk.create(root + <span class="string">"/"</span> + lockName + splitStr, <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>], ZooDefs.Ids.OPEN_ACL_UNSAFE,CreateMode.EPHEMERAL_SEQUENTIAL);</span><br><span class="line">            System.out.println(myZnode + <span class="string">" is created "</span>);</span><br><span class="line">            <span class="comment">//取出所有子节点</span></span><br><span class="line">            List&lt;String&gt; subNodes = zk.getChildren(root, <span class="keyword">false</span>);</span><br><span class="line">            <span class="comment">//取出所有lockName的锁</span></span><br><span class="line">            List&lt;String&gt; lockObjNodes = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">            <span class="keyword">for</span> (String node : subNodes) &#123;</span><br><span class="line">                String _node = node.split(splitStr)[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">if</span>(_node.equals(lockName))&#123;</span><br><span class="line">                    lockObjNodes.add(node);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            Collections.sort(lockObjNodes);</span><br><span class="line">            System.out.println(myZnode + <span class="string">"=="</span> + lockObjNodes.get(<span class="number">0</span>));</span><br><span class="line">            <span class="keyword">if</span>(myZnode.equals(root+<span class="string">"/"</span>+lockObjNodes.get(<span class="number">0</span>)))&#123;</span><br><span class="line">                <span class="comment">//如果是最小的节点,则表示取得锁</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果不是最小的节点，找到比自己小1的节点</span></span><br><span class="line">            String subMyZnode = myZnode.substring(myZnode.lastIndexOf(<span class="string">"/"</span>) + <span class="number">1</span>);</span><br><span class="line">            waitNode = lockObjNodes.get(Collections.binarySearch(lockObjNodes, subMyZnode) - <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (KeeperException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> LockException(e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> LockException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.tryLock())&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> waitForLock(waitNode,time);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">waitForLock</span><span class="params">(String lower, <span class="keyword">long</span> waitTime)</span> <span class="keyword">throws</span> InterruptedException, KeeperException </span>&#123;</span><br><span class="line">        Stat stat = zk.exists(root + <span class="string">"/"</span> + lower,<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">//判断比自己小一个数的节点是否存在,如果不存在则无需等待锁,同时注册监听</span></span><br><span class="line">        <span class="keyword">if</span>(stat != <span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"Thread "</span> + Thread.currentThread().getId() + <span class="string">" waiting for "</span> + root + <span class="string">"/"</span> + lower);</span><br><span class="line">            <span class="keyword">this</span>.latch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">this</span>.latch.await(waitTime, TimeUnit.MILLISECONDS);</span><br><span class="line">            <span class="keyword">this</span>.latch = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"unlock "</span> + myZnode);</span><br><span class="line">            zk.delete(myZnode,-<span class="number">1</span>);</span><br><span class="line">            myZnode = <span class="keyword">null</span>;</span><br><span class="line">            zk.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (KeeperException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">LockException</span><span class="params">(String e)</span></span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">LockException</span><span class="params">(Exception e)</span></span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="优缺点-2"><a href="#优缺点-2" class="headerlink" title="优缺点"></a>优缺点</h4><p><strong>优点：</strong></p><p>有效的解决单点问题，不可重入问题，非阻塞问题以及锁无法释放的问题。实现起来较为简单。</p><p><strong>缺点：</strong></p><p>性能上可能并没有缓存服务那么高，因为每次在创建锁和释放锁的过程中，都要动态创建、销毁临时节点来实现锁功能。ZK 中创建和删除节点只能通过 Leader 服务器来执行，然后将数据同步到所有的 Follower 机器上。还需要对 ZK的原理有所了解。</p><h3 id="基于-Consul-做分布式锁"><a href="#基于-Consul-做分布式锁" class="headerlink" title="基于 Consul 做分布式锁"></a>基于 Consul 做分布式锁</h3><p>DD 写过类似文章，其实主要利用 Consul 的 Key / Value 存储 API 中的 acquire 和 release 操作来实现。</p><p>文章地址：<a href="">http://blog.didispace.com/spring-cloud-consul-lock-and-semphore/</a></p><h3 id="使用分布式锁的注意事项"><a href="#使用分布式锁的注意事项" class="headerlink" title="使用分布式锁的注意事项"></a>使用分布式锁的注意事项</h3><p>1、注意分布式锁的开销</p><p>2、注意加锁的粒度</p><p>3、加锁的方式</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>无论你身处一个什么样的公司，最开始的工作可能都需要从最简单的做起。不要提阿里和腾讯的业务场景 qps 如何大，因为在这样的大场景中你未必能亲自参与项目，亲自参与项目未必能是核心的设计者，是核心的设计者未必能独自设计。希望大家能根据自己公司业务场景，选择适合自己项目的方案。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="">http://www.hollischuang.com/archives/1716</a></p><p><a href="">http://www.spring4all.com/question/158</a></p><p><a href="">https://www.cnblogs.com/PurpleDream/p/5559352.html</a></p><p><a href="">http://www.cnblogs.com/PurpleDream/p/5573040.html</a></p><p><a href="">https://www.cnblogs.com/suolu/p/6588902.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://ws3.sinaimg.cn/large/006tKfTcgy1fqp2lqscrwj31hc0zk46a.jpg&quot; alt=&quot;meadow-811339_1920&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="分布式锁" scheme="http://yoursite.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    
      <category term="数据库" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
      <category term="Zookeeper" scheme="http://yoursite.com/tags/Zookeeper/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot 2.0系列文章(六)：Spring Boot 2.0中SpringBootApplication注解详解</title>
    <link href="http://yoursite.com/2018/04/19/SpringBootApplication-annotation/"/>
    <id>http://yoursite.com/2018/04/19/SpringBootApplication-annotation/</id>
    <published>2018-04-18T16:00:00.000Z</published>
    <updated>2018-05-02T13:27:38.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1fqifa86vplj31hc0p0n7e.jpg" alt="nature-3201015_1920"></p><a id="more"></a><h3 id="关注我"><a href="#关注我" class="headerlink" title="关注我"></a>关注我</h3><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180103/C6LG3mGa12.jpg" alt="mark"></p><p>转载请务必注明原创地址为：<a href="http://www.54tianzhisheng.cn/2018/04/19/SpringBootApplication-annotation/" target="_blank" rel="noopener">http://www.54tianzhisheng.cn/2018/04/19/SpringBootApplication-annotation/</a></p><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>许多 Spring Boot 开发者喜欢他们的应用程序使用自动配置、组件扫描、并能够在他们的 “Application” 类上定义额外的配置。 可以使用一个 <code>@SpringBootApplication</code> 注解来启用这些功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">SpringApplication.run(Application.class, args);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SpringBootApplication"><a href="#SpringBootApplication" class="headerlink" title="@SpringBootApplication"></a>@SpringBootApplication</h3><p>跟进去 <code>@SpringBootApplication</code>  注解可以发现下图：</p><p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1fqifa18tt5j31kw17uap2.jpg" alt="springbootapplication"></p><p>其中标注的三个注解正能解决我们上面所说的三种功能，它们是：</p><ul><li><code>@SpringBootConfiguration</code></li><li><code>@EnableAutoConfiguration</code></li><li><code>@ComponentScan</code></li></ul><p>该接口除了上面三个注解外，还有四个方法如下：</p><p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fqifa27hu2j31kw1aqgy0.jpg" alt="springbootapplication"></p><ul><li>Class&lt;?&gt;[] exclude() default {}:<br>根据 class 来排除，排除特定的类加入 spring 容器，传入参数 value 类型是 class 类型。</li><li>String[] excludeName() default {}:<br>根据 class name 来排除，排除特定的类加入 spring 容器，传入参数 value 类型是 class 的全类名字符串数组。</li><li>String[] scanBasePackages() default {}:<br>指定扫描包，参数是包名的字符串数组。</li><li>Class&lt;?&gt;[] scanBasePackageClasses() default {}:<br>扫描特定的包，参数类似是 Class 类型数组。</li></ul><p>就拿 scanBasePackages 来举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span>(scanBasePackages = &#123;<span class="string">"com.zhisheng.controller"</span>,<span class="string">"com.zhisheng.model"</span>&#125;)</span><br></pre></td></tr></table></figure><p>将不需要的 bean 排除在 spring 容器中，如何操作？看看官方的代码怎么用的：</p><p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1fqifa5xheaj31kw12rwsj.jpg" alt="sb-enableautoconfig-exclude"></p><h3 id="SpringBootConfiguration"><a href="#SpringBootConfiguration" class="headerlink" title="@SpringBootConfiguration"></a>@SpringBootConfiguration</h3><p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fqifab18l3j31kw0w4jyu.jpg" alt="springbootconfiguration"></p><p><code>@SpringBootConfiguration</code>继承自<code>@Configuration</code>，二者功能也一致，标注当前类是配置类，并会将当前类内声明的一个或多个以<code>@Bean</code>注解标记的方法的实例纳入到<code>srping</code>容器中，并且实例名就是方法名。</p><p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fqifa4wulcj31h80qgjy9.jpg" alt="configuration"></p><p>虽说现在已经推荐使用 Spring Boot 里面的 <code>@SpringBootConfiguration</code> 注解，为了探个究竟，我们还是继续研究下 <code>@Configuration</code> 注解。</p><h4 id="Configuration"><a href="#Configuration" class="headerlink" title="@Configuration"></a>@Configuration</h4><p>@Configuration 标注在类上，相当于把该类作为 spring 的 xml 配置文件中的 <code>&lt;beans&gt;</code>，作用为：配置 spring 容器(应用上下文)</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="Bean"><a href="#Bean" class="headerlink" title="@Bean"></a>@Bean</h4><p>@Bean 标注在方法上(返回某个实例的方法)，等价于 spring 的 xml 配置文件中的<code>&lt;bean&gt;</code>，作用为：注册 bean 对象</p><p>可以看看这篇文章：<a href="">https://www.ibm.com/developerworks/cn/webservices/ws-springjava/index.html</a></p><h3 id="ComponentScan"><a href="#ComponentScan" class="headerlink" title="@ComponentScan"></a>@ComponentScan</h3><p>可以通过该注解指定扫描某些包下包含如下注解的均自动注册为 spring beans：</p><p>@Component、@Service、 @Repository、 @Controller、@Entity 等等</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ComponentScan</span>(basePackages = &#123;<span class="string">"com.zhisheng.controller"</span>,<span class="string">"com.zhisheng.model"</span>&#125;)</span><br></pre></td></tr></table></figure><p>以前是在 xml 配置文件中设置如下标签：<code>&lt;context:component-scan&gt;</code>（用来扫描包配置）</p><p>除了可以使用 <code>@ComponentScan</code>  注解来加载我们的 bean，还可以在 Application 类中使用 <code>@Import</code> 指定该类。</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Import</span>(&#123;ConsulConfig.class, Log4jEndPointConfiguration.class&#125;)<span class="comment">//直接 imoport 要引入的类</span></span><br></pre></td></tr></table></figure><h3 id="EnableAutoConfiguration"><a href="#EnableAutoConfiguration" class="headerlink" title="@EnableAutoConfiguration"></a>@EnableAutoConfiguration</h3><p><code>@EnableAutoConfiguration</code>的作用启动自动的配置，<code>@EnableAutoConfiguration</code>注解的意思就是<code>Springboot</code>根据你添加的 jar 包来配置你项目的默认配置，比如根据<code>spring-boot-starter-web</code> ，来判断你的项目是否需要添加了<code>webmvc</code>和<code>tomcat</code>，就会自动的帮你配置 web 项目中所需要的默认配置。简单点说就是它会根据定义在 classpath 下的类，自动的给你生成一些 Bean，并加载到 Spring 的 Context 中。</p><p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fqifa6z9noj31kw1c8k9o.jpg" alt="enable-autoconfiguration"></p><p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1fqifaa174hj317i0tun1o.jpg" alt="2018-04-19_18-44-22"></p><p>可以看到 import  引入了 AutoConfigurationImportSelector 类。该类使用了 Spring Core 包的 SpringFactoriesLoader 类的 loadFactoryNamesof() 方法。</p><p>AutoConfigurationImportSelector 类实现了 DeferredImportSelector 接口，并实现了 <strong>selectImports</strong> 方法，用来导出<em>Configuration</em> 类。</p><p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fqifad0xvxj31kw0xw1eq.jpg" alt="getconfigurations"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes);</span><br></pre></td></tr></table></figure><p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fqifabw5ksj31bk0mwdlf.jpg" alt="getconfigurations01"></p><p>导出的类是通过 <em>SpringFactoriesLoader.loadFactoryNames()</em> 读取了 <em>ClassPath</em> 下面的 <em>META-INF/spring.factories</em> 文件。</p><p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fqifa972ujj31kw0wj4d6.jpg" alt="loadfactoryname"></p><p>这个文件内容大致如下。</p><p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1fqifa3k9x8j31k41f2h3x.jpg" alt="springfactories"></p><p>后面继续会写自动配置方面的博客，请继续关注！</p><p>如果你发现自动装配的 Bean 不是你想要的，你也可以 disable 它。比如说，我不想要自动装配 Database 的那些Bean：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableAutoConfiguration</span>(exclude = &#123;DataSourceAutoConfiguration.class&#125;)</span><br></pre></td></tr></table></figure><h3 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h3><p>1、<a href="http://www.54tianzhisheng.cn/2018/03/06/SpringBoot2-Migration-Guide/" target="_blank" rel="noopener">Spring Boot 2.0系列文章(一)：Spring Boot 2.0 迁移指南</a></p><p>2、<a href="http://www.54tianzhisheng.cn/2018/03/06/SpringBoot2-new-features/" target="_blank" rel="noopener">Spring Boot 2.0系列文章(二)：Spring Boot 2.0 新特性详解</a></p><p>3、<a href="http://www.54tianzhisheng.cn/2018/04/13/Spring_Boot_2.0_Configuration_Changelog/" target="_blank" rel="noopener">Spring Boot 2.0系列文章(三)：Spring Boot 2.0 配置改变</a></p><p>4、<a href="http://www.54tianzhisheng.cn/2018/04/15/springboot2_code/" target="_blank" rel="noopener">Spring Boot 2.0系列文章(四)：Spring Boot 2.0 源码阅读环境搭建</a></p><p>5、<a href="http://www.54tianzhisheng.cn/2018/04/18/spring_boot2_project/" target="_blank" rel="noopener">Spring Boot 2.0系列文章(五)：Spring Boot 2.0 项目源码结构预览</a></p><p>6、<a href="http://www.54tianzhisheng.cn/2018/04/19/SpringBootApplication-annotation/" target="_blank" rel="noopener">Spring Boot 2.0系列文章(六)：Spring boot 2.0 中 SpringBootApplication 注解详解</a></p><p>7、<a href="http://www.54tianzhisheng.cn/2018/04/30/springboot_SpringApplication/" target="_blank" rel="noopener">Spring Boot 2.0系列文章(七)：SpringApplication 深入探索</a></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文主要讲了 SpringBootApplication 注解，然后展开写了其包含的三个注解 SpringBootConfiguration、ComponentScan、EnableAutoConfiguration</p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>虽然源码很难，但随着不断的探索，源码在你面前将会一览无遗，享受这种探索后的成就感！加油！骚年！</p><p>自己本人能力有限，源码看的不多，上面如有不对的还请留言交流。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://ws4.sinaimg.cn/large/006tKfTcgy1fqifa86vplj31hc0p0n7e.jpg&quot; alt=&quot;nature-3201015_1920&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="SpringBoot" scheme="http://yoursite.com/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot 2.0系列文章(五)：Spring Boot 2.0 项目源码结构预览</title>
    <link href="http://yoursite.com/2018/04/18/spring_boot2_project/"/>
    <id>http://yoursite.com/2018/04/18/spring_boot2_project/</id>
    <published>2018-04-17T16:00:00.000Z</published>
    <updated>2018-05-02T13:27:46.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1fqhraflay7j31hc0zk0z1.jpg" alt="fireworks-2585843_1920"></p><a id="more"></a><h3 id="关注我"><a href="#关注我" class="headerlink" title="关注我"></a>关注我</h3><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180103/C6LG3mGa12.jpg" alt="mark"></p><p>转载请务必注明原创地址为：<a href="http://www.54tianzhisheng.cn/2018/04/18/spring_boot2_project/" target="_blank" rel="noopener">http://www.54tianzhisheng.cn/2018/04/15/springboot2_code/</a></p><h3 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h3><p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1fqhsa07r59j30ps104gpd.jpg" alt="springboot2001"></p><p>结构分析：</p><ul><li>Spring-boot-project   核心代码，代码量很多（197508 行）</li><li>Spring-boot-samples  一些样例 demo，代码量不多（9685 行），蛮有用的</li><li>Spring-boot-samples-invoker  里面无代码</li><li>Spring-boot-tests   测试代码（1640 行）</li></ul><h3 id="spring-boot-project"><a href="#spring-boot-project" class="headerlink" title="spring-boot-project"></a>spring-boot-project</h3><p>Spring-boot-project 下面有很多模块，如下：</p><p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fqhs874239j30p00n2dip.jpg" alt="springboot2002"></p><h4 id="Spirng-boot"><a href="#Spirng-boot" class="headerlink" title="Spirng-boot"></a>Spirng-boot</h4><p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fqhs885a4zj30xk1ea78a.jpg" alt="springboot"></p><p>该模块 47760 行代码（含测试代码），Spring boot 主要的库，提供了支持 Spring Boot 其他部分的功能，其中包括了：</p><ul><li>在<code>SpringApplication</code>类，提供静态便捷方法，可以很容易写一个独立的 Spring 应用程序。它唯一的工作就是创造并更新一个合适的 Spring<code>ApplicationContext</code></li><li>带有可选容器的嵌入式 Web 应用程序（Tomcat，Jetty 或 Undertow）</li><li>一流的外部配置支持</li><li>便捷<code>ApplicationContext</code>初始化程序，包括对敏感日志记录默认值的支持</li></ul><h4 id="spring-boot-actuator"><a href="#spring-boot-actuator" class="headerlink" title="spring-boot-actuator"></a>spring-boot-actuator</h4><p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fqhs8ibzjzj30xk15mjv8.jpg" alt="springboot-actuator"></p><p>该模块 18398 行代码（含测试代码），spring-boot-actuator 模块它完全是一个用于暴露自身信息的模块，提供了一个监控和管理生产环境的模块，可以使用 http、jmx、ssh、telnet 等管理和监控应用。审计（Auditing）、 健康（health）、数据采集（metrics gathering）会自动加入到应用里面。</p><h4 id="spring-boot-actuator-autoconfigure"><a href="#spring-boot-actuator-autoconfigure" class="headerlink" title="spring-boot-actuator-autoconfigure"></a>spring-boot-actuator-autoconfigure</h4><p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1fqhs8hfazpj30wi1dy0xb.jpg" alt="springboot-actoator-autoconfig"></p><p>该模块 16721 行代码（含测试代码），Spring Boot Actuator 提供了额外的自动配置功能，可以在生产环境中实现可即时部署和支持的功能，从而装饰你的应用。例如，如果您正在编写 JSON Web 服务，那么它将提供服务器，安全性，日志记录，外部配置，管理端点，审计抽象等等功能。如果您想关闭内置功能，或者扩展或替换它们，它也会变得非常简单。</p><h4 id="spring-boot-autoconfigure"><a href="#spring-boot-autoconfigure" class="headerlink" title="spring-boot-autoconfigure"></a>spring-boot-autoconfigure</h4><p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fqhs89img2j30xs0og0uz.jpg" alt="springboot-autoconfig"></p><p>该模块 51100 行代码（含测试代码）， Spring Boot 可以根据类路径的内容配置大部分常用应用程序。单个<code>@EnableAutoConfiguration</code>注释会触发 Spring上下文的自动配置。</p><p>自动配置尝试推断用户可能需要哪些 bean。例如，如果 <code>HSQLDB</code>在类路径中，并且用户尚未配置任何数据库连接，则他们可能需要定义内存数据库。当用户开始定义他们自己的 bean 时，自动配置将永远远离。</p><h4 id="spring-boot-cli"><a href="#spring-boot-cli" class="headerlink" title="spring-boot-cli"></a>spring-boot-cli</h4><p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fqhsa2hmasj30x21aqq6j.jpg" alt="springboot-cli"></p><p>该模块 9346 行代码（含测试代码），Spring 命令行应用程序编译并运行 Groovy 源代码，使得可以编写少量代码就能运行应用程序。Spring CLI 也可以监视文件，当它们改变时自动重新编译并重新启动。</p><h4 id="spring-boot-dependencies"><a href="#spring-boot-dependencies" class="headerlink" title="spring-boot-dependencies"></a>spring-boot-dependencies</h4><p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1fqhs9xrj6qj31kw16be31.jpg" alt="springboot-dependencies"></p><p>该模块里面没有源码，只有所有依赖和插件的版本号信息。</p><h4 id="spring-boot-devtools"><a href="#spring-boot-devtools" class="headerlink" title="spring-boot-devtools"></a>spring-boot-devtools</h4><p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1fqhs9z88hrj30v41bw785.jpg" alt="springboot-devtools"></p><p>该模块 9418 行代码（含测试代码），spring-boot-devtools 模块来使 Spring Boot 应用支持热部署，提高开发者的开发效率，无需手动重启 Spring Boot 应用。</p><h4 id="spring-boot-docs"><a href="#spring-boot-docs" class="headerlink" title="spring-boot-docs"></a>spring-boot-docs</h4><p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fqhs8affekj30xo1ecdkr.jpg" alt="springboot-docs"></p><p>该模块 671 行代码，springboot 参考文件。</p><h4 id="spring-boot-parent"><a href="#spring-boot-parent" class="headerlink" title="spring-boot-parent"></a>spring-boot-parent</h4><p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1fqhs8dxfnij31kw0zrqkw.jpg" alt="springboot-parent"></p><p>该模块是其他项目的 parent，该模块的父模块是 spring-boot-dependencies。</p><h4 id="spring-boot-properties-migrator"><a href="#spring-boot-properties-migrator" class="headerlink" title="spring-boot-properties-migrator"></a>spring-boot-properties-migrator</h4><p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fqhs9wkyvsj30um18678o.jpg" alt="springboot-properties-migrator"></p><p>该模块有 495 行代码，在 Spring Boot 2.0 中，许多配置属性被重新命名/删除，开发人员需要更新<code>application.properties</code>/ <code>application.yml</code>相应的配置。为了帮助你解决这一问题，Spring Boot 发布了一个新<code>spring-boot-properties-migrator</code>模块。一旦作为该模块作为依赖被添加到你的项目中，它不仅会分析应用程序的环境，而且还会在启动时打印诊断信息，而且还会在运行时为您暂时迁移属性。在您的应用程序迁移期间，这个模块是必备的，完成迁移后，请确保从项目的依赖关系中删除此模块。</p><h4 id="spring-boot-starters"><a href="#spring-boot-starters" class="headerlink" title="spring-boot-starters"></a>spring-boot-starters</h4><p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1fqhs8foqadj31he1hwh5l.jpg" alt="springboot-starter"></p><p>Starter POMs 是由很多方便的依赖集合组成，如果你需要使用某种技术，通过添加少量的jar就可以把相关的依赖加入到项目中去。</p><p>虽然你看得到有这么多 starter，但是却没有一行 Java 代码，意不意外？</p><p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1fqhs84zby0j31kw0xdkb0.jpg" alt="springboot-starter-activemq"></p><p>这确实是 Spring Boot 自动配置的关键之处，后面我可以讲讲。</p><h4 id="spring-boot-test"><a href="#spring-boot-test" class="headerlink" title="spring-boot-test"></a>spring-boot-test</h4><p>测试代码！有 10980 行代码。</p><h4 id="spring-boot-test-autoconfigure"><a href="#spring-boot-test-autoconfigure" class="headerlink" title="spring-boot-test-autoconfigure"></a>spring-boot-test-autoconfigure</h4><p>自动配置的测试代码，有 6063 行代码。</p><h4 id="spring-boot-tools"><a href="#spring-boot-tools" class="headerlink" title="spring-boot-tools"></a>spring-boot-tools</h4><p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1fqhs8kcu5ej30ri0lqwh5.jpg" alt="springboot-tools"></p><ul><li><p>spring-boot-antlib</p><p>Spring Boot AntLib 模块为 Apache Ant 提供了基本的 Spring Boot 支持。 您可以使用该模块创建可执行文件夹。 要使用该模块，您需要在 build.xml 中声明一个额外的 spring-boot 命名空间，如以下示例所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns:ivy</span>=<span class="string">"antlib:org.apache.ivy.ant"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:spring-boot</span>=<span class="string">"antlib:org.springframework.boot.ant"</span></span></span><br><span class="line"><span class="tag"><span class="attr">name</span>=<span class="string">"myapp"</span> <span class="attr">default</span>=<span class="string">"build"</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>您需要记住使用 -lib 选项启动 Ant，如以下示例所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ant -lib &lt;folder containing spring-boot-antlib-2.1.0.BUILD-SNAPSHOT.jar&gt;</span><br></pre></td></tr></table></figure></li><li><p>Spring-boot-autoconfigure-processor</p><p>spring boot 自动配置的核心类</p></li><li><p>Spring-boot-configuration-metadata</p><p>Spring boot 配置元数据</p></li><li><p>Spring-boot-configuration-processor</p><p>spring boot 配置的核心</p></li><li><p>Spring-boot-gradle-plugin</p><p>Spring Boot Gradle 插件在 Gradle 中提供了 Spring Boot 支持，可以打包成可执行 jar 或 war ，运行 Spring Boot 应用程序，并使用 spring-boot-dependencies 提供的依赖关系管理。 它需要 Gradle 4.0 或更高版本。</p></li><li><p>Spring-boot-maven-plugin</p><p>Spring Boot Maven Plugin 在 Maven 中提供了 Spring Boot 支持，让您可以打包成可执行 jar 或 war 应用，并“就地”运行应用程序。 要使用它，你必须使用 Maven 3.2（或更高版本）。</p></li><li><p>Spring-boot-loader</p><p>spring-boot-load 模块通过自定义 jar 包结构，自定义类加载器，优雅的实现了嵌套 jar 资源的加载，通过打包时候重新设置启动类和组织 jar 结构，通过运行时设置自定义加载器来实现嵌套 jar 资源加载。</p></li><li><p>Spring-boot-loader-tools</p><p>spring-boot-load 模块的工具模块</p></li><li><p>Spring-boot-test-support</p><p>测试</p></li></ul><h3 id="spring-boot-samples"><a href="#spring-boot-samples" class="headerlink" title="spring-boot-samples"></a>spring-boot-samples</h3><p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fqhsa4qklcj31kw11y7ud.jpg" alt="springboot-samples"></p><p>样例 demo 比较多，大家看源码的时候可以拿这些现成 demo 测试。</p><h3 id="spring-boot-tests"><a href="#spring-boot-tests" class="headerlink" title="spring-boot-tests"></a>spring-boot-tests</h3><p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fqhs8cezdbj30ui1dqagt.jpg" alt="springboot-tests"></p><h3 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h3><p>1、<a href="http://www.54tianzhisheng.cn/2018/03/06/SpringBoot2-Migration-Guide/" target="_blank" rel="noopener">Spring Boot 2.0系列文章(一)：Spring Boot 2.0 迁移指南</a></p><p>2、<a href="http://www.54tianzhisheng.cn/2018/03/06/SpringBoot2-new-features/" target="_blank" rel="noopener">Spring Boot 2.0系列文章(二)：Spring Boot 2.0 新特性详解</a></p><p>3、<a href="http://www.54tianzhisheng.cn/2018/04/13/Spring_Boot_2.0_Configuration_Changelog/" target="_blank" rel="noopener">Spring Boot 2.0系列文章(三)：Spring Boot 2.0 配置改变</a></p><p>4、<a href="http://www.54tianzhisheng.cn/2018/04/15/springboot2_code/" target="_blank" rel="noopener">Spring Boot 2.0系列文章(四)：Spring Boot 2.0 源码阅读环境搭建</a></p><p>5、<a href="http://www.54tianzhisheng.cn/2018/04/18/spring_boot2_project/" target="_blank" rel="noopener">Spring Boot 2.0系列文章(五)：Spring Boot 2.0 项目源码结构预览</a></p><p>6、<a href="http://www.54tianzhisheng.cn/2018/04/19/SpringBootApplication-annotation/" target="_blank" rel="noopener">Spring Boot 2.0系列文章(六)：Spring boot 2.0 中 SpringBootApplication 注解详解</a></p><p>7、<a href="http://www.54tianzhisheng.cn/2018/04/30/springboot_SpringApplication/" target="_blank" rel="noopener">Spring Boot 2.0系列文章(七)：SpringApplication 深入探索</a></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文主要分析了下 Spring boot 项目源码结构。包含 Spring boot 核心源码、样例 demo、测试。分析了项目的整体结构后，后面才能够有的放矢的去读源码。</p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>虽然源码很难，但随着不断的探索，源码在你面前将会一览无遗，享受这种探索后的成就感！加油！骚年！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/006tKfTcgy1fqhraflay7j31hc0zk0z1.jpg&quot; alt=&quot;fireworks-2585843_1920&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="SpringBoot" scheme="http://yoursite.com/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot 2.0系列文章(四)：Spring Boot 2.0 源码阅读环境搭建</title>
    <link href="http://yoursite.com/2018/04/15/springboot2_code/"/>
    <id>http://yoursite.com/2018/04/15/springboot2_code/</id>
    <published>2018-04-14T16:00:00.000Z</published>
    <updated>2018-05-02T13:28:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fqdma0kpk1j31hc0zkqox.jpg" alt="night-photograph-2183637_1920"></p><a id="more"></a><h3 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h3><p>前几天面试的时候，被问过 Spring Boot 的自动配置源码怎么实现的，没看过源码的我只能投降👦了。</p><p>这不，赶紧来补补了，所以才有了这篇文章的出现，Spring Boot 2. 0 源码阅读环境的搭建中还遇到点问题，被坑死了，还好解决了，感谢群里的小伙伴！</p><h3 id="关注我"><a href="#关注我" class="headerlink" title="关注我"></a>关注我</h3><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180103/C6LG3mGa12.jpg" alt="mark"></p><p>转载请务必注明原创地址为：<a href="http://www.54tianzhisheng.cn/2018/04/15/springboot2_code/" target="_blank" rel="noopener">http://www.54tianzhisheng.cn/2018/04/15/springboot2_code/</a></p><h3 id="项目下载"><a href="#项目下载" class="headerlink" title="项目下载"></a>项目下载</h3><p>从 <a href="https://github.com/spring-projects/spring-boot/releases" target="_blank" rel="noopener">https://github.com/spring-projects/spring-boot/releases</a> 可以看到所有版本的下载地址，我这里选择的是 Spring Boot 2 中最新的  <a href="https://github.com/spring-projects/spring-boot/releases/tag/v2.0.1.RELEASE" target="_blank" rel="noopener">v2.0.1.RELEASE </a> 版本，下载后，然后解压。获取代码之前，请先确保你的 JDK 版本是 1.8 以上哦。</p><h3 id="项目编译"><a href="#项目编译" class="headerlink" title="项目编译"></a>项目编译</h3><p>进入 spring-boot-2.0.1.RELEASE 的目录下，执行下面的命令。</p><h4 id="跳过测试用例编译"><a href="#跳过测试用例编译" class="headerlink" title="跳过测试用例编译"></a>跳过测试用例编译</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mvn clean install -DskipTests -Pfast //跳过测试用例</span><br></pre></td></tr></table></figure><p>跳过测试用例可以加快编译的速度。</p><p>先看下运行成功的效果：</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fqdm9wd342j31gc1mc7n7.jpg" alt="springboot201"></p><p>只花了 6 分多钟就好了。</p><h4 id="全量编译"><a href="#全量编译" class="headerlink" title="全量编译"></a>全量编译</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mvn -f spring-boot-project -Pfull clean install</span><br></pre></td></tr></table></figure><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fqdm9xd4pdj31kw18l7s3.jpg" alt="springboot2-error3"></p><p>全量编译竟然报错，一波未平，一波又起！</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fqdm9y57j4j31kw0e7wls.jpg" alt="2018-04-15_15-37-25"></p><p>看网上的解决方法是：在项目的 pom.xml 文件中的 <code>&lt;properties&gt;</code> 添加 <code>&lt;javadocExecutable&gt;</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">javadocExecutable</span>&gt;</span>$&#123;java.home&#125;/../bin/javadoc<span class="tag">&lt;/<span class="name">javadocExecutable</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure><p>此方法虽然管用，但是只是临时的，需要对每个项目都进行添加。</p><p>问题产生的原因应该是，mvn 拿到的 JAVA_HOME 位置应该是 ${JAVA_HOME}/jre 而不是 jdk 位置。</p><p>后面又看官方的 README 上面写的执行命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mvn clean install</span><br></pre></td></tr></table></figure><p>执行后也是有各种报错，尝试了很久解决，最后花了好几个小时才到下面这图：</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fqdma1lfkdj31kw0yqh5s.jpg" alt="springboot2-error4"></p><p>太折腾人了，太麻烦了！</p><p>暂时就不全量编译了，我们就直接把现在 <code>跳过测试用例编译</code>  后的项目导入到 IDEA 中去。</p><h3 id="导入项目工程"><a href="#导入项目工程" class="headerlink" title="导入项目工程"></a>导入项目工程</h3><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fqdma2dis9j31ia10447y.jpg" alt="import"></p><p>导入后将那些测试的 module 标记为 maven 项目，然后后面自己再根据测试用例去跟源码吧。</p><p>导入后项目没出现报错，美滋滋，后面源码可以看起来。</p><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fqdm9ipwfhj31kw0zkkj1.jpg" alt="success02"></p><h3 id="遇到的坑"><a href="#遇到的坑" class="headerlink" title="遇到的坑"></a>遇到的坑</h3><p>在这之前，我自己创建项目 Spring Boot 2 项目都是失败的，maven 运行项目（mvn clean install）报错如下：</p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fqdm9wsmiqj31gc1mc7n7.jpg" alt="springboot2-error2"></p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fqdm9zrq04j31kw0wru0p.jpg" alt="springboot2-error"></p><p>通过上图可以发现报错的罪魁祸首是由于找不到 org.yaml.snakeyaml  1.19 的包，这个依赖死活下不下来，苦逼了😢。</p><p>一开始以为是公司配的 maven setting.xml 文件有问题（公司私服有问题），导致我这个  org.yaml.snakeyaml  1.19 的包一直下载不来。后来我叫群里的好友帮忙测试下能不能创建 Spring Boot 2 项目，结果他们都行的。我就换成了他们阿里云镜像的 setting 文件，结果在我这还是不行的。真是醉了，我干脆直接叫他把 maven 本地仓库中的 org.yaml.snakeyaml  1.19 整个包都发给我，结果再次创建 Spring Boot 2 项目就能成功了。美滋滋😄！</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fqdm9yr6s8j31kw0o3tkj.jpg" alt="springboot2-success"></p><p>然后就蹭着现在环境 OK，开始搭建我的 Spring Boot 2 源码阅读环境！</p><h3 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h3><p>1、<a href="http://www.54tianzhisheng.cn/2018/03/06/SpringBoot2-Migration-Guide/" target="_blank" rel="noopener">Spring Boot 2.0系列文章(一)：Spring Boot 2.0 迁移指南</a></p><p>2、<a href="http://www.54tianzhisheng.cn/2018/03/06/SpringBoot2-new-features/" target="_blank" rel="noopener">Spring Boot 2.0系列文章(二)：Spring Boot 2.0 新特性详解</a></p><p>3、<a href="http://www.54tianzhisheng.cn/2018/04/13/Spring_Boot_2.0_Configuration_Changelog/" target="_blank" rel="noopener">Spring Boot 2.0系列文章(三)：Spring Boot 2.0 配置改变</a></p><p>4、<a href="http://www.54tianzhisheng.cn/2018/04/15/springboot2_code/" target="_blank" rel="noopener">Spring Boot 2.0系列文章(四)：Spring Boot 2.0 源码阅读环境搭建</a></p><p>5、<a href="http://www.54tianzhisheng.cn/2018/04/18/spring_boot2_project/" target="_blank" rel="noopener">Spring Boot 2.0系列文章(五)：Spring Boot 2.0 项目源码结构预览</a></p><p>6、<a href="http://www.54tianzhisheng.cn/2018/04/19/SpringBootApplication-annotation/" target="_blank" rel="noopener">Spring Boot 2.0系列文章(六)：Spring boot 2.0 中 SpringBootApplication 注解详解</a></p><p>7、<a href="http://www.54tianzhisheng.cn/2018/04/30/springboot_SpringApplication/" target="_blank" rel="noopener">Spring Boot 2.0系列文章(七)：SpringApplication 深入探索</a></p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>源码不骗人，多看看！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://ws3.sinaimg.cn/large/006tNc79gy1fqdma0kpk1j31hc0zkqox.jpg&quot; alt=&quot;night-photograph-2183637_1920&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="SpringBoot" scheme="http://yoursite.com/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot 2.0系列文章(三)：Spring Boot 2.0 配置改变</title>
    <link href="http://yoursite.com/2018/04/13/Spring_Boot_2.0_Configuration_Changelog/"/>
    <id>http://yoursite.com/2018/04/13/Spring_Boot_2.0_Configuration_Changelog/</id>
    <published>2018-04-12T16:00:00.000Z</published>
    <updated>2018-04-19T16:10:55.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fqc4n57tj4j31hc0zktmm.jpg" alt="pocket-watch-3156771_1920"></p><a id="more"></a><h3 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h3><p>好久没更新文章了，本来打算在毕业之前不更新了，这里，对不住了，我又更新了。😝😝</p><p>之前翻译了两篇 Spring Boot 2.0 的文章，<a href="http://www.54tianzhisheng.cn/2018/03/06/SpringBoot2-Migration-Guide/" target="_blank" rel="noopener">Spring Boot 2.0系列文章(一)：Spring Boot 2.0 迁移指南</a>   和  <a href="http://www.54tianzhisheng.cn/2018/03/06/SpringBoot2-new-features/" target="_blank" rel="noopener">Spring Boot 2.0系列文章(二)：Spring Boot 2.0 新特性详解</a></p><p>今天就继续详细探究 Spring Boot 2.0 里面的改变。</p><h3 id="关注我"><a href="#关注我" class="headerlink" title="关注我"></a>关注我</h3><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180103/C6LG3mGa12.jpg" alt="mark"></p><p>转载请务必注明原创地址为：<a href="http://www.54tianzhisheng.cn/2018/04/13/Spring_Boot_2.0_Configuration_Changelog/" target="_blank" rel="noopener">http://www.54tianzhisheng.cn/2018/04/13/Spring_Boot_2.0_Configuration_Changelog/</a></p><h3 id="配置改变"><a href="#配置改变" class="headerlink" title="配置改变"></a>配置改变</h3><p>配置属性在 1.5.10.RELEASE 和 2.0.0.RELEASE 两个版本之间的改变：</p><h4 id="启用键"><a href="#启用键" class="headerlink" title="启用键"></a>启用键</h4><p>下面的表是 2.0.0.RELEASE 版本中的弃用键：</p><table><thead><tr><th>Key</th><th>Replacement（替代）</th><th>原因</th></tr></thead><tbody><tr><td><code>spring.datasource.hikari.initialization-fail-fast</code></td><td></td><td></td></tr><tr><td><code>spring.main.web-environment</code></td><td><code>spring.main.web-application-type</code></td></tr></tbody></table><h4 id="新键"><a href="#新键" class="headerlink" title="新键"></a>新键</h4><p>下面的表是 2.0.0.RELEASE 版本中新的键：</p><table><thead><tr><th>Key</th><th>Default value（默认值）</th><th>描述</th></tr></thead><tbody><tr><td><code>logging.file.max-history</code></td><td><code>0</code></td><td>要保存的归档日志文件的最大值</td></tr><tr><td><code>logging.file.max-size</code></td><td><code>10MB</code></td><td>日志文件最大容量</td></tr><tr><td><code>logging.pattern.dateformat</code></td><td><code>yyyy-MM-dd HH:mm:ss.SSS</code></td><td>日志的日期格式</td></tr><tr><td><code>management.endpoint.auditevents.cache.time-to-live</code></td><td><code>0ms</code></td><td>可以缓存响应的最长时间</td></tr><tr><td><code>management.endpoint.auditevents.enabled</code></td><td><code>true</code></td><td>是否启用 auditevents 端点</td></tr><tr><td><code>management.endpoint.beans.cache.time-to-live</code></td><td><code>0ms</code></td><td>可以缓存响应的最长时间</td></tr><tr><td><code>management.endpoint.beans.enabled</code></td><td><code>true</code></td><td>是否启用 bean 端点</td></tr><tr><td><code>management.endpoint.conditions.cache.time-to-live</code></td><td><code>0ms</code></td><td>可以缓存响应的最长时间</td></tr><tr><td><code>management.endpoint.conditions.enabled</code></td><td><code>true</code></td><td>是否启用 conditions 端点</td></tr><tr><td><code>management.endpoint.configprops.cache.time-to-live</code></td><td><code>0ms</code></td><td>可以缓存响应的最长时间</td></tr><tr><td><code>management.endpoint.configprops.enabled</code></td><td><code>true</code></td><td>是否启用 configprops 端点</td></tr><tr><td><code>management.endpoint.configprops.keys-to-sanitize</code></td><td><code>password,secret,key,token,    .credentials.,vcap_services</code></td><td>Keys that should be sanitized</td></tr><tr><td><code>management.endpoint.env.cache.time-to-live</code></td><td><code>0ms</code></td><td>可以缓存响应的最长时间</td></tr><tr><td><code>management.endpoint.env.enabled</code></td><td><code>true</code></td><td>是否启用 env 端点</td></tr><tr><td><code>management.endpoint.env.keys-to-sanitize</code></td><td><code>password,secret,key,token,   .credentials.,vcap_services</code></td><td>Keys that should be sanitized.</td></tr><tr><td><code>management.endpoint.flyway.cache.time-to-live</code></td><td><code>0ms</code></td><td>可以缓存响应的最长时间</td></tr><tr><td><code>management.endpoint.flyway.enabled</code></td><td><code>true</code></td><td>是否启用 flyway 端点</td></tr><tr><td><code>management.endpoint.health.cache.time-to-live</code></td><td><code>0ms</code></td><td>可以缓存响应的最长时间</td></tr><tr><td><code>management.endpoint.health.enabled</code></td><td><code>true</code></td><td>是否启用 health 端点</td></tr><tr><td><code>management.endpoint.health.roles</code></td><td></td><td>角色用于确定用户是否有权显示详细信息</td></tr><tr><td><code>management.endpoint.health.show-details</code></td><td><code>never</code></td><td>何时显示完整的健康详情</td></tr><tr><td><code>management.endpoint.heapdump.cache.time-to-live</code></td><td><code>0ms</code></td><td>可以缓存响应的最长时间</td></tr><tr><td><code>management.endpoint.heapdump.enabled</code></td><td><code>true</code></td><td>是否启用 heapdump 端点</td></tr><tr><td><code>management.endpoint.httptrace.cache.time-to-live</code></td><td><code>0ms</code></td><td>可以缓存响应的最长时间</td></tr><tr><td><code>management.endpoint.httptrace.enabled</code></td><td><code>true</code></td><td>是否启用 httptrace 端点</td></tr><tr><td><code>management.endpoint.info.cache.time-to-live</code></td><td><code>0ms</code></td><td>可以缓存响应的最长时间</td></tr><tr><td><code>management.endpoint.info.enabled</code></td><td><code>true</code></td><td>是否启用 info 端点</td></tr><tr><td><code>management.endpoint.jolokia.config</code></td><td></td><td>Jolokia 设置</td></tr><tr><td><code>management.endpoint.jolokia.enabled</code></td><td><code>true</code></td><td>是否启用 jolokia 端点</td></tr><tr><td><code>management.endpoint.liquibase.cache.time-to-live</code></td><td><code>0ms</code></td><td>可以缓存响应的最长时间</td></tr><tr><td><code>management.endpoint.liquibase.enabled</code></td><td><code>true</code></td><td>是否启用 liquibase 端点</td></tr><tr><td><code>management.endpoint.logfile.cache.time-to-live</code></td><td><code>0ms</code></td><td>可以缓存响应的最长时间</td></tr><tr><td><code>management.endpoint.logfile.enabled</code></td><td><code>true</code></td><td>是否启用 logfile 端点</td></tr><tr><td><code>management.endpoint.logfile.external-file</code></td><td></td><td>要访问的外部日志文件</td></tr><tr><td><code>management.endpoint.loggers.cache.time-to-live</code></td><td><code>0ms</code></td><td>可以缓存响应的最长时间</td></tr><tr><td><code>management.endpoint.loggers.enabled</code></td><td><code>true</code></td><td>是否启用 loggers 端点</td></tr><tr><td><code>management.endpoint.mappings.cache.time-to-live</code></td><td><code>0ms</code></td><td>可以缓存响应的最长时间</td></tr><tr><td><code>management.endpoint.mappings.enabled</code></td><td><code>true</code></td><td>是否启用 mappings 端点</td></tr><tr><td><code>management.endpoint.metrics.cache.time-to-live</code></td><td><code>0ms</code></td><td>可以缓存响应的最长时间</td></tr><tr><td><code>management.endpoint.metrics.enabled</code></td><td><code>true</code></td><td>是否启用 metrics 端点</td></tr><tr><td><code>management.endpoint.prometheus.cache.time-to-live</code></td><td><code>0ms</code></td><td>可以缓存响应的最长时间</td></tr><tr><td><code>management.endpoint.prometheus.enabled</code></td><td><code>true</code></td><td>是否启用 prometheus 端点</td></tr><tr><td><code>management.endpoint.scheduledtasks.cache.time-to-live</code></td><td><code>0ms</code></td><td>可以缓存响应的最长时间</td></tr><tr><td><code>management.endpoint.scheduledtasks.enabled</code></td><td><code>true</code></td><td>是否启用 scheduledtasks 端点</td></tr><tr><td><code>management.endpoint.sessions.enabled</code></td><td><code>true</code></td><td>是否启用 sessions 端点</td></tr><tr><td><code>management.endpoint.shutdown.enabled</code></td><td><code>false</code></td><td>是否启用 shutdown 端点</td></tr><tr><td><code>management.endpoint.threaddump.cache.time-to-live</code></td><td><code>0ms</code></td><td>可以缓存响应的最长时间</td></tr><tr><td><code>management.endpoint.threaddump.enabled</code></td><td><code>true</code></td><td>是否启用 threaddump 端点</td></tr><tr><td><code>management.endpoints.enabled-by-default</code></td><td></td><td>是否启用或者关闭所有的端点</td></tr><tr><td><code>management.endpoints.jmx.domain</code></td><td><code>org.springframework.boot</code></td><td>端点 JMX 域名</td></tr><tr><td><code>management.endpoints.jmx.exposure.exclude</code></td><td></td><td>应排除的端点 ID</td></tr><tr><td><code>management.endpoints.jmx.exposure.include</code></td><td><code>*</code></td><td>应包含的端点 ID 或全部 <code>*</code></td></tr><tr><td><code>management.endpoints.jmx.static-names</code></td><td></td><td>追加到所有表示端点的 MBean 的ObjectName 的静态属性.</td></tr><tr><td><code>management.endpoints.jmx.unique-names</code></td><td><code>false</code></td><td>是否确保 ObjectNames 在发生冲突时被修改</td></tr><tr><td><code>management.endpoints.web.base-path</code></td><td><code>/actuator</code></td><td>Web 端点的基本路径</td></tr><tr><td><code>management.endpoints.web.cors.allow-credentials</code></td><td></td><td>是否支持凭证</td></tr><tr><td><code>management.endpoints.web.cors.allowed-headers</code></td><td></td><td>Comma-separated list of headers to allow in a request. ‘*’ allows all headers.</td></tr><tr><td><code>management.endpoints.web.cors.allowed-methods</code></td><td></td><td>Comma-separated list of methods to allow. ‘*’ allows all methods.</td></tr><tr><td><code>management.endpoints.web.cors.allowed-origins</code></td><td></td><td>Comma-separated list of origins to allow. ‘*’ allows all origins.</td></tr><tr><td><code>management.endpoints.web.cors.exposed-headers</code></td><td></td><td>Comma-separated list of headers to include in a response.</td></tr><tr><td><code>management.endpoints.web.cors.max-age</code></td><td><code>1800s</code></td><td>How long the response from a pre-flight request can be cached by clients.</td></tr><tr><td><code>management.endpoints.web.exposure.exclude</code></td><td></td><td>Endpoint IDs that should be excluded.</td></tr><tr><td><code>management.endpoints.web.exposure.include</code></td><td><code>health,info</code></td><td>Endpoint IDs that should be included or ‘*’ for all.</td></tr><tr><td><code>management.endpoints.web.path-mapping</code></td><td></td><td>Mapping between endpoint IDs and the path that should expose them.</td></tr><tr><td><code>management.health.influxdb.enabled</code></td><td><code>true</code></td><td>Whether to enable InfluxDB health check.</td></tr><tr><td><code>management.health.neo4j.enabled</code></td><td><code>true</code></td><td>Whether to enable Neo4j health check.</td></tr><tr><td><code>management.health.status.http-mapping</code></td><td></td><td>Mapping of health statuses to HTTP status codes.</td></tr><tr><td><code>management.metrics.binders.files.enabled</code></td><td><code>true</code></td><td>Whether to enable files metrics.</td></tr><tr><td><code>management.metrics.binders.integration.enabled</code></td><td><code>true</code></td><td>Whether to enable Spring Integration metrics.</td></tr><tr><td><code>management.metrics.binders.jvm.enabled</code></td><td><code>true</code></td><td>Whether to enable JVM metrics.</td></tr><tr><td><code>management.metrics.binders.logback.enabled</code></td><td><code>true</code></td><td>Whether to enable Logback metrics.</td></tr><tr><td><code>management.metrics.binders.processor.enabled</code></td><td><code>true</code></td><td>Whether to enable processor metrics.</td></tr><tr><td><code>management.metrics.binders.uptime.enabled</code></td><td><code>true</code></td><td>Whether to enable uptime metrics.</td></tr><tr><td><code>management.metrics.distribution.percentiles</code></td><td></td><td>Specific computed non-aggregable percentiles to ship to the backend for meter IDs starting-with the specified name.</td></tr><tr><td><code>management.metrics.distribution.percentiles-histogram</code></td><td></td><td>Whether meter IDs starting-with the specified name should be publish percentile histograms.</td></tr><tr><td><code>management.metrics.distribution.sla</code></td><td></td><td>Specific SLA boundaries for meter IDs starting-with the specified name.</td></tr><tr><td><code>management.metrics.enable</code></td><td></td><td>Whether meter IDs starting-with the specified name should be enabled.</td></tr><tr><td><code>management.metrics.export.atlas.batch-size</code></td><td><code>10000</code></td><td>Number of measurements per request to use for this backend.</td></tr><tr><td><code>management.metrics.export.atlas.config-refresh-frequency</code></td><td><code>10s</code></td><td>Frequency for refreshing config settings from the LWC service.</td></tr><tr><td><code>management.metrics.export.atlas.config-time-to-live</code></td><td><code>150s</code></td><td>Time to live for subscriptions from the LWC service.</td></tr><tr><td><code>management.metrics.export.atlas.config-uri</code></td><td><code>http://localhost:7101/     lwc/api/v1/expressions/local-dev</code></td><td>URI for the Atlas LWC endpoint to retrieve current subscriptions.</td></tr><tr><td><code>management.metrics.export.atlas.connect-timeout</code></td><td><code>1s</code></td><td>Connection timeout for requests to this backend.</td></tr><tr><td><code>management.metrics.export.atlas.enabled</code></td><td><code>true</code></td><td>Whether exporting of metrics to this backend is enabled.</td></tr><tr><td><code>management.metrics.export.atlas.eval-uri</code></td><td><code>http://localhost:7101/ lwc/api/v1/evaluate</code></td><td>URI for the Atlas LWC endpoint to evaluate the data for a subscription.</td></tr><tr><td><code>management.metrics.export.atlas.lwc-enabled</code></td><td><code>false</code></td><td>Whether to enable streaming to Atlas LWC.</td></tr><tr><td><code>management.metrics.export.atlas.meter-time-to-live</code></td><td><code>15m</code></td><td>Time to live for meters that do not have any activity.</td></tr><tr><td><code>management.metrics.export.atlas.num-threads</code></td><td><code>2</code></td><td>Number of threads to use with the metrics publishing scheduler.</td></tr><tr><td><code>management.metrics.export.atlas.read-timeout</code></td><td><code>10s</code></td><td>Read timeout for requests to this backend.</td></tr><tr><td><code>management.metrics.export.atlas.step</code></td><td><code>1m</code></td><td>Step size (i.e. reporting frequency) to use.</td></tr><tr><td><code>management.metrics.export.atlas.uri</code></td><td><code>http://localhost:7101/ api/v1/publish</code></td><td>URI of the Atlas server.</td></tr><tr><td><code>management.metrics.export.datadog.api-key</code></td><td></td><td>Datadog API key.</td></tr><tr><td><code>management.metrics.export.datadog.application-key</code></td><td></td><td>Datadog application key.</td></tr><tr><td><code>management.metrics.export.datadog.batch-size</code></td><td><code>10000</code></td><td>Number of measurements per request to use for this backend.</td></tr><tr><td><code>management.metrics.export.datadog.connect-timeout</code></td><td><code>1s</code></td><td>Connection timeout for requests to this backend.</td></tr><tr><td><code>management.metrics.export.datadog.descriptions</code></td><td><code>true</code></td><td>Whether to publish descriptions metadata to Datadog.</td></tr><tr><td><code>management.metrics.export.datadog.enabled</code></td><td><code>true</code></td><td>Whether exporting of metrics to this backend is enabled.</td></tr><tr><td><code>management.metrics.export.datadog.host-tag</code></td><td><code>instance</code></td><td>Tag that will be mapped to “host” when shipping metrics to Datadog.</td></tr><tr><td><code>management.metrics.export.datadog.num-threads</code></td><td><code>2</code></td><td>Number of threads to use with the metrics publishing scheduler.</td></tr><tr><td><code>management.metrics.export.datadog.read-timeout</code></td><td><code>10s</code></td><td>Read timeout for requests to this backend.</td></tr><tr><td><code>management.metrics.export.datadog.step</code></td><td><code>1m</code></td><td>Step size (i.e. reporting frequency) to use.</td></tr><tr><td><code>management.metrics.export.datadog.uri</code></td><td><code>https://app.datadoghq.com</code></td><td>URI to ship metrics to.</td></tr><tr><td><code>management.metrics.export.ganglia.addressing-mode</code></td><td><code>multicast</code></td><td>UDP addressing mode, either unicast or multicast.</td></tr><tr><td><code>management.metrics.export.ganglia.duration-units</code></td><td><code>milliseconds</code></td><td>Base time unit used to report durations.</td></tr><tr><td><code>management.metrics.export.ganglia.enabled</code></td><td><code>true</code></td><td>Whether exporting of metrics to Ganglia is enabled.</td></tr><tr><td><code>management.metrics.export.ganglia.host</code></td><td><code>localhost</code></td><td>Host of the Ganglia server to receive exported metrics.</td></tr><tr><td><code>management.metrics.export.ganglia.port</code></td><td><code>8649</code></td><td>Port of the Ganglia server to receive exported metrics.</td></tr><tr><td><code>management.metrics.export.ganglia.protocol-version</code></td><td><code>3.1</code></td><td>Ganglia protocol version.</td></tr><tr><td><code>management.metrics.export.ganglia.rate-units</code></td><td><code>seconds</code></td><td>Base time unit used to report rates.</td></tr><tr><td><code>management.metrics.export.ganglia.step</code></td><td><code>1m</code></td><td>Step size (i.e. reporting frequency) to use.</td></tr><tr><td><code>management.metrics.export.ganglia.time-to-live</code></td><td><code>1</code></td><td>Time to live for metrics on Ganglia.</td></tr><tr><td><code>management.metrics.export.graphite.duration-units</code></td><td><code>milliseconds</code></td><td>Base time unit used to report durations.</td></tr><tr><td><code>management.metrics.export.graphite.enabled</code></td><td><code>true</code></td><td>Whether exporting of metrics to Graphite is enabled.</td></tr><tr><td><code>management.metrics.export.graphite.host</code></td><td><code>localhost</code></td><td>Host of the Graphite server to receive exported metrics.</td></tr><tr><td><code>management.metrics.export.graphite.port</code></td><td><code>2004</code></td><td>Port of the Graphite server to receive exported metrics.</td></tr><tr><td><code>management.metrics.export.graphite.protocol</code></td><td><code>pickled</code></td><td>Protocol to use while shipping data to Graphite.</td></tr><tr><td><code>management.metrics.export.graphite.rate-units</code></td><td><code>seconds</code></td><td>Base time unit used to report rates.</td></tr><tr><td><code>management.metrics.export.graphite.step</code></td><td><code>1m</code></td><td>Step size (i.e. reporting frequency) to use.</td></tr><tr><td><code>management.metrics.export.graphite.tags-as-prefix</code></td><td>``</td><td>For the default naming convention, turn the specified tag keys into part of the metric prefix.</td></tr><tr><td><code>management.metrics.export.influx.auto-create-db</code></td><td><code>true</code></td><td>Whether to create the Influx database if it does not exist before attempting to publish metrics to it.</td></tr><tr><td><code>management.metrics.export.influx.batch-size</code></td><td><code>10000</code></td><td>Number of measurements per request to use for this backend.</td></tr><tr><td><code>management.metrics.export.influx.compressed</code></td><td><code>true</code></td><td>Whether to enable GZIP compression of metrics batches published to Influx.</td></tr><tr><td><code>management.metrics.export.influx.connect-timeout</code></td><td><code>1s</code></td><td>Connection timeout for requests to this backend.</td></tr><tr><td><code>management.metrics.export.influx.consistency</code></td><td><code>one</code></td><td>Write consistency for each point.</td></tr><tr><td><code>management.metrics.export.influx.db</code></td><td><code>mydb</code></td><td>Tag that will be mapped to “host” when shipping metrics to Influx.</td></tr><tr><td><code>management.metrics.export.influx.enabled</code></td><td><code>true</code></td><td>Whether exporting of metrics to this backend is enabled.</td></tr><tr><td><code>management.metrics.export.influx.num-threads</code></td><td><code>2</code></td><td>Number of threads to use with the metrics publishing scheduler.</td></tr><tr><td><code>management.metrics.export.influx.password</code></td><td></td><td>Login password of the Influx server.</td></tr><tr><td><code>management.metrics.export.influx.read-timeout</code></td><td><code>10s</code></td><td>Read timeout for requests to this backend.</td></tr><tr><td><code>management.metrics.export.influx.retention-policy</code></td><td></td><td>Retention policy to use (Influx writes to the DEFAULT retention policy if one is not specified).</td></tr><tr><td><code>management.metrics.export.influx.step</code></td><td><code>1m</code></td><td>Step size (i.e. reporting frequency) to use.</td></tr><tr><td><code>management.metrics.export.influx.uri</code></td><td><code>http://localhost:8086</code></td><td>URI of the Influx server.</td></tr><tr><td><code>management.metrics.export.influx.user-name</code></td><td></td><td>Login user of the Influx server.</td></tr><tr><td><code>management.metrics.export.jmx.enabled</code></td><td><code>true</code></td><td>Whether exporting of metrics to JMX is enabled.</td></tr><tr><td><code>management.metrics.export.jmx.step</code></td><td><code>1m</code></td><td>Step size (i.e. reporting frequency) to use.</td></tr><tr><td><code>management.metrics.export.newrelic.account-id</code></td><td></td><td>New Relic account ID.</td></tr><tr><td><code>management.metrics.export.newrelic.api-key</code></td><td></td><td>New Relic API key.</td></tr><tr><td><code>management.metrics.export.newrelic.batch-size</code></td><td><code>10000</code></td><td>Number of measurements per request to use for this backend.</td></tr><tr><td><code>management.metrics.export.newrelic.connect-timeout</code></td><td><code>1s</code></td><td>Connection timeout for requests to this backend.</td></tr><tr><td><code>management.metrics.export.newrelic.enabled</code></td><td><code>true</code></td><td>Whether exporting of metrics to this backend is enabled.</td></tr><tr><td><code>management.metrics.export.newrelic.num-threads</code></td><td><code>2</code></td><td>Number of threads to use with the metrics publishing scheduler.</td></tr><tr><td><code>management.metrics.export.newrelic.read-timeout</code></td><td><code>10s</code></td><td>Read timeout for requests to this backend.</td></tr><tr><td><code>management.metrics.export.newrelic.step</code></td><td><code>1m</code></td><td>Step size (i.e. reporting frequency) to use.</td></tr><tr><td><code>management.metrics.export.newrelic.uri</code></td><td><code>https://insights-collector    .newrelic.com</code></td><td>URI to ship metrics to.</td></tr><tr><td><code>management.metrics.export.prometheus.descriptions</code></td><td><code>true</code></td><td>Whether to enable publishing descriptions as part of the scrape payload to Prometheus.</td></tr><tr><td><code>management.metrics.export.prometheus.enabled</code></td><td><code>true</code></td><td>Whether exporting of metrics to Prometheus is enabled.</td></tr><tr><td><code>management.metrics.export.prometheus.step</code></td><td><code>1m</code></td><td>Step size (i.e. reporting frequency) to use.</td></tr><tr><td><code>management.metrics.export.signalfx.access-token</code></td><td></td><td>SignalFX access token.</td></tr><tr><td><code>management.metrics.export.signalfx.batch-size</code></td><td><code>10000</code></td><td>Number of measurements per request to use for this backend.</td></tr><tr><td><code>management.metrics.export.signalfx.connect-timeout</code></td><td><code>1s</code></td><td>Connection timeout for requests to this backend.</td></tr><tr><td><code>management.metrics.export.signalfx.enabled</code></td><td><code>true</code></td><td>Whether exporting of metrics to this backend is enabled.</td></tr><tr><td><code>management.metrics.export.signalfx.num-threads</code></td><td><code>2</code></td><td>Number of threads to use with the metrics publishing scheduler.</td></tr><tr><td><code>management.metrics.export.signalfx.read-timeout</code></td><td><code>10s</code></td><td>Read timeout for requests to this backend.</td></tr><tr><td><code>management.metrics.export.signalfx.source</code></td><td></td><td>Uniquely identifies the app instance that is publishing metrics to SignalFx.</td></tr><tr><td><code>management.metrics.export.signalfx.step</code></td><td><code>10s</code></td><td>Step size (i.e. reporting frequency) to use.</td></tr><tr><td><code>management.metrics.export.signalfx.uri</code></td><td><code>https://ingest.signalfx.com</code></td><td>URI to ship metrics to.</td></tr><tr><td><code>management.metrics.export.simple.enabled</code></td><td><code>true</code></td><td>Whether, in the absence of any other exporter, exporting of metrics to an in-memory backend is enabled.</td></tr><tr><td><code>management.metrics.export.simple.mode</code></td><td><code>cumulative</code></td><td>Counting mode.</td></tr><tr><td><code>management.metrics.export.simple.step</code></td><td><code>1m</code></td><td>Step size (i.e. reporting frequency) to use.</td></tr><tr><td><code>management.metrics.export.statsd.enabled</code></td><td><code>true</code></td><td>Whether exporting of metrics to StatsD is enabled.</td></tr><tr><td><code>management.metrics.export.statsd.flavor</code></td><td><code>datadog</code></td><td>StatsD line protocol to use.</td></tr><tr><td><code>management.metrics.export.statsd.host</code></td><td><code>localhost</code></td><td>Host of the StatsD server to receive exported metrics.</td></tr><tr><td><code>management.metrics.export.statsd.max-packet-length</code></td><td><code>1400</code></td><td>Total length of a single payload should be kept within your network’s MTU.</td></tr><tr><td><code>management.metrics.export.statsd.polling-frequency</code></td><td><code>10s</code></td><td>How often gauges will be polled.</td></tr><tr><td><code>management.metrics.export.statsd.port</code></td><td><code>8125</code></td><td>Port of the StatsD server to receive exported metrics.</td></tr><tr><td><code>management.metrics.export.statsd.publish-unchanged-meters</code></td><td><code>true</code></td><td>Whether to send unchanged meters to the StatsD server.</td></tr><tr><td><code>management.metrics.export.statsd.queue-size</code></td><td><code>2147483647</code></td><td>Maximum size of the queue of items waiting to be sent to the StatsD server.</td></tr><tr><td><code>management.metrics.export.wavefront.api-token</code></td><td></td><td>API token used when publishing metrics directly to the Wavefront API host.</td></tr><tr><td><code>management.metrics.export.wavefront.batch-size</code></td><td><code>10000</code></td><td>Number of measurements per request to use for this backend.</td></tr><tr><td><code>management.metrics.export.wavefront.connect-timeout</code></td><td><code>1s</code></td><td>Connection timeout for requests to this backend.</td></tr><tr><td><code>management.metrics.export.wavefront.enabled</code></td><td><code>true</code></td><td>Whether exporting of metrics to this backend is enabled.</td></tr><tr><td><code>management.metrics.export.wavefront.global-prefix</code></td><td></td><td>Global prefix to separate metrics originating from this app’s white box instrumentation from those originating from other Wavefront integrations when viewed in the Wavefront UI.</td></tr><tr><td><code>management.metrics.export.wavefront.num-threads</code></td><td><code>2</code></td><td>Number of threads to use with the metrics publishing scheduler.</td></tr><tr><td><code>management.metrics.export.wavefront.read-timeout</code></td><td><code>10s</code></td><td>Read timeout for requests to this backend.</td></tr><tr><td><code>management.metrics.export.wavefront.source</code></td><td></td><td>Unique identifier for the app instance that is the source of metrics being published to Wavefront.</td></tr><tr><td><code>management.metrics.export.wavefront.step</code></td><td><code>10s</code></td><td>Step size (i.e. reporting frequency) to use.</td></tr><tr><td><code>management.metrics.export.wavefront.uri</code></td><td><code>https://longboard.wavefront.com</code></td><td>URI to ship metrics to.</td></tr><tr><td><code>management.metrics.use-global-registry</code></td><td><code>true</code></td><td>Whether auto-configured MeterRegistry implementations should be bound to the global static registry on Metrics.</td></tr><tr><td><code>management.metrics.web.client.max-uri-tags</code></td><td><code>100</code></td><td>Maximum number of unique URI tag values allowed.</td></tr><tr><td><code>management.metrics.web.client.requests-metric-name</code></td><td><code>http.client.requests</code></td><td>Name of the metric for sent requests.</td></tr><tr><td><code>management.metrics.web.server.auto-time-requests</code></td><td><code>true</code></td><td>Whether requests handled by Spring MVC or WebFlux should be automatically timed.</td></tr><tr><td><code>management.metrics.web.server.requests-metric-name</code></td><td><code>http.server.requests</code></td><td>Name of the metric for received requests.</td></tr><tr><td><code>management.server.add-application-context-header</code></td><td><code>false</code></td><td>Add the “X-Application-Context” HTTP header in each response.</td></tr><tr><td><code>management.server.address</code></td><td></td><td>Network address to which the management endpoints should bind.</td></tr><tr><td><code>management.server.port</code></td><td></td><td>Management endpoint HTTP port (uses the same port as the application by default).</td></tr><tr><td><code>management.server.servlet.context-path</code></td><td><code>Management endpoint context-path (for instance,</code>/management).</td><td></td></tr><tr><td><code>management.server.ssl.ciphers</code></td><td></td><td></td></tr><tr><td><code>management.server.ssl.client-auth</code></td><td></td><td></td></tr><tr><td><code>management.server.ssl.enabled</code></td><td></td><td></td></tr><tr><td><code>management.server.ssl.enabled-protocols</code></td><td></td><td></td></tr><tr><td><code>management.server.ssl.key-alias</code></td><td></td><td></td></tr><tr><td><code>management.server.ssl.key-password</code></td><td></td><td></td></tr><tr><td><code>management.server.ssl.key-store</code></td><td></td><td></td></tr><tr><td><code>management.server.ssl.key-store-password</code></td><td></td><td></td></tr><tr><td><code>management.server.ssl.key-store-provider</code></td><td></td><td></td></tr><tr><td><code>management.server.ssl.key-store-type</code></td><td></td><td></td></tr><tr><td><code>management.server.ssl.protocol</code></td><td></td><td></td></tr><tr><td><code>management.server.ssl.trust-store</code></td><td></td><td></td></tr><tr><td><code>management.server.ssl.trust-store-password</code></td><td></td><td></td></tr><tr><td><code>management.server.ssl.trust-store-provider</code></td><td></td><td></td></tr><tr><td><code>management.server.ssl.trust-store-type</code></td><td></td><td></td></tr><tr><td><code>management.trace.http.enabled</code></td><td><code>true</code></td><td>Whether to enable HTTP request-response tracing.</td></tr><tr><td><code>management.trace.http.include</code></td><td><code>request-headers,response-headers, cookies,errors</code></td><td>Items to be included in the trace.</td></tr><tr><td><code>server.error.include-exception</code></td><td><code>false</code></td><td>Include the “exception” attribute.</td></tr><tr><td><code>server.http2.enabled</code></td><td></td><td></td></tr><tr><td><code>server.jetty.accesslog.append</code></td><td><code>false</code></td><td>Append to log.</td></tr><tr><td><code>server.jetty.accesslog.date-format</code></td><td><code>dd/MMM/yyyy:HH:mm:ss Z</code></td><td>Timestamp format of the request log.</td></tr><tr><td><code>server.jetty.accesslog.enabled</code></td><td><code>false</code></td><td>Enable access log.</td></tr><tr><td><code>server.jetty.accesslog.extended-format</code></td><td><code>false</code></td><td>Enable extended NCSA format.</td></tr><tr><td><code>server.jetty.accesslog.file-date-format</code></td><td></td><td>Date format to place in log file name.</td></tr><tr><td><code>server.jetty.accesslog.filename</code></td><td></td><td>Log filename.</td></tr><tr><td><code>server.jetty.accesslog.locale</code></td><td></td><td>Locale of the request log.</td></tr><tr><td><code>server.jetty.accesslog.log-cookies</code></td><td><code>false</code></td><td>Enable logging of the request cookies.</td></tr><tr><td><code>server.jetty.accesslog.log-latency</code></td><td><code>false</code></td><td>Enable logging of request processing time.</td></tr><tr><td><code>server.jetty.accesslog.log-server</code></td><td><code>false</code></td><td>Enable logging of the request hostname.</td></tr><tr><td><code>server.jetty.accesslog.retention-period</code></td><td><code>31</code></td><td>Number of days before rotated log files are deleted.</td></tr><tr><td><code>server.jetty.accesslog.time-zone</code></td><td><code>GMT</code></td><td>Timezone of the request log.</td></tr><tr><td><code>server.servlet.application-display-name</code></td><td><code>application</code></td><td>Display name of the application.</td></tr><tr><td><code>server.servlet.context-parameters</code></td><td></td><td>Servlet context init parameters.</td></tr><tr><td><code>server.servlet.context-path</code></td><td></td><td>Context path of the application.</td></tr><tr><td><code>server.servlet.jsp.class-name</code></td><td></td><td></td></tr><tr><td><code>server.servlet.jsp.init-parameters</code></td><td></td><td></td></tr><tr><td><code>server.servlet.jsp.registered</code></td><td></td><td></td></tr><tr><td><code>server.servlet.path</code></td><td><code>/</code></td><td>Path of the main dispatcher servlet.</td></tr><tr><td><code>server.servlet.session.cookie.comment</code></td><td></td><td></td></tr><tr><td><code>server.servlet.session.cookie.domain</code></td><td></td><td></td></tr><tr><td><code>server.servlet.session.cookie.http-only</code></td><td></td><td></td></tr><tr><td><code>server.servlet.session.cookie.max-age</code></td><td></td><td></td></tr><tr><td><code>server.servlet.session.cookie.name</code></td><td></td><td></td></tr><tr><td><code>server.servlet.session.cookie.path</code></td><td></td><td></td></tr><tr><td><code>server.servlet.session.cookie.secure</code></td><td></td><td></td></tr><tr><td><code>server.servlet.session.persistent</code></td><td></td><td></td></tr><tr><td><code>server.servlet.session.store-dir</code></td><td></td><td></td></tr><tr><td><code>server.servlet.session.timeout</code></td><td></td><td></td></tr><tr><td><code>server.servlet.session.tracking-modes</code></td><td></td><td></td></tr><tr><td><code>server.tomcat.max-http-header-size</code></td><td><code>0</code></td><td>Maximum size, in bytes, of the HTTP message header.</td></tr><tr><td><code>server.tomcat.resource.cache-ttl</code></td><td></td><td>Time-to-live of the static resource cache.</td></tr><tr><td><code>server.tomcat.use-relative-redirects</code></td><td></td><td>Whether HTTP 1.1 and later location headers generated by a call to sendRedirect will use relative or absolute redirects.</td></tr><tr><td><code>server.undertow.eager-filter-init</code></td><td><code>true</code></td><td>Whether servlet filters should be initialized on startup.</td></tr><tr><td><code>spring.banner.charset</code></td><td><code>UTF-8</code></td><td>Banner file encoding.</td></tr><tr><td><code>spring.banner.image.height</code></td><td></td><td>Height of the banner image in chars (default based on image height).</td></tr><tr><td><code>spring.banner.image.invert</code></td><td><code>false</code></td><td>Whether images should be inverted for dark terminal themes.</td></tr><tr><td><code>spring.banner.image.location</code></td><td><code>classpath:banner.gif</code></td><td>Banner image file location (jpg or png can also be used).</td></tr><tr><td><code>spring.banner.image.margin</code></td><td><code>2</code></td><td>Left hand image margin in chars.</td></tr><tr><td><code>spring.banner.image.width</code></td><td><code>76</code></td><td>Width of the banner image in chars.</td></tr><tr><td><code>spring.banner.location</code></td><td><code>classpath:banner.txt</code></td><td>Banner text resource location.</td></tr><tr><td><code>spring.batch.initialize-schema</code></td><td><code>embedded</code></td><td>Database schema initialization mode.</td></tr><tr><td><code>spring.cache.redis.cache-null-values</code></td><td><code>true</code></td><td>Allow caching null values.</td></tr><tr><td><code>spring.cache.redis.key-prefix</code></td><td></td><td>Key prefix.</td></tr><tr><td><code>spring.cache.redis.time-to-live</code></td><td></td><td>Entry expiration.</td></tr><tr><td><code>spring.cache.redis.use-key-prefix</code></td><td><code>true</code></td><td>Whether to use the key prefix when writing to Redis.</td></tr><tr><td><code>spring.config.additional-location</code></td><td></td><td>Config file locations used in addition to the defaults.</td></tr><tr><td><code>spring.data.cassandra.connect-timeout</code></td><td></td><td>Socket option: connection time out.</td></tr><tr><td><code>spring.data.cassandra.pool.heartbeat-interval</code></td><td><code>30s</code></td><td>Heartbeat interval after which a message is sent on an idle connection to make sure it’s still alive.</td></tr><tr><td><code>spring.data.cassandra.pool.idle-timeout</code></td><td><code>120s</code></td><td>Idle timeout before an idle connection is removed.</td></tr><tr><td><code>spring.data.cassandra.pool.max-queue-size</code></td><td><code>256</code></td><td>Maximum number of requests that get queued if no connection is available.</td></tr><tr><td><code>spring.data.cassandra.pool.pool-timeout</code></td><td><code>5000ms</code></td><td>Pool timeout when trying to acquire a connection from a host’s pool.</td></tr><tr><td><code>spring.data.cassandra.read-timeout</code></td><td></td><td>Socket option: read time out.</td></tr><tr><td><code>spring.data.cassandra.repositories.type</code></td><td><code>auto</code></td><td>Type of Cassandra repositories to enable.</td></tr><tr><td><code>spring.data.couchbase.repositories.type</code></td><td><code>auto</code></td><td>Type of Couchbase repositories to enable.</td></tr><tr><td><code>spring.data.mongodb.repositories.type</code></td><td><code>auto</code></td><td>Type of Mongo repositories to enable.</td></tr><tr><td><code>spring.data.neo4j.auto-index</code></td><td><code>none</code></td><td>Auto index mode.</td></tr><tr><td><code>spring.data.web.pageable.default-page-size</code></td><td><code>20</code></td><td>Default page size.</td></tr><tr><td><code>spring.data.web.pageable.max-page-size</code></td><td><code>2000</code></td><td>Maximum page size to be accepted.</td></tr><tr><td><code>spring.data.web.pageable.one-indexed-parameters</code></td><td><code>false</code></td><td>Whether to expose and assume 1-based page number indexes.</td></tr><tr><td><code>spring.data.web.pageable.page-parameter</code></td><td><code>page</code></td><td>Page index parameter name.</td></tr><tr><td><code>spring.data.web.pageable.prefix</code></td><td>``</td><td>General prefix to be prepended to the page number and page size parameters.</td></tr><tr><td><code>spring.data.web.pageable.qualifier-delimiter</code></td><td><code>_</code></td><td>Delimiter to be used between the qualifier and the actual page number and size properties.</td></tr><tr><td><code>spring.data.web.pageable.size-parameter</code></td><td><code>size</code></td><td>Page size parameter name.</td></tr><tr><td><code>spring.data.web.sort.sort-parameter</code></td><td><code>sort</code></td><td>Sort parameter name.</td></tr><tr><td><code>spring.datasource.hikari.initialization-fail-timeout</code></td><td></td><td></td></tr><tr><td><code>spring.datasource.hikari.metrics-tracker-factory</code></td><td></td><td></td></tr><tr><td><code>spring.datasource.hikari.scheduled-executor</code></td><td></td><td></td></tr><tr><td><code>spring.datasource.hikari.scheduled-executor-service</code></td><td></td><td></td></tr><tr><td><code>spring.datasource.hikari.schema</code></td><td></td><td></td></tr><tr><td><code>spring.datasource.initialization-mode</code></td><td><code>embedded</code></td><td>Initialize the datasource with available DDL and DML scripts.</td></tr><tr><td><code>spring.devtools.restart.log-condition-evaluation-delta</code></td><td><code>true</code></td><td>Whether to log the condition evaluation delta upon restart.</td></tr><tr><td><code>spring.flyway.baseline-description</code></td><td></td><td></td></tr><tr><td><code>spring.flyway.baseline-on-migrate</code></td><td></td><td></td></tr><tr><td><code>spring.flyway.baseline-version</code></td><td></td><td></td></tr><tr><td><code>spring.flyway.check-location</code></td><td><code>true</code></td><td>Whether to check that migration scripts location exists.</td></tr><tr><td><code>spring.flyway.clean-disabled</code></td><td></td><td></td></tr><tr><td><code>spring.flyway.clean-on-validation-error</code></td><td></td><td></td></tr><tr><td><code>spring.flyway.dry-run-output</code></td><td></td><td></td></tr><tr><td><code>spring.flyway.enabled</code></td><td><code>true</code></td><td>是否启用 flyway.</td></tr><tr><td><code>spring.flyway.encoding</code></td><td></td><td></td></tr><tr><td><code>spring.flyway.error-handlers</code></td><td></td><td></td></tr><tr><td><code>spring.flyway.group</code></td><td></td><td></td></tr><tr><td><code>spring.flyway.ignore-future-migrations</code></td><td></td><td></td></tr><tr><td><code>spring.flyway.ignore-missing-migrations</code></td><td></td><td></td></tr><tr><td><code>spring.flyway.init-sqls</code></td><td></td><td>SQL statements to execute to initialize a connection immediately after obtaining it.</td></tr><tr><td><code>spring.flyway.installed-by</code></td><td></td><td></td></tr><tr><td><code>spring.flyway.locations</code></td><td></td><td></td></tr><tr><td><code>spring.flyway.mixed</code></td><td></td><td></td></tr><tr><td><code>spring.flyway.out-of-order</code></td><td></td><td></td></tr><tr><td><code>spring.flyway.password</code></td><td></td><td>如果您想让 Flyway 创建自己的DataSource，可以使用 JDBC 密码</td></tr><tr><td><code>spring.flyway.placeholder-prefix</code></td><td></td><td></td></tr><tr><td><code>spring.flyway.placeholder-replacement</code></td><td></td><td></td></tr><tr><td><code>spring.flyway.placeholder-suffix</code></td><td></td><td></td></tr><tr><td><code>spring.flyway.placeholders</code></td><td></td><td></td></tr><tr><td><code>spring.flyway.repeatable-sql-migration-prefix</code></td><td></td><td></td></tr><tr><td><code>spring.flyway.schemas</code></td><td></td><td></td></tr><tr><td><code>spring.flyway.skip-default-callbacks</code></td><td></td><td></td></tr><tr><td><code>spring.flyway.skip-default-resolvers</code></td><td></td><td></td></tr><tr><td><code>spring.flyway.sql-migration-prefix</code></td><td></td><td></td></tr><tr><td><code>spring.flyway.sql-migration-separator</code></td><td></td><td></td></tr><tr><td><code>spring.flyway.sql-migration-suffix</code></td><td></td><td></td></tr><tr><td><code>spring.flyway.sql-migration-suffixes</code></td><td></td><td></td></tr><tr><td><code>spring.flyway.table</code></td><td></td><td></td></tr><tr><td><code>spring.flyway.target</code></td><td></td><td></td></tr><tr><td><code>spring.flyway.undo-sql-migration-prefix</code></td><td></td><td></td></tr><tr><td><code>spring.flyway.url</code></td><td></td><td>要迁移的数据库的 JDBC URL</td></tr><tr><td><code>spring.flyway.user</code></td><td></td><td>登录要迁移数据库的用户名</td></tr><tr><td><code>spring.flyway.validate-on-migrate</code></td><td></td><td></td></tr><tr><td><code>spring.gson.date-format</code></td><td></td><td>序列化 Date 对象时使用的格式</td></tr><tr><td><code>spring.gson.disable-html-escaping</code></td><td></td><td>Whether to disable the escaping of HTML characters such as ‘&lt;’, ‘&gt;’, etc.</td></tr><tr><td><code>spring.gson.disable-inner-class-serialization</code></td><td></td><td>Whether to exclude inner classes during serialization.</td></tr><tr><td><code>spring.gson.enable-complex-map-key-serialization</code></td><td></td><td>Whether to enable serialization of complex map keys (i.e. non-primitives).</td></tr><tr><td><code>spring.gson.exclude-fields-without-expose-annotation</code></td><td></td><td>Whether to exclude all fields from consideration for serialization or deserialization that do not have the “Expose” annotation.</td></tr><tr><td><code>spring.gson.field-naming-policy</code></td><td></td><td>Naming policy that should be applied to an object’s field during serialization and deserialization.</td></tr><tr><td><code>spring.gson.generate-non-executable-json</code></td><td></td><td>Whether to generate non executable JSON by prefixing the output with some special text.</td></tr><tr><td><code>spring.gson.lenient</code></td><td></td><td>Whether to be lenient about parsing JSON that doesn’t conform to RFC 4627.</td></tr><tr><td><code>spring.gson.long-serialization-policy</code></td><td></td><td>Serialization policy for Long and long types.</td></tr><tr><td><code>spring.gson.pretty-printing</code></td><td></td><td>Whether to output serialized JSON that fits in a page for pretty printing.</td></tr><tr><td><code>spring.gson.serialize-nulls</code></td><td></td><td>Whether to serialize null fields.</td></tr><tr><td><code>spring.influx.password</code></td><td></td><td>Influx 登录用户名密码</td></tr><tr><td><code>spring.influx.url</code></td><td></td><td>InfluxDB 数据库 URL</td></tr><tr><td><code>spring.influx.user</code></td><td></td><td>Influx 登录用户名</td></tr><tr><td><code>spring.integration.jdbc.initialize-schema</code></td><td><code>embedded</code></td><td>Database schema initialization mode.</td></tr><tr><td><code>spring.integration.jdbc.schema</code></td><td><code>classpath:org/springframework/ integration/jdbc/schema-@@platform@@.sql</code></td><td>Path to the SQL file to use to initialize the database schema.</td></tr><tr><td><code>spring.jdbc.template.fetch-size</code></td><td><code>-1</code></td><td>Number of rows that should be fetched from the database when more rows are needed.</td></tr><tr><td><code>spring.jdbc.template.max-rows</code></td><td><code>-1</code></td><td>Maximum number of rows.</td></tr><tr><td><code>spring.jdbc.template.query-timeout</code></td><td></td><td>Query timeout.</td></tr><tr><td><code>spring.jpa.mapping-resources</code></td><td></td><td>Mapping resources (equivalent to “mapping-file” entries in persistence.xml).</td></tr><tr><td><code>spring.jta.atomikos.datasource.concurrent-connection-validation</code></td><td></td><td></td></tr><tr><td><code>spring.jta.atomikos.properties.allow-sub-transactions</code></td><td><code>true</code></td><td>Specify whether sub-transactions are allowed.</td></tr><tr><td><code>spring.jta.atomikos.properties.default-max-wait-time-on-shutdown</code></td><td></td><td>How long should normal shutdown (no-force) wait for transactions to complete.</td></tr><tr><td><code>spring.jta.atomikos.properties.recovery.delay</code></td><td><code>10000ms</code></td><td>Delay between two recovery scans.</td></tr><tr><td><code>spring.jta.atomikos.properties.recovery.forget-orphaned-log-entries-delay</code></td><td><code>86400000ms</code></td><td>Delay after which recovery can cleanup pending (‘orphaned’) log entries.</td></tr><tr><td><code>spring.jta.atomikos.properties.recovery.max-retries</code></td><td><code>5</code></td><td>Number of retry attempts to commit the transaction before throwing an exception.</td></tr><tr><td><code>spring.jta.atomikos.properties.recovery.retry-interval</code></td><td><code>10000ms</code></td><td>Delay between retry attempts.</td></tr><tr><td><code>spring.kafka.admin.client-id</code></td><td></td><td>ID to pass to the server when making requests.</td></tr><tr><td><code>spring.kafka.admin.fail-fast</code></td><td><code>false</code></td><td>Whether to fail fast if the broker is not available on startup.</td></tr><tr><td><code>spring.kafka.admin.properties</code></td><td></td><td>Additional admin-specific properties used to configure the client.</td></tr><tr><td><code>spring.kafka.admin.ssl.key-password</code></td><td></td><td>Password of the private key in the key store file.</td></tr><tr><td><code>spring.kafka.admin.ssl.keystore-location</code></td><td></td><td>Location of the key store file.</td></tr><tr><td><code>spring.kafka.admin.ssl.keystore-password</code></td><td></td><td>Store password for the key store file.</td></tr><tr><td><code>spring.kafka.admin.ssl.truststore-location</code></td><td></td><td>Location of the trust store file.</td></tr><tr><td><code>spring.kafka.admin.ssl.truststore-password</code></td><td></td><td>Store password for the trust store file.</td></tr><tr><td><code>spring.kafka.consumer.properties</code></td><td></td><td>Additional consumer-specific properties used to configure the client.</td></tr><tr><td><code>spring.kafka.consumer.ssl.key-password</code></td><td></td><td>Password of the private key in the key store file.</td></tr><tr><td><code>spring.kafka.consumer.ssl.keystore-location</code></td><td></td><td>Location of the key store file.</td></tr><tr><td><code>spring.kafka.consumer.ssl.keystore-password</code></td><td></td><td>Store password for the key store file.</td></tr><tr><td><code>spring.kafka.consumer.ssl.truststore-location</code></td><td></td><td>Location of the trust store file.</td></tr><tr><td><code>spring.kafka.consumer.ssl.truststore-password</code></td><td></td><td>Store password for the trust store file.</td></tr><tr><td><code>spring.kafka.jaas.control-flag</code></td><td><code>required</code></td><td>Control flag for login configuration.</td></tr><tr><td><code>spring.kafka.jaas.enabled</code></td><td><code>false</code></td><td>Whether to enable JAAS configuration.</td></tr><tr><td><code>spring.kafka.jaas.login-module</code></td><td><code>com.sun.security.auth           .module.Krb5LoginModule</code></td><td>Login module.</td></tr><tr><td><code>spring.kafka.jaas.options</code></td><td></td><td>Additional JAAS options.</td></tr><tr><td><code>spring.kafka.listener.client-id</code></td><td></td><td>Prefix for the listener’s consumer client.id property.</td></tr><tr><td><code>spring.kafka.listener.idle-event-interval</code></td><td></td><td>Time between publishing idle consumer events (no data received).</td></tr><tr><td><code>spring.kafka.listener.log-container-config</code></td><td></td><td>Whether to log the container configuration during initialization (INFO level).</td></tr><tr><td><code>spring.kafka.listener.monitor-interval</code></td><td></td><td>Time between checks for non-responsive consumers.</td></tr><tr><td><code>spring.kafka.listener.no-poll-threshold</code></td><td></td><td>Multiplier applied to “pollTimeout” to determine if a consumer is non-responsive.</td></tr><tr><td><code>spring.kafka.listener.type</code></td><td><code>single</code></td><td>Listener type.</td></tr><tr><td><code>spring.kafka.producer.properties</code></td><td></td><td>Additional producer-specific properties used to configure the client.</td></tr><tr><td><code>spring.kafka.producer.ssl.key-password</code></td><td></td><td>Password of the private key in the key store file.</td></tr><tr><td><code>spring.kafka.producer.ssl.keystore-location</code></td><td></td><td>Location of the key store file.</td></tr><tr><td><code>spring.kafka.producer.ssl.keystore-password</code></td><td></td><td>Store password for the key store file.</td></tr><tr><td><code>spring.kafka.producer.ssl.truststore-location</code></td><td></td><td>Location of the trust store file.</td></tr><tr><td><code>spring.kafka.producer.ssl.truststore-password</code></td><td></td><td>Store password for the trust store file.</td></tr><tr><td><code>spring.kafka.producer.transaction-id-prefix</code></td><td></td><td>When non empty, enables transaction support for producer.</td></tr><tr><td><code>spring.ldap.anonymous-read-only</code></td><td><code>false</code></td><td>Whether read-only operations should use an anonymous environment.</td></tr><tr><td><code>spring.liquibase.change-log</code></td><td><code>classpath:/db/changelog/     db.changelog-master.yaml</code></td><td>Change log configuration path.</td></tr><tr><td><code>spring.liquibase.check-change-log-location</code></td><td><code>true</code></td><td>Whether to check that the change log location exists.</td></tr><tr><td><code>spring.liquibase.contexts</code></td><td></td><td>Comma-separated list of runtime contexts to use.</td></tr><tr><td><code>spring.liquibase.default-schema</code></td><td></td><td>Default database schema.</td></tr><tr><td><code>spring.liquibase.drop-first</code></td><td><code>false</code></td><td>Whether to first drop the database schema.</td></tr><tr><td><code>spring.liquibase.enabled</code></td><td><code>true</code></td><td>Whether to enable Liquibase support.</td></tr><tr><td><code>spring.liquibase.labels</code></td><td></td><td>Comma-separated list of runtime labels to use.</td></tr><tr><td><code>spring.liquibase.parameters</code></td><td></td><td>Change log parameters.</td></tr><tr><td><code>spring.liquibase.password</code></td><td></td><td>Login password of the database to migrate.</td></tr><tr><td><code>spring.liquibase.rollback-file</code></td><td></td><td>File to which rollback SQL is written when an update is performed.</td></tr><tr><td><code>spring.liquibase.url</code></td><td></td><td>JDBC URL of the database to migrate.</td></tr><tr><td><code>spring.liquibase.user</code></td><td></td><td>Login user of the database to migrate.</td></tr><tr><td><code>spring.main.web-application-type</code></td><td></td><td>Flag to explicitly request a specific type of web application.</td></tr><tr><td><code>spring.messages.cache-duration</code></td><td></td><td>Loaded resource bundle files cache duration.</td></tr><tr><td><code>spring.messages.use-code-as-default-message</code></td><td><code>false</code></td><td>Whether to use the message code as the default message instead of throwing a “NoSuchMessageException”.</td></tr><tr><td><code>spring.mvc.contentnegotiation.favor-parameter</code></td><td><code>false</code></td><td>Whether a request parameter (“format” by default) should be used to determine the requested media type.</td></tr><tr><td><code>spring.mvc.contentnegotiation.favor-path-extension</code></td><td><code>false</code></td><td>Whether the path extension in the URL path should be used to determine the requested media type.</td></tr><tr><td><code>spring.mvc.contentnegotiation.media-types</code></td><td></td><td>Map file extensions to media types for content negotiation.</td></tr><tr><td><code>spring.mvc.contentnegotiation.parameter-name</code></td><td></td><td>Query parameter name to use when “favor-parameter” is enabled.</td></tr><tr><td><code>spring.mvc.pathmatch.use-registered-suffix-pattern</code></td><td><code>false</code></td><td>Whether suffix pattern matching should work only against extensions registered with “spring.mvc.contentnegotiation.media-types.*”.</td></tr><tr><td><code>spring.mvc.pathmatch.use-suffix-pattern</code></td><td><code>false</code></td><td>Whether to use suffix pattern match (“.*”) when matching patterns to requests.</td></tr><tr><td><code>spring.quartz.jdbc.initialize-schema</code></td><td><code>embedded</code></td><td>Database schema initialization mode.</td></tr><tr><td><code>spring.quartz.jdbc.schema</code></td><td><code>classpath:org/quartz/impl/ jdbcjobstore/ tables_@@platform@@.sql</code></td><td>Path to the SQL file to use to initialize the database schema.</td></tr><tr><td><code>spring.quartz.job-store-type</code></td><td><code>memory</code></td><td>Quartz job store type.</td></tr><tr><td><code>spring.quartz.properties</code></td><td></td><td>Additional Quartz Scheduler properties.</td></tr><tr><td><code>spring.rabbitmq.listener.direct.acknowledge-mode</code></td><td></td><td>Acknowledge mode of container.</td></tr><tr><td><code>spring.rabbitmq.listener.direct.auto-startup</code></td><td><code>true</code></td><td>Whether to start the container automatically on startup.</td></tr><tr><td><code>spring.rabbitmq.listener.direct.consumers-per-queue</code></td><td></td><td>Number of consumers per queue.</td></tr><tr><td><code>spring.rabbitmq.listener.direct.default-requeue-rejected</code></td><td></td><td>Whether rejected deliveries are re-queued by default.</td></tr><tr><td><code>spring.rabbitmq.listener.direct.idle-event-interval</code></td><td></td><td>How often idle container events should be published.</td></tr><tr><td><code>spring.rabbitmq.listener.direct.prefetch</code></td><td></td><td>Number of messages to be handled in a single request.</td></tr><tr><td><code>spring.rabbitmq.listener.direct.retry.enabled</code></td><td><code>false</code></td><td>Whether publishing retries are enabled.</td></tr><tr><td><code>spring.rabbitmq.listener.direct.retry.initial-interval</code></td><td><code>1000ms</code></td><td>Duration between the first and second attempt to deliver a message.</td></tr><tr><td><code>spring.rabbitmq.listener.direct.retry.max-attempts</code></td><td><code>3</code></td><td>Maximum number of attempts to deliver a message.</td></tr><tr><td><code>spring.rabbitmq.listener.direct.retry.max-interval</code></td><td><code>10000ms</code></td><td>Maximum duration between attempts.</td></tr><tr><td><code>spring.rabbitmq.listener.direct.retry.multiplier</code></td><td><code>1</code></td><td>Multiplier to apply to the previous retry interval.</td></tr><tr><td><code>spring.rabbitmq.listener.direct.retry.stateless</code></td><td><code>true</code></td><td>Whether retries are stateless or stateful.</td></tr><tr><td><code>spring.rabbitmq.listener.type</code></td><td><code>simple</code></td><td>Listener container type.</td></tr><tr><td><code>spring.rabbitmq.ssl.key-store-type</code></td><td><code>PKCS12</code></td><td>Key store type.</td></tr><tr><td><code>spring.rabbitmq.ssl.trust-store-type</code></td><td><code>JKS</code></td><td>Trust store type.</td></tr><tr><td><code>spring.rabbitmq.template.exchange</code></td><td>``</td><td>Name of the default exchange to use for send operations.</td></tr><tr><td><code>spring.rabbitmq.template.routing-key</code></td><td>``</td><td>Value of a default routing key to use for send operations.</td></tr><tr><td><code>spring.reactor.stacktrace-mode.enabled</code></td><td><code>false</code></td><td>Whether Reactor should collect stacktrace information at runtime.</td></tr><tr><td><code>spring.redis.jedis.pool.max-active</code></td><td><code>8</code></td><td>Maximum number of connections that can be allocated by the pool at a given time.</td></tr><tr><td><code>spring.redis.jedis.pool.max-idle</code></td><td><code>8</code></td><td>Maximum number of “idle” connections in the pool.</td></tr><tr><td><code>spring.redis.jedis.pool.max-wait</code></td><td><code>-1ms</code></td><td>Maximum amount of time a connection allocation should block before throwing an exception when the pool is exhausted.</td></tr><tr><td><code>spring.redis.jedis.pool.min-idle</code></td><td><code>0</code></td><td>Target for the minimum number of idle connections to maintain in the pool.</td></tr><tr><td><code>spring.redis.lettuce.pool.max-active</code></td><td><code>8</code></td><td>Maximum number of connections that can be allocated by the pool at a given time.</td></tr><tr><td><code>spring.redis.lettuce.pool.max-idle</code></td><td><code>8</code></td><td>Maximum number of “idle” connections in the pool.</td></tr><tr><td><code>spring.redis.lettuce.pool.max-wait</code></td><td><code>-1ms</code></td><td>Maximum amount of time a connection allocation should block before throwing an exception when the pool is exhausted.</td></tr><tr><td><code>spring.redis.lettuce.pool.min-idle</code></td><td><code>0</code></td><td>Target for the minimum number of idle connections to maintain in the pool.</td></tr><tr><td><code>spring.redis.lettuce.shutdown-timeout</code></td><td><code>100ms</code></td><td>Shutdown timeout.</td></tr><tr><td><code>spring.resources.cache.cachecontrol.cache-private</code></td><td></td><td>Indicate that the response message is intended for a single user and must not be stored by a shared cache.</td></tr><tr><td><code>spring.resources.cache.cachecontrol.cache-public</code></td><td></td><td>Indicate that any cache may store the response.</td></tr><tr><td><code>spring.resources.cache.cachecontrol.max-age</code></td><td></td><td>Maximum time the response should be cached, in seconds if no duration suffix is not specified.</td></tr><tr><td><code>spring.resources.cache.cachecontrol.must-revalidate</code></td><td></td><td>Indicate that once it has become stale, a cache must not use the response without re-validating it with the server.</td></tr><tr><td><code>spring.resources.cache.cachecontrol.no-cache</code></td><td></td><td>Indicate that the cached response can be reused only if re-validated with the server.</td></tr><tr><td><code>spring.resources.cache.cachecontrol.no-store</code></td><td></td><td>Indicate to not cache the response in any case.</td></tr><tr><td><code>spring.resources.cache.cachecontrol.no-transform</code></td><td></td><td>Indicate intermediaries (caches and others) that they should not transform the response content.</td></tr><tr><td><code>spring.resources.cache.cachecontrol.proxy-revalidate</code></td><td></td><td>Same meaning as the “must-revalidate” directive, except that it does not apply to private caches.</td></tr><tr><td><code>spring.resources.cache.cachecontrol.s-max-age</code></td><td></td><td>Maximum time the response should be cached by shared caches, in seconds if no duration suffix is not specified.</td></tr><tr><td><code>spring.resources.cache.cachecontrol.stale-if-error</code></td><td></td><td>Maximum time the response may be used when errors are encountered, in seconds if no duration suffix is not specified.</td></tr><tr><td><code>spring.resources.cache.cachecontrol.stale-while-revalidate</code></td><td></td><td>Maximum time the response can be served after it becomes stale, in seconds if no duration suffix is not specified.</td></tr><tr><td><code>spring.resources.cache.period</code></td><td></td><td>Cache period for the resources served by the resource handler.</td></tr><tr><td><code>spring.security.filter.dispatcher-types</code></td><td><code>async,error,request</code></td><td>Security filter chain dispatcher types.</td></tr><tr><td><code>spring.security.filter.order</code></td><td><code>-100</code></td><td>Security filter chain order.</td></tr><tr><td><code>spring.security.oauth2.client.provider</code></td><td></td><td>OAuth provider details.</td></tr><tr><td><code>spring.security.oauth2.client.registration</code></td><td></td><td>OAuth client registrations.</td></tr><tr><td><code>spring.security.user.name</code></td><td><code>user</code></td><td>Default user name.</td></tr><tr><td><code>spring.security.user.password</code></td><td></td><td>Password for the default user name.</td></tr><tr><td><code>spring.security.user.roles</code></td><td></td><td>Granted roles for the default user name.</td></tr><tr><td><code>spring.servlet.multipart.enabled</code></td><td><code>true</code></td><td>Whether to enable support of multipart uploads.</td></tr><tr><td><code>spring.servlet.multipart.file-size-threshold</code></td><td><code>0</code></td><td>Threshold after which files are written to disk.</td></tr><tr><td><code>spring.servlet.multipart.location</code></td><td></td><td>Intermediate location of uploaded files.</td></tr><tr><td><code>spring.servlet.multipart.max-file-size</code></td><td><code>1MB</code></td><td>Max file size.</td></tr><tr><td><code>spring.servlet.multipart.max-request-size</code></td><td><code>10MB</code></td><td>Max request size.</td></tr><tr><td><code>spring.servlet.multipart.resolve-lazily</code></td><td><code>false</code></td><td>Whether to resolve the multipart request lazily at the time of file or parameter access.</td></tr><tr><td><code>spring.session.jdbc.cleanup-cron</code></td><td><code>0 * * * * *</code></td><td>Cron expression for expired session cleanup job.</td></tr><tr><td><code>spring.session.jdbc.initialize-schema</code></td><td><code>embedded</code></td><td>Database schema initialization mode.</td></tr><tr><td><code>spring.session.mongodb.collection-name</code></td><td><code>sessions</code></td><td>Collection name used to store sessions.</td></tr><tr><td><code>spring.session.redis.cleanup-cron</code></td><td><code>0 * * * * *</code></td><td>Cron expression for expired session cleanup job.</td></tr><tr><td><code>spring.session.servlet.filter-dispatcher-types</code></td><td><code>async,error,request</code></td><td>Session repository filter dispatcher types.</td></tr><tr><td><code>spring.session.servlet.filter-order</code></td><td></td><td>Session repository filter order.</td></tr><tr><td><code>spring.thymeleaf.enable-spring-el-compiler</code></td><td><code>false</code></td><td>Enable the SpringEL compiler in SpringEL expressions.</td></tr><tr><td><code>spring.thymeleaf.reactive.chunked-mode-view-names</code></td><td></td><td>Comma-separated list of view names (patterns allowed) that should be the only ones executed in CHUNKED mode when a max chunk size is set.</td></tr><tr><td><code>spring.thymeleaf.reactive.full-mode-view-names</code></td><td></td><td>Comma-separated list of view names (patterns allowed) that should be executed in FULL mode even if a max chunk size is set.</td></tr><tr><td><code>spring.thymeleaf.reactive.max-chunk-size</code></td><td><code>0</code></td><td>Maximum size of data buffers used for writing to the response, in bytes.</td></tr><tr><td><code>spring.thymeleaf.reactive.media-types</code></td><td></td><td>Media types supported by the view technology.</td></tr><tr><td><code>spring.thymeleaf.servlet.content-type</code></td><td><code>text/html</code></td><td>Content-Type value written to HTTP responses.</td></tr><tr><td><code>spring.webflux.date-format</code></td><td></td><td>Date format to use.</td></tr><tr><td><code>spring.webflux.static-path-pattern</code></td><td><code>/**</code></td><td>Path pattern used for static resources.</td></tr><tr><td><code>spring.webservices.wsdl-locations</code></td><td></td><td>Comma-separated list of locations of WSDLs and accompanying XSDs to be exposed as beans.</td></tr></tbody></table><table><thead><tr><th>Key</th><th>Replacement（替代）</th><th>原因</th></tr></thead><tbody><tr><td><code>banner.charset</code></td><td><code>spring.banner.charset</code></td><td></td></tr><tr><td><code>banner.image.height</code></td><td><code>spring.banner.image.height</code></td><td></td></tr><tr><td><code>banner.image.invert</code></td><td><code>spring.banner.image.invert</code></td><td></td></tr><tr><td><code>banner.image.location</code></td><td><code>spring.banner.image.location</code></td><td></td></tr><tr><td><code>banner.image.margin</code></td><td><code>spring.banner.image.margin</code></td><td></td></tr><tr><td><code>banner.image.width</code></td><td><code>spring.banner.image.width</code></td><td></td></tr><tr><td><code>banner.location</code></td><td><code>spring.banner.location</code></td><td></td></tr><tr><td><code>endpoints.actuator.enabled</code></td><td></td><td>actuator  端点不再可用</td></tr><tr><td><code>endpoints.actuator.path</code></td><td></td><td>actuator  端点不再可用</td></tr><tr><td><code>endpoints.actuator.sensitive</code></td><td></td><td>actuator  端点不再可用</td></tr><tr><td><code>endpoints.auditevents.enabled</code></td><td><code>management.endpoint.  auditevents.enabled</code></td><td></td></tr><tr><td><code>endpoints.auditevents.path</code></td><td><code>management.endpoints.web.path-mapping.auditevents</code></td><td></td></tr><tr><td><code>endpoints.auditevents.sensitive</code></td><td></td><td>终端敏感标志不再可定制，因为Spring Boot 不再提供可自定义的安全自动配置</td></tr><tr><td><code>endpoints.autoconfig.enabled</code></td><td><code>management.endpoint.   conditions.enabled</code></td><td></td></tr><tr><td><code>endpoints.autoconfig.id</code></td><td></td><td>端点标识符不再可定制</td></tr><tr><td><code>endpoints.autoconfig.path</code></td><td><code>management.endpoints.web.path-mapping.conditions</code></td><td></td></tr><tr><td><code>endpoints.autoconfig.sensitive</code></td><td></td><td>终端敏感标志不再可定制，因为Spring Boot 不再提供可自定义的安全自动配置</td></tr><tr><td><code>endpoints.beans.enabled</code></td><td><code>management.endpoint.beans.enabled</code></td><td></td></tr><tr><td><code>endpoints.beans.id</code></td><td></td><td>端点标识符不再可定制</td></tr><tr><td><code>endpoints.beans.path</code></td><td><code>management.endpoints.web.path-mapping.beans</code></td><td></td></tr><tr><td><code>endpoints.beans.sensitive</code></td><td></td><td>终端敏感标志不再可定制，因为Spring Boot 不再提供可自定义的安全自动配置</td></tr><tr><td><code>endpoints.configprops.enabled</code></td><td><code>management.endpoint.   configprops.enabled</code></td><td></td></tr><tr><td><code>endpoints.configprops.id</code></td><td></td><td>端点标识符不再可定制</td></tr><tr><td><code>endpoints.configprops.keys-to-sanitize</code></td><td><code>management.endpoint.     configprops.keys-to-sanitize</code></td><td></td></tr><tr><td><code>endpoints.configprops.path</code></td><td><code>management.endpoints.web.path-mapping.configprops</code></td><td></td></tr><tr><td><code>endpoints.configprops.sensitive</code></td><td></td><td>终端敏感标志不再可定制，因为Spring Boot 不再提供可自定义的安全自动配置</td></tr><tr><td><code>endpoints.cors.allow-credentials</code></td><td><code>management.endpoints.      web.cors.allow-credentials</code></td><td></td></tr><tr><td><code>endpoints.cors.allowed-headers</code></td><td><code>management.endpoints.    web.cors.allowed-headers</code></td><td></td></tr><tr><td><code>endpoints.cors.allowed-methods</code></td><td><code>management.endpoints.    web.cors.allowed-methods</code></td><td></td></tr><tr><td><code>endpoints.cors.allowed-origins</code></td><td><code>management.endpoints.    web.cors.allowed-origins</code></td><td></td></tr><tr><td><code>endpoints.cors.exposed-headers</code></td><td><code>management.endpoints.    web.cors.exposed-headers</code></td><td></td></tr><tr><td><code>endpoints.cors.max-age</code></td><td><code>management.endpoints.        web.cors.max-age</code></td><td></td></tr><tr><td><code>endpoints.docs.curies.enabled</code></td><td></td><td>docs 端点不再可用</td></tr><tr><td><code>endpoints.docs.enabled</code></td><td></td><td>docs 端点不再可用</td></tr><tr><td><code>endpoints.docs.path</code></td><td></td><td>docs 端点不再可用</td></tr><tr><td><code>endpoints.docs.sensitive</code></td><td></td><td>docs 端点不再可用</td></tr><tr><td><code>endpoints.dump.enabled</code></td><td><code>management.endpoint.    threaddump.enabled</code></td><td></td></tr><tr><td><code>endpoints.dump.id</code></td><td></td><td>端点标识符不再可定制</td></tr><tr><td><code>endpoints.dump.path</code></td><td><code>management.endpoints.web.path-mapping.dump</code></td><td></td></tr><tr><td><code>endpoints.dump.sensitive</code></td><td></td><td>终端敏感标志不再可定制，因为Spring Boot 不再提供可自定义的安全自动配置</td></tr><tr><td><code>endpoints.enabled</code></td><td><code>management.endpoints.             enabled-by-default</code></td><td></td></tr><tr><td><code>endpoints.env.enabled</code></td><td><code>management.endpoint.env.enabled</code></td><td></td></tr><tr><td><code>endpoints.env.id</code></td><td></td><td>端点标识符不再可定制</td></tr><tr><td><code>endpoints.env.keys-to-sanitize</code></td><td><code>management.endpoint.             env.keys-to-sanitize</code></td><td></td></tr><tr><td><code>endpoints.env.path</code></td><td><code>management.endpoints.            web.path-mapping.env</code></td><td></td></tr><tr><td><code>endpoints.env.sensitive</code></td><td></td><td>终端敏感标志不再可定制，因为Spring Boot 不再提供可自定义的安全自动配置</td></tr><tr><td><code>endpoints.flyway.enabled</code></td><td><code>management.endpoint.flyway.enabled</code></td><td></td></tr><tr><td><code>endpoints.flyway.id</code></td><td></td><td>端点标识符不再可定制</td></tr><tr><td><code>endpoints.flyway.sensitive</code></td><td></td><td>终端敏感标志不再可定制，因为Spring Boot 不再提供可自定义的安全自动配置</td></tr><tr><td><code>endpoints.health.enabled</code></td><td><code>management.endpoint.health.enabled</code></td><td></td></tr><tr><td><code>endpoints.health.id</code></td><td></td><td>端点标识符不再可定制</td></tr><tr><td><code>endpoints.health.mapping</code></td><td><code>management.health.status.http-mapping</code></td><td></td></tr><tr><td><code>endpoints.health.path</code></td><td><code>management.endpoints.web.path-mapping.health</code></td><td></td></tr><tr><td><code>endpoints.health.sensitive</code></td><td></td><td>终端敏感标志不再可定制，因为Spring Boot 不再提供可自定义的安全自动配置</td></tr><tr><td><code>endpoints.health.time-to-live</code></td><td><code>management.endpoint.    health.cache.time-to-live</code></td><td></td></tr><tr><td><code>endpoints.heapdump.enabled</code></td><td><code>management.endpoint.heapdump.enabled</code></td><td></td></tr><tr><td><code>endpoints.heapdump.path</code></td><td><code>management.endpoints.web.path-mapping.heapdump</code></td><td></td></tr><tr><td><code>endpoints.heapdump.sensitive</code></td><td></td><td>终端敏感标志不再可定制，因为Spring Boot 不再提供可自定义的安全自动配置</td></tr><tr><td><code>endpoints.hypermedia.enabled</code></td><td></td><td>Actuator 中的 Hypermedia 不再可用</td></tr><tr><td><code>endpoints.info.enabled</code></td><td><code>management.endpoint.info.enabled</code></td><td></td></tr><tr><td><code>endpoints.info.id</code></td><td></td><td>端点标识符不再可定制</td></tr><tr><td><code>endpoints.info.path</code></td><td><code>management.endpoints.web.path-mapping.info</code></td><td></td></tr><tr><td><code>endpoints.info.sensitive</code></td><td></td><td>终端敏感标志不再可定制，因为Spring Boot 不再提供可自定义的安全自动配置</td></tr><tr><td><code>endpoints.jmx.domain</code></td><td><code>management.endpoints.jmx.domain</code></td><td></td></tr><tr><td><code>endpoints.jmx.enabled</code></td><td><code>management.endpoints. jmx.exposure.exclude</code></td><td></td></tr><tr><td><code>endpoints.jmx.static-names</code></td><td><code>management.endpoints.        jmx.static-names</code></td><td></td></tr><tr><td><code>endpoints.jmx.unique-names</code></td><td><code>management.endpoints.        jmx.unique-names</code></td><td></td></tr><tr><td><code>endpoints.jolokia.enabled</code></td><td><code>management.endpoint.     jolokia.enabled</code></td><td></td></tr><tr><td><code>endpoints.jolokia.path</code></td><td><code>management.endpoints.web.path-mapping.jolokia</code></td><td></td></tr><tr><td><code>endpoints.jolokia.sensitive</code></td><td></td><td>终端敏感标志不再可定制，因为Spring Boot 不再提供可自定义的安全自动配置</td></tr><tr><td><code>endpoints.liquibase.enabled</code></td><td><code>management.endpoint.   liquibase.enabled</code></td><td></td></tr><tr><td><code>endpoints.liquibase.id</code></td><td></td><td>端点标识符不再可定制</td></tr><tr><td><code>endpoints.liquibase.sensitive</code></td><td></td><td>终端敏感标志不再可定制，因为Spring Boot 不再提供可自定义的安全自动配置</td></tr><tr><td><code>endpoints.logfile.enabled</code></td><td><code>management.endpoint.     logfile.enabled</code></td><td></td></tr><tr><td><code>endpoints.logfile.external-file</code></td><td><code>management.endpoint.     logfile.external-file</code></td><td></td></tr><tr><td><code>endpoints.logfile.path</code></td><td><code>management.endpoints.web.path-mapping.logfile</code></td><td></td></tr><tr><td><code>endpoints.logfile.sensitive</code></td><td></td><td>终端敏感标志不再可定制，因为Spring Boot 不再提供可自定义的安全自动配置</td></tr><tr><td><code>endpoints.loggers.enabled</code></td><td><code>management.endpoint.      loggers.enabled</code></td><td></td></tr><tr><td><code>endpoints.loggers.id</code></td><td></td><td>端点标识符不再可定制</td></tr><tr><td><code>endpoints.loggers.path</code></td><td><code>management.endpoints.web.path-mapping.loggers</code></td><td></td></tr><tr><td><code>endpoints.loggers.sensitive</code></td><td></td><td>终端敏感标志不再可定制，因为Spring Boot 不再提供可自定义的安全自动配置</td></tr><tr><td><code>endpoints.mappings.enabled</code></td><td><code>management.endpoint.     mappings.enabled</code></td><td></td></tr><tr><td><code>endpoints.mappings.id</code></td><td></td><td>端点标识符不再可定制</td></tr><tr><td><code>endpoints.mappings.path</code></td><td><code>management.endpoints.web.path-mapping.mappings</code></td><td></td></tr><tr><td><code>endpoints.mappings.sensitive</code></td><td></td><td>终端敏感标志不再可定制，因为Spring Boot 不再提供可自定义的安全自动配置</td></tr><tr><td><code>endpoints.metrics.enabled</code></td><td><code>management.endpoint.metrics.enabled</code></td><td></td></tr><tr><td><code>endpoints.metrics.filter.counter-submissions</code></td><td></td><td>Metrics support 现在使用千分尺</td></tr><tr><td><code>endpoints.metrics.filter.enabled</code></td><td></td><td>Metrics support 现在使用千分尺</td></tr><tr><td><code>endpoints.metrics.filter.gauge-submissions</code></td><td></td><td>Metrics support 现在使用千分尺</td></tr><tr><td><code>endpoints.metrics.id</code></td><td></td><td>端点标识符不再可定制</td></tr><tr><td><code>endpoints.metrics.path</code></td><td><code>management.endpoints.web.path-mapping.metrics</code></td><td></td></tr><tr><td><code>endpoints.metrics.sensitive</code></td><td></td><td>终端敏感标志不再可定制，因为Spring Boot 不再提供可自定义的安全自动配置</td></tr><tr><td><code>endpoints.sensitive</code></td><td></td><td>终端敏感标志不再可定制，因为Spring Boot 不再提供可自定义的安全自动配置</td></tr><tr><td><code>endpoints.shutdown.enabled</code></td><td><code>management.endpoint.     shutdown.enabled</code></td><td></td></tr><tr><td><code>endpoints.shutdown.id</code></td><td></td><td>端点标识符不再可定制</td></tr><tr><td><code>endpoints.shutdown.path</code></td><td><code>management.endpoints.web.path-mapping.shutdown</code></td><td></td></tr><tr><td><code>endpoints.shutdown.sensitive</code></td><td></td><td>终端敏感标志不再可定制，因为Spring Boot 不再提供可自定义的安全自动配置</td></tr><tr><td><code>endpoints.trace.enabled</code></td><td><code>management.endpoint.     httptrace.enabled</code></td><td></td></tr><tr><td><code>endpoints.trace.filter.enabled</code></td><td><code>management.trace.http.enabled</code></td><td></td></tr><tr><td><code>endpoints.trace.id</code></td><td></td><td>端点标识符不再可定制</td></tr><tr><td><code>endpoints.trace.path</code></td><td><code>management.endpoints.web.path-mapping.httptrace</code></td><td></td></tr><tr><td><code>endpoints.trace.sensitive</code></td><td></td><td>终端敏感标志不再可定制，因为Spring Boot 不再提供可自定义的安全自动配置</td></tr><tr><td><code>error.path</code></td><td></td><td>Path of the error controller.</td></tr><tr><td><code>flyway.baseline-description</code></td><td><code>spring.flyway.baseline-description</code></td><td></td></tr><tr><td><code>flyway.baseline-on-migrate</code></td><td><code>spring.flyway.baseline-on-migrate</code></td><td></td></tr><tr><td><code>flyway.baseline-version</code></td><td><code>spring.flyway.baseline-version</code></td><td></td></tr><tr><td><code>flyway.check-location</code></td><td><code>spring.flyway.check-location</code></td><td></td></tr><tr><td><code>flyway.clean-on-validation-error</code></td><td><code>spring.flyway.                    clean-on-validation-error</code></td><td></td></tr><tr><td><code>flyway.enabled</code></td><td><code>spring.flyway.enabled</code></td><td></td></tr><tr><td><code>flyway.encoding</code></td><td><code>spring.flyway.encoding</code></td><td></td></tr><tr><td><code>flyway.ignore-failed-future-migration</code></td><td></td><td></td></tr><tr><td><code>flyway.init-sqls</code></td><td><code>spring.flyway.init-sqls</code></td><td></td></tr><tr><td><code>flyway.locations</code></td><td><code>spring.flyway.locations</code></td><td></td></tr><tr><td><code>flyway.out-of-order</code></td><td><code>spring.flyway.out-of-order</code></td><td></td></tr><tr><td><code>flyway.password</code></td><td><code>spring.flyway.password</code></td><td></td></tr><tr><td><code>flyway.placeholder-prefix</code></td><td><code>spring.flyway.placeholder-prefix</code></td><td></td></tr><tr><td><code>flyway.placeholder-replacement</code></td><td><code>spring.flyway.placeholder-replacement</code></td><td></td></tr><tr><td><code>flyway.placeholder-suffix</code></td><td><code>spring.flyway.placeholder-suffix</code></td><td></td></tr><tr><td><code>flyway.placeholders</code></td><td><code>spring.flyway.placeholders</code></td><td></td></tr><tr><td><code>flyway.schemas</code></td><td><code>spring.flyway.schemas</code></td><td></td></tr><tr><td><code>flyway.sql-migration-prefix</code></td><td><code>spring.flyway.sql-migration-prefix</code></td><td></td></tr><tr><td><code>flyway.sql-migration-separator</code></td><td><code>spring.flyway.sql-migration-separator</code></td><td></td></tr><tr><td><code>flyway.sql-migration-suffix</code></td><td><code>spring.flyway.sql-migration-suffixes</code></td><td></td></tr><tr><td><code>flyway.table</code></td><td><code>spring.flyway.table</code></td><td></td></tr><tr><td><code>flyway.target</code></td><td><code>spring.flyway.target</code></td><td></td></tr><tr><td><code>flyway.url</code></td><td><code>spring.flyway.url</code></td><td></td></tr><tr><td><code>flyway.user</code></td><td><code>spring.flyway.user</code></td><td></td></tr><tr><td><code>flyway.validate-on-migrate</code></td><td><code>spring.flyway.validate-on-migrate</code></td><td></td></tr><tr><td><code>jolokia.config</code></td><td><code>management.endpoint.jolokia.config</code></td><td></td></tr><tr><td><code>liquibase.change-log</code></td><td><code>spring.liquibase.change-log</code></td><td></td></tr><tr><td><code>liquibase.check-change-log-location</code></td><td><code>spring.liquibase.check-change-log-location</code></td><td></td></tr><tr><td><code>liquibase.contexts</code></td><td><code>spring.liquibase.contexts</code></td><td></td></tr><tr><td><code>liquibase.default-schema</code></td><td><code>spring.liquibase.default-schema</code></td><td></td></tr><tr><td><code>liquibase.drop-first</code></td><td><code>spring.liquibase.drop-first</code></td><td></td></tr><tr><td><code>liquibase.enabled</code></td><td><code>spring.liquibase.enabled</code></td><td></td></tr><tr><td><code>liquibase.labels</code></td><td><code>spring.liquibase.labels</code></td><td></td></tr><tr><td><code>liquibase.parameters</code></td><td><code>spring.liquibase.parameters</code></td><td></td></tr><tr><td><code>liquibase.password</code></td><td><code>spring.liquibase.password</code></td><td></td></tr><tr><td><code>liquibase.rollback-file</code></td><td><code>spring.liquibase.rollback-file</code></td><td></td></tr><tr><td><code>liquibase.url</code></td><td><code>spring.liquibase.url</code></td><td></td></tr><tr><td><code>liquibase.user</code></td><td><code>spring.liquibase.user</code></td><td></td></tr><tr><td><code>management.add-application-context-header</code></td><td><code>management.server.add-application-context-header</code></td><td></td></tr><tr><td><code>management.address</code></td><td><code>management.server.address</code></td><td></td></tr><tr><td><code>management.context-path</code></td><td><code>management.server.       servlet.context-path</code></td><td></td></tr><tr><td><code>management.port</code></td><td><code>management.server.port</code></td><td></td></tr><tr><td><code>management.security.enabled</code></td><td></td><td>现在提供全局 security 自动配置。</td></tr><tr><td><code>management.security.roles</code></td><td></td><td>security 自动配置不再可定制</td></tr><tr><td><code>management.security.sessions</code></td><td></td><td>security 自动配置不再可定制</td></tr><tr><td><code>management.shell.auth.jaas.domain</code></td><td></td><td>CRaSH 支持不再可用</td></tr><tr><td><code>management.shell.auth.key.path</code></td><td></td><td>CRaSH 支持不再可用</td></tr><tr><td><code>management.shell.auth.simple.user.name</code></td><td></td><td>CRaSH 支持不再可用</td></tr><tr><td><code>management.shell.auth.simple.user.password</code></td><td></td><td>CRaSH 支持不再可用</td></tr><tr><td><code>management.shell.auth.spring.roles</code></td><td></td><td>CRaSH 支持不再可用</td></tr><tr><td><code>management.shell.auth.type</code></td><td></td><td>CRaSH 支持不再可用</td></tr><tr><td><code>management.shell.ssh.auth-timeout</code></td><td></td><td>CRaSH 支持不再可用</td></tr><tr><td><code>management.shell.ssh.enabled</code></td><td></td><td>CRaSH 支持不再可用</td></tr><tr><td><code>management.shell.ssh.idle-timeout</code></td><td></td><td>CRaSH 支持不再可用</td></tr><tr><td><code>management.shell.ssh.key-path</code></td><td></td><td>CRaSH 支持不再可用</td></tr><tr><td><code>management.shell.ssh.port</code></td><td></td><td>CRaSH 支持不再可用</td></tr><tr><td><code>management.shell.telnet.enabled</code></td><td></td><td>CRaSH 支持不再可用</td></tr><tr><td><code>management.shell.telnet.port</code></td><td></td><td>CRaSH 支持不再可用</td></tr><tr><td><code>management.ssl.ciphers</code></td><td><code>management.server.ssl.ciphers</code></td><td></td></tr><tr><td><code>management.ssl.client-auth</code></td><td><code>management.server.ssl.client-auth</code></td><td></td></tr><tr><td><code>management.ssl.enabled</code></td><td><code>management.server.ssl.enabled</code></td><td></td></tr><tr><td><code>management.ssl.enabled-protocols</code></td><td><code>management.server.ssl.enabled-protocols</code></td><td></td></tr><tr><td><code>management.ssl.key-alias</code></td><td><code>management.server.ssl.key-alias</code></td><td></td></tr><tr><td><code>management.ssl.key-password</code></td><td><code>management.server.ssl.key-password</code></td><td></td></tr><tr><td><code>management.ssl.key-store</code></td><td><code>management.server.ssl.key-store</code></td><td></td></tr><tr><td><code>management.ssl.key-store-password</code></td><td><code>management.server.ssl.key-store-password</code></td><td></td></tr><tr><td><code>management.ssl.key-store-provider</code></td><td><code>management.server.ssl.key-store-provider</code></td><td></td></tr><tr><td><code>management.ssl.key-store-type</code></td><td><code>management.server.ssl.key-store-type</code></td><td></td></tr><tr><td><code>management.ssl.protocol</code></td><td><code>management.server.ssl.protocol</code></td><td></td></tr><tr><td><code>management.ssl.trust-store</code></td><td><code>management.server.ssl.trust-store</code></td><td></td></tr><tr><td><code>management.ssl.trust-store-password</code></td><td><code>management.server.ssl.trust-store-password</code></td><td></td></tr><tr><td><code>management.ssl.trust-store-provider</code></td><td><code>management.server.ssl.trust-store-provider</code></td><td></td></tr><tr><td><code>management.ssl.trust-store-type</code></td><td><code>management.server.ssl.trust-store-type</code></td><td></td></tr><tr><td><code>management.trace.include</code></td><td><code>management.trace.http.include</code></td><td></td></tr><tr><td><code>security.basic.authorize-mode</code></td><td></td><td>security 自动配置不再可定制</td></tr><tr><td><code>security.basic.enabled</code></td><td></td><td>security 自动配置不再可定制</td></tr><tr><td><code>security.basic.path</code></td><td></td><td>security 自动配置不再可定制</td></tr><tr><td><code>security.basic.realm</code></td><td></td><td>security 自动配置不再可定制</td></tr><tr><td><code>security.enable-csrf</code></td><td></td><td>security 自动配置不再可定制</td></tr><tr><td><code>security.filter-dispatcher-types</code></td><td><code>spring.security.         filter.dispatcher-types</code></td><td></td></tr><tr><td><code>security.filter-order</code></td><td><code>spring.security.filter.order</code></td><td></td></tr><tr><td><code>security.headers.cache</code></td><td></td><td>security 自动配置不再可定制</td></tr><tr><td><code>security.headers.content-security-policy</code></td><td></td><td>security 自动配置不再可定制</td></tr><tr><td><code>security.headers.content-security-policy-mode</code></td><td></td><td>security 自动配置不再可定制</td></tr><tr><td><code>security.headers.content-type</code></td><td></td><td>security 自动配置不再可定制</td></tr><tr><td><code>security.headers.frame</code></td><td></td><td>security 自动配置不再可定制</td></tr><tr><td><code>security.headers.hsts</code></td><td></td><td>security 自动配置不再可定制</td></tr><tr><td><code>security.headers.xss</code></td><td></td><td>security 自动配置不再可定制</td></tr><tr><td><code>security.ignored</code></td><td></td><td>security 自动配置不再可定制</td></tr><tr><td><code>security.oauth2.                authorization.check-token-access</code></td><td></td><td>Spring Security 访问规则用于检查令牌端点（例如，SpEL表达式，如“isAuthenticated（）”）</td></tr><tr><td><code>security.oauth2.authorization.realm</code></td><td></td><td>客户端身份验证的领域名称</td></tr><tr><td><code>security.oauth2.authorization.token-key-access</code></td><td></td><td>Spring Security访问规则用于检查令牌端点（例如，SpEL表达式，如“isAuthenticated（）”）</td></tr><tr><td><code>security.oauth2.client.access-token-uri</code></td><td></td><td></td></tr><tr><td><code>security.oauth2.client.access-token-validity-seconds</code></td><td></td><td></td></tr><tr><td><code>security.oauth2.client.additional-information</code></td><td></td><td></td></tr><tr><td><code>security.oauth2.client.authentication-scheme</code></td><td></td><td></td></tr><tr><td><code>security.oauth2.client.authorities</code></td><td></td><td></td></tr><tr><td><code>security.oauth2.client.authorized-grant-types</code></td><td></td><td></td></tr><tr><td><code>security.oauth2.client.auto-approve-scopes</code></td><td></td><td></td></tr><tr><td><code>security.oauth2.client.client-authentication-scheme</code></td><td></td><td></td></tr><tr><td><code>security.oauth2.client.client-id</code></td><td></td><td></td></tr><tr><td><code>security.oauth2.client.client-secret</code></td><td></td><td></td></tr><tr><td><code>security.oauth2.client.grant-type</code></td><td></td><td></td></tr><tr><td><code>security.oauth2.client.id</code></td><td></td><td></td></tr><tr><td><code>security.oauth2.client.pre-            established-redirect-uri</code></td><td></td><td></td></tr><tr><td><code>security.oauth2.client.refresh-token-validity-seconds</code></td><td></td><td></td></tr><tr><td><code>security.oauth2.client.registered-redirect-uri</code></td><td></td><td></td></tr><tr><td><code>security.oauth2.client.resource-ids</code></td><td></td><td></td></tr><tr><td><code>security.oauth2.client.scope</code></td><td></td><td></td></tr><tr><td><code>security.oauth2.client.token-name</code></td><td></td><td></td></tr><tr><td><code>security.oauth2.client.use-current-uri</code></td><td></td><td></td></tr><tr><td><code>security.oauth2.client.user-authorization-uri</code></td><td></td><td></td></tr><tr><td><code>security.oauth2.resource.filter-order</code></td><td><code>0</code></td><td>用于验证令牌的过滤器链的顺序。</td></tr><tr><td><code>security.oauth2.resource.id</code></td><td></td><td>资源的标识符</td></tr><tr><td><code>security.oauth2.resource.jwk.key-set-uri</code></td><td></td><td>获取验证密钥以验证 JWT 令牌的 URI</td></tr><tr><td><code>security.oauth2.resource.jwt.key-uri</code></td><td></td><td>JWT 令牌的 URI</td></tr><tr><td><code>security.oauth2.resource.jwt.key-value</code></td><td></td><td>JWT 令牌的验证密钥</td></tr><tr><td><code>security.oauth2.resource.prefer-token-info</code></td><td><code>true</code></td><td>使用令牌信息，可以设置为 false以使用用户信息</td></tr><tr><td><code>security.oauth2.resource.service-id</code></td><td><code>resource</code></td><td></td></tr><tr><td><code>security.oauth2.resource.token-info-uri</code></td><td></td><td>token decoding 端点的 URI</td></tr><tr><td><code>security.oauth2.resource.token-type</code></td><td></td><td>使用 userInfoUri 时要发送的令牌类型。</td></tr><tr><td><code>security.oauth2.resource.user-info-uri</code></td><td></td><td>用户端点的 URI</td></tr><tr><td><code>security.oauth2.sso.filter-order</code></td><td></td><td>如果不提供显式的WebSecurityConfigurerAdapter，则应用过滤器顺序（在这种情况下，可以改为提供顺序）。</td></tr><tr><td><code>security.oauth2.sso.login-path</code></td><td><code>/login</code></td><td>登录页面的路径，即触发重定向到 OAuth2 授权服务器的页面。</td></tr><tr><td><code>security.require-ssl</code></td><td></td><td>security 自动配置已不再可定制</td></tr><tr><td><code>security.sessions</code></td><td></td><td>security 自动配置已不再可定制</td></tr><tr><td><code>security.user.name</code></td><td><code>spring.security.user.name</code></td><td></td></tr><tr><td><code>security.user.password</code></td><td><code>spring.security.user.password</code></td><td></td></tr><tr><td><code>security.user.role</code></td><td><code>spring.security.user.roles</code></td><td></td></tr><tr><td><code>server.context-parameters</code></td><td><code>server.servlet.context-parameters</code></td><td></td></tr><tr><td><code>server.context-path</code></td><td><code>server.servlet.context-path</code></td><td></td></tr><tr><td><code>server.display-name</code></td><td><code>server.servlet.             application-display-name</code></td><td></td></tr><tr><td><code>server.jsp-servlet.class-name</code></td><td><code>server.servlet.jsp.class-name</code></td><td></td></tr><tr><td><code>server.jsp-servlet.init-parameters</code></td><td><code>server.servlet.jsp.init-parameters</code></td><td></td></tr><tr><td><code>server.jsp-servlet.registered</code></td><td><code>server.servlet.jsp.registered</code></td><td></td></tr><tr><td><code>server.servlet-path</code></td><td><code>server.servlet.path</code></td><td></td></tr><tr><td><code>server.session.cookie.comment</code></td><td><code>server.servlet.session.cookie.comment</code></td><td></td></tr><tr><td><code>server.session.cookie.domain</code></td><td><code>server.servlet.session.cookie.domain</code></td><td></td></tr><tr><td><code>server.session.cookie.http-only</code></td><td><code>server.servlet.       session.cookie.http-only</code></td><td></td></tr><tr><td><code>server.session.cookie.max-age</code></td><td><code>server.servlet.session.cookie.max-age</code></td><td></td></tr><tr><td><code>server.session.cookie.name</code></td><td><code>server.servlet.session.cookie.name</code></td><td></td></tr><tr><td><code>server.session.cookie.path</code></td><td><code>server.servlet.session.cookie.path</code></td><td></td></tr><tr><td><code>server.session.cookie.secure</code></td><td><code>server.servlet.session.cookie.secure</code></td><td></td></tr><tr><td><code>server.session.persistent</code></td><td><code>server.servlet.session.persistent</code></td><td></td></tr><tr><td><code>server.session.store-dir</code></td><td><code>server.servlet.session.store-dir</code></td><td></td></tr><tr><td><code>server.session.timeout</code></td><td><code>server.servlet.session.timeout</code></td><td></td></tr><tr><td><code>server.session.tracking-modes</code></td><td><code>server.servlet.session.tracking-modes</code></td><td></td></tr><tr><td><code>spring.activemq.pool.configuration.block-if-session-pool-is-full</code></td><td></td><td></td></tr><tr><td><code>spring.activemq.pool.configuration.block-if-session-pool-is-full-timeout</code></td><td></td><td></td></tr><tr><td><code>spring.activemq.pool.configuration.connection-factory</code></td><td></td><td></td></tr><tr><td><code>spring.activemq.pool.configuration.create-connection-on-startup</code></td><td></td><td></td></tr><tr><td><code>spring.activemq.pool.configuration.expiry-timeout</code></td><td></td><td></td></tr><tr><td><code>spring.activemq.pool.configuration.idle-timeout</code></td><td></td><td></td></tr><tr><td><code>spring.activemq.pool.configuration.max-connections</code></td><td></td><td></td></tr><tr><td><code>spring.activemq.pool.configuration.maximum-active-session-per-connection</code></td><td></td><td></td></tr><tr><td><code>spring.activemq.pool.configuration.properties</code></td><td></td><td></td></tr><tr><td><code>spring.activemq.pool.configuration.reconnect-on-exception</code></td><td></td><td></td></tr><tr><td><code>spring.activemq.pool.configuration.time-between-expiration-check-millis</code></td><td></td><td></td></tr><tr><td><code>spring.activemq.pool.configuration.use-anonymous-producers</code></td><td></td><td></td></tr><tr><td><code>spring.application.index</code></td><td></td><td>应用程序上下文 ID 默认情况下是唯一的</td></tr><tr><td><code>spring.batch.initializer.enabled</code></td><td><code>spring.batch.initialize-schema</code></td><td></td></tr><tr><td><code>spring.cache.guava.spec</code></td><td></td><td>用于创建缓存的规范</td></tr><tr><td><code>spring.cache.hazelcast.config</code></td><td></td><td>用于初始化 Hazelcast 的配置文件的位置</td></tr><tr><td><code>spring.data.cassandra.connect-timeout-millis</code></td><td><code>spring.data.          cassandra.connect-timeout</code></td><td></td></tr><tr><td><code>spring.data.cassandra.read-timeout-millis</code></td><td><code>spring.data.cassandra.read-timeout</code></td><td></td></tr><tr><td><code>spring.data.cassandra.repositories.enabled</code></td><td><code>spring.data.cassandra.    repositories.type</code></td><td></td></tr><tr><td><code>spring.data.couchbase.repositories.enabled</code></td><td><code>spring.data.couchbase.    repositories.type</code></td><td></td></tr><tr><td><code>spring.data.mongodb.repositories.enabled</code></td><td><code>spring.data.mongodb.    repositories.type</code></td><td></td></tr><tr><td><code>spring.data.neo4j.compiler</code></td><td></td><td>从 Neo4j 3 开始不再支持</td></tr><tr><td><code>spring.datasource.dbcp.access-to-underlying-connection-allowed</code></td><td></td><td></td></tr><tr><td><code>spring.datasource.dbcp.connection-init-sqls</code></td><td></td><td></td></tr><tr><td><code>spring.datasource.dbcp.default-auto-commit</code></td><td></td><td></td></tr><tr><td><code>spring.datasource.dbcp.default-catalog</code></td><td></td><td></td></tr><tr><td><code>spring.datasource.dbcp.default-read-only</code></td><td></td><td></td></tr><tr><td><code>spring.datasource.dbcp.default-transaction-isolation</code></td><td></td><td></td></tr><tr><td><code>spring.datasource.dbcp.driver-class-name</code></td><td></td><td></td></tr><tr><td><code>spring.datasource.dbcp.initial-size</code></td><td></td><td></td></tr><tr><td><code>spring.datasource.dbcp.log-abandoned</code></td><td></td><td></td></tr><tr><td><code>spring.datasource.dbcp.login-timeout</code></td><td></td><td></td></tr><tr><td><code>spring.datasource.dbcp.max-active</code></td><td></td><td></td></tr><tr><td><code>spring.datasource.dbcp.max-idle</code></td><td></td><td></td></tr><tr><td><code>spring.datasource.dbcp.max-open-prepared-statements</code></td><td></td><td></td></tr><tr><td><code>spring.datasource.dbcp.max-wait</code></td><td></td><td></td></tr><tr><td><code>spring.datasource.dbcp.min-evictable-idle-time-millis</code></td><td></td><td></td></tr><tr><td><code>spring.datasource.dbcp.min-idle</code></td><td></td><td></td></tr><tr><td><code>spring.datasource.dbcp.num-tests-per-eviction-run</code></td><td></td><td></td></tr><tr><td><code>spring.datasource.dbcp.password</code></td><td></td><td></td></tr><tr><td><code>spring.datasource.dbcp.pool-prepared-statements</code></td><td></td><td></td></tr><tr><td><code>spring.datasource.dbcp.remove-abandoned</code></td><td></td><td></td></tr><tr><td><code>spring.datasource.dbcp.remove-abandoned-timeout</code></td><td></td><td></td></tr><tr><td><code>spring.datasource.dbcp.test-on-borrow</code></td><td></td><td></td></tr><tr><td><code>spring.datasource.dbcp.test-on-return</code></td><td></td><td></td></tr><tr><td><code>spring.datasource.dbcp.test-while-idle</code></td><td></td><td></td></tr><tr><td><code>spring.datasource.dbcp.time-between-eviction-runs-millis</code></td><td></td><td></td></tr><tr><td><code>spring.datasource.dbcp.url</code></td><td></td><td></td></tr><tr><td><code>spring.datasource.dbcp.username</code></td><td></td><td></td></tr><tr><td><code>spring.datasource.dbcp.validation-query</code></td><td></td><td></td></tr><tr><td><code>spring.datasource.dbcp.validation-query-timeout</code></td><td></td><td></td></tr><tr><td><code>spring.datasource.hikari.connection-customizer-class-name</code></td><td></td><td></td></tr><tr><td><code>spring.datasource.initialize</code></td><td><code>spring.datasource.       initialization-mode</code></td><td></td></tr><tr><td><code>spring.devtools.remote.debug.enabled</code></td><td></td><td>远程 debug 已不再支持</td></tr><tr><td><code>spring.devtools.remote.debug.local-port</code></td><td></td><td>远程 debug 已不再支持</td></tr><tr><td><code>spring.http.multipart.enabled</code></td><td><code>spring.servlet.multipart.enabled</code></td><td></td></tr><tr><td><code>spring.http.multipart.file-size-threshold</code></td><td><code>spring.servlet.multipart.file-size-threshold</code></td><td></td></tr><tr><td><code>spring.http.multipart.location</code></td><td><code>spring.servlet.multipart.location</code></td><td></td></tr><tr><td><code>spring.http.multipart.max-file-size</code></td><td><code>spring.servlet.multipart.max-file-size</code></td><td></td></tr><tr><td><code>spring.http.multipart.max-request-size</code></td><td><code>spring.servlet.           multipart.max-request-size</code></td><td></td></tr><tr><td><code>spring.http.multipart.resolve-lazily</code></td><td><code>spring.servlet.multipart.resolve-lazily</code></td><td></td></tr><tr><td><code>spring.jpa.hibernate.naming.strategy</code></td><td></td><td>Hibernate 4 的自动配置已不再提供</td></tr><tr><td><code>spring.jta.atomikos.properties.console-log-level</code></td><td><code>warn</code></td><td></td></tr><tr><td><code>spring.messages.cache-seconds</code></td><td><code>spring.messages.cache-duration</code></td><td></td></tr><tr><td><code>spring.metrics.export.aggregate.key-pattern</code></td><td></td><td>Metrics support 现在使用千分尺</td></tr><tr><td><code>spring.metrics.export.aggregate.prefix</code></td><td></td><td>Metrics support 现在使用千分尺</td></tr><tr><td><code>spring.metrics.export.delay-millis</code></td><td></td><td>Metrics support 现在使用千分尺</td></tr><tr><td><code>spring.metrics.export.enabled</code></td><td></td><td>Metrics support 现在使用千分尺</td></tr><tr><td><code>spring.metrics.export.excludes</code></td><td></td><td>Metrics support 现在使用千分尺</td></tr><tr><td><code>spring.metrics.export.includes</code></td><td></td><td>Metrics support 现在使用千分尺</td></tr><tr><td><code>spring.metrics.export.redis.key</code></td><td></td><td>Metrics support 现在使用千分尺</td></tr><tr><td><code>spring.metrics.export.redis.prefix</code></td><td></td><td>Metrics support 现在使用千分尺</td></tr><tr><td><code>spring.metrics.export.send-latest</code></td><td></td><td>Metrics support 现在使用千分尺</td></tr><tr><td><code>spring.metrics.export.statsd.host</code></td><td><code>management.metrics.    export.statsd.host</code></td><td></td></tr><tr><td><code>spring.metrics.export.statsd.port</code></td><td><code>management.metrics.   export.statsd.port</code></td><td></td></tr><tr><td><code>spring.metrics.export.statsd.prefix</code></td><td></td><td>Metrics support 现在使用千分尺</td></tr><tr><td><code>spring.metrics.export.triggers</code></td><td></td><td>Metrics support 现在使用千分尺</td></tr><tr><td><code>spring.mobile.devicedelegatingviewresolver.enable-fallback</code></td><td><code>false</code></td><td>启用对回退解决方案的支持</td></tr><tr><td><code>spring.mobile.devicedelegatingviewresolver.enabled</code></td><td><code>false</code></td><td>启用 device 视图解析器</td></tr><tr><td><code>spring.mobile.devicedelegatingviewresolver.mobile-prefix</code></td><td><code>mobile/</code></td><td>用于查看移动设备名称的前缀</td></tr><tr><td><code>spring.mobile.devicedelegatingviewresolver.mobile-suffix</code></td><td>``</td><td>附加后缀以查看移动设备的名称</td></tr><tr><td><code>spring.mobile.devicedelegatingviewresolver.normal-prefix</code></td><td>``</td><td>用于查看普通设备名称的前缀.</td></tr><tr><td><code>spring.mobile.devicedelegatingviewresolver.normal-suffix</code></td><td>``</td><td>附加后缀以查看普通设备的名称</td></tr><tr><td><code>spring.mobile.devicedelegatingviewresolver.tablet-prefix</code></td><td><code>tablet/</code></td><td>前缀预设为查看平板电脑设备的名称</td></tr><tr><td><code>spring.mobile.devicedelegatingviewresolver.tablet-suffix</code></td><td>``</td><td>附加后缀以查看平板电脑设备的名称</td></tr><tr><td><code>spring.mobile.sitepreference.enabled</code></td><td><code>true</code></td><td>启用 SitePreferenceHandler.</td></tr><tr><td><code>spring.mvc.media-types</code></td><td><code>spring.mvc.    contentnegotiation.media-types</code></td><td></td></tr><tr><td><code>spring.rabbitmq.listener.acknowledge-mode</code></td><td></td><td></td></tr><tr><td><code>spring.rabbitmq.listener.auto-startup</code></td><td></td><td></td></tr><tr><td><code>spring.rabbitmq.listener.concurrency</code></td><td></td><td></td></tr><tr><td><code>spring.rabbitmq.listener.default-requeue-rejected</code></td><td></td><td></td></tr><tr><td><code>spring.rabbitmq.listener.idle-event-interval</code></td><td></td><td></td></tr><tr><td><code>spring.rabbitmq.listener.max-concurrency</code></td><td></td><td></td></tr><tr><td><code>spring.rabbitmq.listener.prefetch</code></td><td></td><td></td></tr><tr><td><code>spring.rabbitmq.listener.retry.enabled</code></td><td><code>false</code></td><td>是否启用发布重试</td></tr><tr><td><code>spring.rabbitmq.listener.retry.initial-interval</code></td><td><code>1000</code></td><td>第一次和第二次尝试发布或传递讯息的时间间隔</td></tr><tr><td><code>spring.rabbitmq.listener.retry.max-attempts</code></td><td><code>3</code></td><td>尝试发布或传递邮件的最大次数</td></tr><tr><td><code>spring.rabbitmq.listener.retry.max-interval</code></td><td><code>10000</code></td><td>尝试之间的最大间隔</td></tr><tr><td><code>spring.rabbitmq.listener.retry.multiplier</code></td><td><code>1</code></td><td>于先前重试间隔的倍数</td></tr><tr><td><code>spring.rabbitmq.listener.retry.stateless</code></td><td><code>true</code></td><td>无论重试是无状态还是有状态</td></tr><tr><td><code>spring.rabbitmq.listener.transaction-size</code></td><td></td><td></td></tr><tr><td><code>spring.redis.pool.max-active</code></td><td><code>spring.redis.jedis.pool.max-idle</code></td><td></td></tr><tr><td><code>spring.redis.pool.max-idle</code></td><td><code>spring.redis.jedis.pool.max-idle</code></td><td></td></tr><tr><td><code>spring.redis.pool.max-wait</code></td><td><code>spring.redis.jedis.pool.max-wait</code></td><td></td></tr><tr><td><code>spring.redis.pool.min-idle</code></td><td><code>spring.redis.jedis.pool.min-idle</code></td><td></td></tr><tr><td><code>spring.resources.cache-period</code></td><td><code>spring.resources.cache.period</code></td><td></td></tr><tr><td><code>spring.sendgrid.password</code></td><td></td><td>不再支持使用用户名和密码 ( 使用 spring.sendgrid.api-key 代替 )</td></tr><tr><td><code>spring.sendgrid.username</code></td><td></td><td>不再支持使用用户名和密码 ( 使用 spring.sendgrid.api-key 代替 )</td></tr><tr><td><code>spring.session.jdbc.initializer.enabled</code></td><td><code>spring.session.         jdbc.initialize-schema</code></td><td></td></tr><tr><td><code>spring.session.mongo.collection-name</code></td><td><code>spring.session.mongodb.collection-name</code></td><td></td></tr><tr><td><code>spring.social.auto-connection-views</code></td><td><code>false</code></td><td>为支持的生产者启用连接状态视图</td></tr><tr><td><code>spring.social.facebook.app-id</code></td><td></td><td>Application id.</td></tr><tr><td><code>spring.social.facebook.app-secret</code></td><td></td><td>Application secret.</td></tr><tr><td><code>spring.social.linkedin.app-id</code></td><td></td><td>Application id.</td></tr><tr><td><code>spring.social.linkedin.app-secret</code></td><td></td><td>Application secret.</td></tr><tr><td><code>spring.social.twitter.app-id</code></td><td></td><td>Application id.</td></tr><tr><td><code>spring.social.twitter.app-secret</code></td><td></td><td>Application secret.</td></tr><tr><td><code>spring.thymeleaf.content-type</code></td><td><code>spring.thymeleaf.      servlet.content-type</code></td></tr></tbody></table><h3 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h3><h3 id="相关文章-1"><a href="#相关文章-1" class="headerlink" title="相关文章"></a>相关文章</h3><p>1、<a href="http://www.54tianzhisheng.cn/2018/03/06/SpringBoot2-Migration-Guide/" target="_blank" rel="noopener">Spring Boot 2.0系列文章(一)：Spring Boot 2.0 迁移指南</a></p><p>2、<a href="http://www.54tianzhisheng.cn/2018/03/06/SpringBoot2-new-features/" target="_blank" rel="noopener">Spring Boot 2.0系列文章(二)：Spring Boot 2.0 新特性详解</a></p><p>3、<a href="http://www.54tianzhisheng.cn/2018/04/13/Spring_Boot_2.0_Configuration_Changelog/" target="_blank" rel="noopener">Spring Boot 2.0系列文章(三)：Spring Boot 2.0 配置改变</a></p><p>4、<a href="http://www.54tianzhisheng.cn/2018/04/15/springboot2_code/" target="_blank" rel="noopener">Spring Boot 2.0系列文章(四)：Spring Boot 2.0 源码阅读环境搭建</a></p><p>5、<a href="http://www.54tianzhisheng.cn/2018/04/18/spring_boot2_project/" target="_blank" rel="noopener">Spring Boot 2.0系列文章(五)：Spring Boot 2.0 项目源码结构预览</a></p><p>6、<a href="http://www.54tianzhisheng.cn/2018/04/19/SpringBootApplication-annotation/" target="_blank" rel="noopener">Spring Boot 2.0系列文章(六)：Spring boot 2.0 中 SpringBootApplication 注解详解</a></p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>英文参考：<a href="">https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-2.0-Configuration-Changelog</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://ws2.sinaimg.cn/large/006tKfTcgy1fqc4n57tj4j31hc0zktmm.jpg&quot; alt=&quot;pocket-watch-3156771_1920&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="SpringBoot" scheme="http://yoursite.com/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>写这么多系列博客，怪不得找不到女朋友</title>
    <link href="http://yoursite.com/2018/03/27/blogs/"/>
    <id>http://yoursite.com/2018/03/27/blogs/</id>
    <published>2018-03-26T16:00:00.000Z</published>
    <updated>2018-03-27T15:18:02.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fprrv5n1p2j31hc0u0tm6.jpg" alt="nature-3054445_1920"></p><h3 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h3><p>好几周没更新博客了，对不断支持我博客的童鞋们说声：“抱歉了！”。自己这段时间确实比较忙，而且还在抽空完成学校的毕业设计。今天晚上抽空把大学期间写过的博客弄一个系列文章合集，算是对大学这四年的一个总结，证明自己没白过。</p><a id="more"></a><p>熟悉我的人都知道我写博客的时间比较早，而且坚持的时间也比较久，一直到现在也是一直保持着更新状态。最早最早开始写博客是在 CSDN 上写的，然后在简书也写过一段时间，后来放弃了简书转战了掘金，以下图片是自己在掘金这一年的成果，快 <strong>1.5 万</strong>关注了，哈哈哈。</p><p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1fprrv4ovhqj31kw0iaadw.jpg" alt="21"></p><p>去年过年前还收到掘金送来的专属礼物，真是激动，感谢掘金，希望越办越好！</p><p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1fprrv2qhutj31kw23vu0x.jpg" alt="IMG_20180206_125142"></p><p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1fprrv7e4wvj31kw23vb29.jpg" alt="IMG_20180206_125159"></p><p>细数文章后，发现自己在实习的这段时间写的博客也挺多的，而且质量还比较高，经常上开发者头条、掘金等平台的首页推荐。在此，感谢实习期间组内大佬们的各种帮助！</p><p>这里再次说下写博客的好处：</p><ul><li>很好的用来总结自己所学的知识</li><li>遇到那么一群也写博客的大佬，有共同话题聊了</li><li>面试加分（在简历上放上自己的个人网站链接，面试官就可以更好的了解你，知道你所学知识的深度和广度）</li></ul><p>不要小看你的每一篇不起眼博客，用一个蚂蚁金服大佬跟我说的话叫做：<strong>厚积薄发</strong>！</p><p>不多说了，如果想和我交流的可以加我 qq 群：<strong>528776268</strong>    和我的微信：<strong>zhisheng_tian</strong></p><h3 id="关注我"><a href="#关注我" class="headerlink" title="关注我"></a>关注我</h3><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180103/C6LG3mGa12.jpg" alt="mark"></p><p>转载请务必注明原创地址为：<a href="http://www.54tianzhisheng.cn/2018/03/27/blogs/" target="_blank" rel="noopener">http://www.54tianzhisheng.cn/2018/03/27/blogs/</a></p><h3 id="系列文章合集"><a href="#系列文章合集" class="headerlink" title="系列文章合集"></a>系列文章合集</h3><h4 id="Spring-Boot-系列文章"><a href="#Spring-Boot-系列文章" class="headerlink" title="Spring Boot 系列文章"></a><strong>Spring Boot 系列文章</strong></h4><p>1、<a href="http://www.54tianzhisheng.cn/2018/01/05/SpringBoot-Kafka/" target="_blank" rel="noopener">Spring Boot系列文章（一）：SpringBoot Kafka 整合使用</a></p><p>2、<a href="http://www.54tianzhisheng.cn/2018/01/17/SpringBoot-Admin/" target="_blank" rel="noopener">Spring Boot系列文章（二）：SpringBoot Admin 使用指南</a></p><p>3、<a href="http://www.54tianzhisheng.cn/2018/01/26/SpringBoot-RabbitMQ/" target="_blank" rel="noopener">Spring Boot系列文章（三）：SpringBoot RabbitMQ 整合使用</a></p><p>4、<a href="http://www.54tianzhisheng.cn/2018/01/27/SpringBoot-ActiveMQ/" target="_blank" rel="noopener">Spring Boot系列文章（四）：SpringBoot ActiveMQ 整合使用</a></p><p>5、<a href="http://www.54tianzhisheng.cn/2018/01/28/RabbitMQ/" target="_blank" rel="noopener">Spring Boot系列文章（五）：SpringBoot RabbitMQ 整合进阶版</a></p><p>6、<a href="http://www.54tianzhisheng.cn/2018/02/07/SpringBoot-RocketMQ/" target="_blank" rel="noopener">Spring Boot系列文章（六）：SpringBoot RocketMQ 整合使用和监控</a></p><p>7、更多请期待</p><h4 id="Spring-Boot-2-0-系列文章"><a href="#Spring-Boot-2-0-系列文章" class="headerlink" title="Spring Boot 2.0 系列文章"></a><strong>Spring Boot 2.0 系列文章</strong></h4><p>1、<a href="http://www.54tianzhisheng.cn/2018/03/06/SpringBoot2-Migration-Guide/" target="_blank" rel="noopener">Spring Boot 2.0系列文章(一)：Spring Boot 2.0 迁移指南</a></p><p>2、<a href="http://www.54tianzhisheng.cn/2018/03/06/SpringBoot2-new-features/" target="_blank" rel="noopener">Spring Boot 2.0系列文章(二)：Spring Boot 2.0 新特性详解</a></p><p>3、后面绝对有更多文章出现的</p><h4 id="Docker-系列文章"><a href="#Docker-系列文章" class="headerlink" title="Docker 系列文章"></a><strong>Docker 系列文章</strong></h4><p>1、<a href="http://www.54tianzhisheng.cn/2017/11/26/Docker-harbor/" target="_blank" rel="noopener">Docker系列文章（一）：基于 Harbor 搭建 Docker 私有镜像仓库</a></p><p>2、<a href="http://www.54tianzhisheng.cn/2018/01/25/Docker-install/" target="_blank" rel="noopener">Docker系列文章（二）：Mac 安装 Docker 及常用命令</a></p><p>3、同样，后面也会持续更新</p><h4 id="ElasticSearch-系列文章"><a href="#ElasticSearch-系列文章" class="headerlink" title="ElasticSearch 系列文章"></a><strong>ElasticSearch 系列文章</strong></h4><p>1、<a href="http://www.54tianzhisheng.cn/2017/09/08/Elasticsearch-analyzers/" target="_blank" rel="noopener">Elasticsearch 系列文章（一）：Elasticsearch 默认分词器和中分分词器之间的比较及使用方法</a></p><p>2、 <a href="http://www.54tianzhisheng.cn/2017/09/09/Elasticsearch-install/" target="_blank" rel="noopener">Elasticsearch 系列文章（二）：全文搜索引擎 Elasticsearch 集群搭建入门教程</a></p><p>3、<a href="http://www.54tianzhisheng.cn/2017/10/15/ElasticSearch-cluster-health-metrics/" target="_blank" rel="noopener">Elasticsearch 系列文章（三）：ElasticSearch 集群监控</a></p><p>4、<a href="http://www.54tianzhisheng.cn/2017/10/18/ElasticSearch-nodes-metrics/" target="_blank" rel="noopener">Elasticsearch 系列文章（四）：ElasticSearch 单个节点监控</a></p><p>5、<a href="http://www.54tianzhisheng.cn/2017/12/25/ELK/" target="_blank" rel="noopener">Elasticsearch 系列文章（五）：ELK 实时日志分析平台环境搭建</a></p><p>6、也有更多深入的文章</p><h4 id="搭建博客系列文章"><a href="#搭建博客系列文章" class="headerlink" title="搭建博客系列文章"></a><strong>搭建博客系列文章</strong></h4><p>1、<a href="http://www.54tianzhisheng.cn/2017/03/28/%E5%88%A9%E7%94%A8Github%20Page%20%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/" target="_blank" rel="noopener">利用Github Page 搭建个人博客网站</a></p><p>2、<a href="http://www.54tianzhisheng.cn/2017/04/13/Hexo-yilia-changyan/" target="_blank" rel="noopener">Github pages + Hexo 博客 yilia 主题使用畅言评论系统</a></p><p>3、<a href="http://www.54tianzhisheng.cn/2017/12/18/hexo-yilia/" target="_blank" rel="noopener">Hexo + yilia 搭建博客可能会遇到的所有疑问</a></p><p>4、<a href="http://www.54tianzhisheng.cn/2017/06/13/Hexo-yilia-toc/" target="_blank" rel="noopener">Hexo + yilia 主题实现文章目录</a></p><p>5、这个系列看情况，可能还会有</p><h4 id="Java-系列文章"><a href="#Java-系列文章" class="headerlink" title="Java 系列文章"></a><strong>Java 系列文章</strong></h4><p>1、<a href="http://www.54tianzhisheng.cn/2017/06/13/String-new/" target="_blank" rel="noopener">关于String s = new String(“xyz”); 创建几个对象的问题</a></p><p>2、<a href="http://www.54tianzhisheng.cn/2017/06/13/Java-Thread/" target="_blank" rel="noopener">《Java 多线程编程核心技术》学习笔记及总结</a></p><p>3、<a href="http://www.54tianzhisheng.cn/2017/06/13/java-var/" target="_blank" rel="noopener">从对象深入分析 Java 中实例变量和类变量的区别</a></p><p>4、<a href="http://www.54tianzhisheng.cn/2017/06/13/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%A9%B6Java%20%E4%B8%AD%20finally%20%E8%AF%AD%E5%8F%A5%E5%9D%97/" target="_blank" rel="noopener">深度探究Java 中 finally 语句块</a></p><p>5、<a href="http://www.54tianzhisheng.cn/2017/06/13/%E8%A7%A3%E5%86%B3jdk1.8%E4%B8%AD%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6%E5%A4%B1%E8%B4%A5%EF%BC%88handshake_failure%EF%BC%89%E9%97%AE%E9%A2%98/" target="_blank" rel="noopener">解决jdk1.8中发送邮件失败（handshake_failure）问题</a></p><p>6、<a href="http://www.54tianzhisheng.cn/2017/06/13/%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90%20Java%20Web%20%E4%B8%AD%E7%9A%84%E4%B8%AD%E6%96%87%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98/" target="_blank" rel="noopener">深入分析 Java Web 中的中文编码问题</a></p><p>7、<a href="http://www.54tianzhisheng.cn/2017/06/13/%E5%A5%87%E6%80%AA%E7%9A%84Java%E9%A2%98%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88128%20==%20128%E8%BF%94%E5%9B%9E%E4%B8%BAFalse%EF%BC%8C%E8%80%8C127%20==%20127%E4%BC%9A%E8%BF%94%E5%9B%9E%E4%B8%BATrue-/" target="_blank" rel="noopener">奇怪的Java题：为什么128 == 128返回为False，而127 == 127会返回为True?</a></p><p>8、<a href="http://www.54tianzhisheng.cn/2017/06/13/java%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6/" target="_blank" rel="noopener">Java读取文件</a></p><p>9、<a href="http://www.54tianzhisheng.cn/2017/06/13/HashMap-Hashtable/" target="_blank" rel="noopener">HashMap、Hashtable、HashSet 和 ConcurrentHashMap 的比较</a></p><p>10、<a href="http://www.54tianzhisheng.cn/2017/06/13/Java%E8%BF%9E%E6%8E%A5Oracle%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%89%E7%A7%8D%E8%BF%9E%E6%8E%A5%E6%96%B9%E5%BC%8F/" target="_blank" rel="noopener">Java连接Oracle数据库的三种连接方式</a></p><p>11、<a href="http://www.54tianzhisheng.cn/2017/06/13/Java%20NIO%20%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/" target="_blank" rel="noopener">Java NIO 系列教程</a></p><p>12、<a href="http://www.54tianzhisheng.cn/2017/06/13/Java-16-lession/" target="_blank" rel="noopener">《疯狂 Java 突破程序员基本功的 16 课》读书笔记</a></p><p>13、<a href="http://www.54tianzhisheng.cn/2017/06/17/%E8%AF%A6%E7%BB%86%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90%20Java%20ClassLoader%20%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6/" target="_blank" rel="noopener">详细深入分析 Java ClassLoader 工作机制</a></p><p>14、<a href="http://www.54tianzhisheng.cn/2017/06/17/%E8%AF%A6%E8%A7%A3%20Filter%20%E8%BF%87%E6%BB%A4%E5%99%A8/" target="_blank" rel="noopener">详解 Filter 过滤器</a></p><p>15、<a href="http://www.54tianzhisheng.cn/2017/06/23/java-io/" target="_blank" rel="noopener">Java IO流学习超详细总结（图文并茂）</a></p><p>16、<a href="http://www.54tianzhisheng.cn/2017/07/09/servlet/" target="_blank" rel="noopener">通过源码详解 Servlet</a></p><p>17、<a href="http://www.54tianzhisheng.cn/2017/07/25/Java-performance-tuning/" target="_blank" rel="noopener">Java 性能调优需要格外注意的细节</a></p><p>18、<a href="http://www.54tianzhisheng.cn/2017/07/29/ThreadPool/" target="_blank" rel="noopener">Java 线程池艺术探索</a></p><p>19、<a href="http://www.54tianzhisheng.cn/2017/06/13/JVM%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E7%9B%91%E6%8E%A7%E5%B7%A5%E5%85%B7jps%E3%80%81jstack%E3%80%81jmap%E3%80%81jhat%E3%80%81jstat%E7%AD%89%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/" target="_blank" rel="noopener">JVM性能调优监控工具jps、jstack、jmap、jhat、jstat等使用详解</a></p><p>20、这个必须的持续更新下去</p><h4 id="Maven-系列文章"><a href="#Maven-系列文章" class="headerlink" title="Maven  系列文章"></a><strong>Maven  系列文章</strong></h4><p>1、<a href="http://www.54tianzhisheng.cn/2017/10/14/Nexus3-Maven/" target="_blank" rel="noopener">Centos7 搭建最新 Nexus3 Maven 私服</a></p><p>2、<a href="http://www.54tianzhisheng.cn/2017/11/11/Maven-dependencies-dependencyManagement/" target="_blank" rel="noopener">Maven 中 dependencies 与 dependencyManagement 的区别</a></p><h4 id="Kafka-系列文章"><a href="#Kafka-系列文章" class="headerlink" title="Kafka 系列文章"></a><strong>Kafka 系列文章</strong></h4><p>1、<a href="http://www.54tianzhisheng.cn/2018/01/04/Kafka/" target="_blank" rel="noopener">Kafka 安装及快速入门</a></p><p>2、<a href="http://www.54tianzhisheng.cn/2018/01/05/SpringBoot-Kafka/" target="_blank" rel="noopener">Spring Boot系列文章（一）：SpringBoot Kafka 整合使用</a></p><h4 id="Mybatis-系列文章"><a href="#Mybatis-系列文章" class="headerlink" title="Mybatis 系列文章"></a><strong>Mybatis 系列文章</strong></h4><p>1、<a href="http://blog.csdn.net/tzs_1041218129/article/details/53404326" target="_blank" rel="noopener">通过项目逐步深入了解Mybatis&lt;一&gt;</a></p><p>2、<a href="http://blog.csdn.net/tzs_1041218129/article/details/53449052" target="_blank" rel="noopener">通过项目逐步深入了解Mybatis&lt;二&gt;</a></p><p>3、<a href="http://blog.csdn.net/tzs_1041218129/article/details/53456677" target="_blank" rel="noopener">通过项目逐步深入了解Mybatis&lt;三&gt;</a></p><p>4、<a href="http://www.54tianzhisheng.cn/2017/06/15/%E9%80%9A%E8%BF%87%E9%A1%B9%E7%9B%AE%E9%80%90%E6%AD%A5%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3Mybatis(%E5%9B%9B" target="_blank" rel="noopener">通过项目逐步深入了解Mybatis（四)</a>/)</p><p>5、<a href="http://www.54tianzhisheng.cn/2017/06/13/MyBatis-foreach/" target="_blank" rel="noopener">MyBatis的foreach语句详解</a></p><p>6、期待它的源码解析文章吗？</p><h4 id="Nginx-系列文章"><a href="#Nginx-系列文章" class="headerlink" title="Nginx 系列文章"></a><strong>Nginx 系列文章</strong></h4><p>1、<a href="http://www.54tianzhisheng.cn/2017/08/18/Ubuntu-install-Nginx/" target="_blank" rel="noopener">Ubuntu16.10 安装 Nginx</a></p><p>2、<a href="http://www.54tianzhisheng.cn/2017/08/05/Nginx/" target="_blank" rel="noopener">Nginx 基本知识快速入门</a></p><h4 id="Python-爬虫系列文章"><a href="#Python-爬虫系列文章" class="headerlink" title="Python 爬虫系列文章"></a><strong>Python 爬虫系列文章</strong></h4><p>1、<a href="http://www.54tianzhisheng.cn/2017/06/13/Python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E7%88%AC%E5%8F%96%E7%99%BE%E5%BA%A6%E8%B4%B4%E5%90%A7%E5%B8%96%E5%AD%90/" target="_blank" rel="noopener">Python爬虫实战之爬取百度贴吧帖子</a></p><p>2、<a href="http://www.54tianzhisheng.cn/2017/06/13/Pyspider%E6%A1%86%E6%9E%B6%20%E2%80%94%E2%80%94%20Python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E7%88%AC%E5%8F%96%20V2EX%20%E7%BD%91%E7%AB%99%E5%B8%96%E5%AD%90/" target="_blank" rel="noopener">Pyspider框架 —— Python爬虫实战之爬取 V2EX 网站帖子</a></p><p>3、<a href="http://www.54tianzhisheng.cn/2017/06/13/Python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E7%88%AC%E5%8F%96%E7%B3%97%E4%BA%8B%E7%99%BE%E7%A7%91%E6%AE%B5%E5%AD%90/" target="_blank" rel="noopener">Python爬虫实战之爬取糗事百科段子</a></p><p>4、这个估计得等有机会再次学 Python 时再写</p><h4 id="RocketMQ-系列文章"><a href="#RocketMQ-系列文章" class="headerlink" title="RocketMQ 系列文章"></a><strong>RocketMQ 系列文章</strong></h4><p>1、<a href="http://www.54tianzhisheng.cn/2018/02/05/RocketMQ/" target="_blank" rel="noopener">RocketMQ系列文章（一）：RocketMQ 初探</a></p><p>2、<a href="http://www.54tianzhisheng.cn/2018/02/06/RocketMQ-install/" target="_blank" rel="noopener">RocketMQ系列文章（二）：RocketMQ 安装及快速入门</a></p><p>3、<a href="http://www.54tianzhisheng.cn/2018/02/07/rocketmq-example/" target="_blank" rel="noopener">RocketMQ系列文章（三）：RocketMQ 简单的消息示例</a></p><p>4、<a href="http://www.54tianzhisheng.cn/2018/02/07/SpringBoot-RocketMQ/" target="_blank" rel="noopener">Spring Boot系列文章（六）：SpringBoot RocketMQ 整合使用和监控</a></p><h4 id="Spring-MVC-系列文章"><a href="#Spring-MVC-系列文章" class="headerlink" title="Spring MVC 系列文章"></a><strong>Spring MVC 系列文章</strong></h4><p>1、<a href="http://www.54tianzhisheng.cn/2017/06/13/Spring%20MVC%20+%20Hibernate%20JPA%20+%20Bootstrap%20%E6%90%AD%E5%BB%BA%E7%9A%84%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/" target="_blank" rel="noopener">Spring MVC系列文章（一）：Spring MVC + Hibernate JPA + Bootstrap 搭建的博客系统 Demo</a></p><p>2、<a href="http://www.54tianzhisheng.cn/2017/06/13/Spring%20MVC+Hibernate%20JPA%E6%90%AD%E5%BB%BA%E7%9A%84%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE%E4%B8%AD%E6%89%80%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91/" target="_blank" rel="noopener">Spring MVC系列文章（二）：Spring MVC+Hibernate JPA搭建的博客系统项目中所遇到的坑</a></p><p>3、<a href="http://www.54tianzhisheng.cn/2017/07/14/Spring-MVC01/" target="_blank" rel="noopener">Spring MVC系列文章（三）：看透 Spring MVC 源代码分析与实践 —— 网站基础知识</a></p><p>4、<a href="http://www.54tianzhisheng.cn/2017/07/14/Spring-MVC02/" target="_blank" rel="noopener">Spring MVC系列文章（四）：看透 Spring MVC 源代码分析与实践 —— 俯视 Spring MVC</a></p><p>5、<a href="http://www.54tianzhisheng.cn/2017/07/21/Spring-MVC03/" target="_blank" rel="noopener">Spring MVC系列文章（五）：看透 Spring MVC 源代码分析与实践 —— Spring MVC 组件分析</a></p><p>6、<a href="http://www.54tianzhisheng.cn/2017/06/16/%E9%80%9A%E8%BF%87%E9%A1%B9%E7%9B%AE%E9%80%90%E6%AD%A5%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3Spring%20MVC%EF%BC%88%E4%B8%80%EF%BC%89/" target="_blank" rel="noopener">通过项目逐步深入了解Spring MVC（一）</a></p><h4 id="Netty-系列文章"><a href="#Netty-系列文章" class="headerlink" title="Netty 系列文章"></a><strong>Netty 系列文章</strong></h4><p>1、<a href="http://www.54tianzhisheng.cn/2017/12/08/netty-01-env/" target="_blank" rel="noopener">Netty系列文章（一）：Netty 源码阅读之初始环境搭建</a></p><p>2、这个系列迟早会更新的。</p><h4 id="前端系列文章"><a href="#前端系列文章" class="headerlink" title="前端系列文章"></a><strong>前端系列文章</strong></h4><p>1、<a href="http://www.54tianzhisheng.cn/2017/06/18/Bootstrap%E5%85%A5%E9%97%A8%E9%9C%80%E6%8E%8C%E6%8F%A1%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%88%E4%B8%80%EF%BC%89/" target="_blank" rel="noopener">Bootstrap入门需掌握的知识点（一）</a></p><p>2、<a href="http://www.54tianzhisheng.cn/2017/06/18/Bootstrap%E5%85%A5%E9%97%A8%E9%9C%80%E6%8E%8C%E6%8F%A1%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%88%E4%BA%8C%EF%BC%89/" target="_blank" rel="noopener">Bootstrap入门需掌握的知识点（二）</a></p><p>3、<a href="http://www.54tianzhisheng.cn/2017/12/09/CodeMirror/" target="_blank" rel="noopener">使用 CodeMirror 打造属于自己的在线代码编辑器</a></p><p>4、<a href="http://www.54tianzhisheng.cn/2017/06/23/AJAX/" target="_blank" rel="noopener">AJAX 学习</a></p><p>5、前端渣渣这个也要慢慢学习这块</p><h4 id="面试经验系列"><a href="#面试经验系列" class="headerlink" title="面试经验系列"></a><strong>面试经验系列</strong></h4><p>1、<a href="http://www.54tianzhisheng.cn/2017/08/04/yaxin/" target="_blank" rel="noopener">秋招第一站 —— 亚信科技</a></p><p>2、<a href="http://www.54tianzhisheng.cn/2017/08/04/iqiyi/" target="_blank" rel="noopener">秋招第二站 —— 内推爱奇艺（一面二面）</a></p><p>3、<a href="http://www.54tianzhisheng.cn/2017/08/04/alibaba/" target="_blank" rel="noopener">秋招第三站 —— 内推阿里（一面）</a></p><p>4、 <a href="http://www.54tianzhisheng.cn/2017/09/17/Interview-summary/" target="_blank" rel="noopener">面试过阿里等互联网大公司，我知道了这些套路</a></p><p>5、<a href="http://www.54tianzhisheng.cn/2017/08/28/recommend-books/" target="_blank" rel="noopener">那些年我看过的书 —— 致敬我的大学生活 —— Say Good Bye ！</a></p><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a><strong>其他</strong></h4><p>还有一些其他方面的技术文章，算不是系列文章，比较零散，还有就是一些随笔文章，就不把它们放在合集里了。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>用自己的一句话：<strong>坑要一个个填，路要一步步走！前人栽树，后人乘凉，学会感恩！</strong></p><p>建了个不错的微信群，如果有感兴趣的可以加我微信，对我回复  <strong>加群</strong> ，然后会拉你进群交流。</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fp0t1jn6s4j30qi0z10x1.jpg" alt="1520091522031"></p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fp3jkmizmpj30o00didgn.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://ws2.sinaimg.cn/large/006tKfTcgy1fprrv5n1p2j31hc0u0tm6.jpg&quot; alt=&quot;nature-3054445_1920&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;前提&quot;&gt;&lt;a href=&quot;#前提&quot; class=&quot;headerlink&quot; title=&quot;前提&quot;&gt;&lt;/a&gt;前提&lt;/h3&gt;&lt;p&gt;好几周没更新博客了，对不断支持我博客的童鞋们说声：“抱歉了！”。自己这段时间确实比较忙，而且还在抽空完成学校的毕业设计。今天晚上抽空把大学期间写过的博客弄一个系列文章合集，算是对大学这四年的一个总结，证明自己没白过。&lt;/p&gt;
    
    </summary>
    
    
      <category term="博客合集" scheme="http://yoursite.com/tags/%E5%8D%9A%E5%AE%A2%E5%90%88%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot 2.0系列文章(一)：Spring Boot 2.0 迁移指南</title>
    <link href="http://yoursite.com/2018/03/06/SpringBoot2-Migration-Guide/"/>
    <id>http://yoursite.com/2018/03/06/SpringBoot2-Migration-Guide/</id>
    <published>2018-03-05T16:00:00.000Z</published>
    <updated>2018-05-02T13:29:08.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fp3h0820m2j31hc0zkwxr.jpg" alt=""></p><h3 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h3><p>希望本文档将帮助您把应用程序迁移到 Spring Boot 2.0。</p><a id="more"></a><h3 id="关注我"><a href="#关注我" class="headerlink" title="关注我"></a>关注我</h3><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180103/C6LG3mGa12.jpg" alt="mark"></p><p>转载请务必注明原创地址为：<a href="http://www.54tianzhisheng.cn/2018/03/06/SpringBoot2-Migration-Guide/" target="_blank" rel="noopener">http://www.54tianzhisheng.cn/2018/03/06/SpringBoot2-Migration-Guide/</a></p><h3 id="在你开始之前"><a href="#在你开始之前" class="headerlink" title="在你开始之前"></a>在你开始之前</h3><p>首先，<strong>Spring Boot 2.0 需要 Java 8 或更高版本</strong>。不再支持 Java 6 和 7 了。</p><p>在 Spring Boot 2.0 中，许多配置属性被重新命名/删除，开发人员需要更新<code>application.properties</code>/ <code>application.yml</code>相应的配置。为了帮助你解决这一问题，Spring Boot 发布了一个新<code>spring-boot-properties-migrator</code>模块。一旦作为该模块作为依赖被添加到你的项目中，它不仅会分析应用程序的环境，而且还会在启动时打印诊断信息，而且还会在运行时为您暂时迁移属性。在您的应用程序迁移期间，这个模块是必备的：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-properties-migrator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意：完成迁移后，请确保从项目的依赖关系中删除此模块。</p><h3 id="构建您的-Spring-Boot-应用程序"><a href="#构建您的-Spring-Boot-应用程序" class="headerlink" title="构建您的 Spring Boot 应用程序"></a>构建您的 Spring Boot 应用程序</h3><h4 id="Spring-Boot-Maven-插件"><a href="#Spring-Boot-Maven-插件" class="headerlink" title="Spring Boot Maven 插件"></a>Spring Boot Maven 插件</h4><p>为了保持了一致性，并且避免与其他插件发生冲突，现在暴露的插件配置属性都以一个<code>spring-boot</code>前缀开始。</p><p>例如，以下命令<code>prod</code>使用命令行启用配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn spring-boot:run -Dspring-boot.run.profiles=prod</span><br></pre></td></tr></table></figure><h5 id="Surefire-默认值"><a href="#Surefire-默认值" class="headerlink" title="Surefire 默认值"></a>Surefire 默认值</h5><p>以前的 <code>include/exclude</code> 模式已与最新的 Surefire 默认设置保持一致。如果依赖于此插件，需要相应地更新插件配置。之前对应的配置如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-surefire-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*Tests.java<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*Test.java<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">excludes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exclude</span>&gt;</span>**/Abstract*.java<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">excludes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure><p>PS: 如果您使用 JUnit 5，则应将 Surefire 降级到 <code>2.19.1</code>。该<code>**/*Tests.java</code>版本不包含此模式，因此如果您依赖该模式，请确保将其添加到您的配置中。</p><h4 id="Spring-Boot-Gradle-插件"><a href="#Spring-Boot-Gradle-插件" class="headerlink" title="Spring Boot Gradle 插件"></a>Spring Boot Gradle 插件</h4><p>Spring Boot 的 Gradle 插件在很大程度上已被重写，有了重大的改进。您可以在其<a href="https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/gradle-plugin/reference" target="_blank" rel="noopener">参考文献</a>和<a href="https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/gradle-plugin/api" target="_blank" rel="noopener">API</a>文档中阅读关于插件功能的更多信息。</p><h5 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h5><p>Spring Boot 的 Gradle 插件不再自动应用依赖管理插件。相反，Spring Boot 的插件现在可以通过导入正确版本的spring-boot-dependencies BOM 来应用依赖管理插件。当依赖管理被配置的时候，这一点会让你有更多的控制权。</p><p>对于大多数应用程序，使用应用依赖管理插件就足够了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: &apos;org.springframework.boot&apos;</span><br><span class="line">apply plugin: &apos;io.spring.dependency-management&apos; // &lt;-- add this to your build.gradle</span><br></pre></td></tr></table></figure><p>注意：依赖管理插件仍然是 spring-boot-gradle-plugin 的传递依赖项，所以不需要在 buildscript 配置中将其列为类路径依赖项。</p><h5 id="建立可执行的-Jars-和-Wars"><a href="#建立可执行的-Jars-和-Wars" class="headerlink" title="建立可执行的 Jars 和 Wars"></a>建立可执行的 Jars 和 Wars</h5><p> <code>bootRepackage</code> 任务已经被替换成 <code>bootJar</code> 和 <code>bootWar</code> 任务，分别用于构建可执行的 <code>jar</code> 包和 <code>war</code>包。</p><h5 id="配置更新"><a href="#配置更新" class="headerlink" title="配置更新"></a>配置更新</h5><p><code>BootRun</code>，<code>BootJar</code>和<code>BootWar</code>任务现在都使用<code>mainClassName</code>的属性来配置主类的名称。这使得三个特定于引导的任务相互一致，并将其与 Gradle 自己的应用程序插件进行对齐。</p><h3 id="Spring-Boot-特性"><a href="#Spring-Boot-特性" class="headerlink" title="Spring Boot 特性"></a>Spring Boot 特性</h3><h4 id="默认动态代理策略"><a href="#默认动态代理策略" class="headerlink" title="默认动态代理策略"></a>默认动态代理策略</h4><p>Spring Boot 默认使用 CGLIB 做动态代理代理(基于类的动态代理)，包括对 AOP 的支持。如果你需要基于接口的动态代理，你需要将<code>spring.aop.proxy-target-class</code> 设置为<code>false</code>。</p><h4 id="SpringApplication"><a href="#SpringApplication" class="headerlink" title="SpringApplication"></a>SpringApplication</h4><h5 id="Web-环境"><a href="#Web-环境" class="headerlink" title="Web 环境"></a>Web 环境</h5><p>Spring Boot 应用程序现在可以在更多模式下运行，因此<code>spring.main.web-environment</code>现在不推荐使用，<code>spring.main.web-application-type</code>属性可以提供更多的支持。</p><p>如果您想确保应用程序不启动 Web 服务器，则必须将该属性更改为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.main.web-application-type=none</span><br></pre></td></tr></table></figure><p>注意：可以通过  <code>SpringApplication</code> 的 <code>setWebApplicationType</code> 方法实现。</p><h5 id="Spring-Boot-应用程序事件更改"><a href="#Spring-Boot-应用程序事件更改" class="headerlink" title="Spring Boot 应用程序事件更改"></a>Spring Boot 应用程序事件更改</h5><p>我们已经添加了一个新事件<code>ApplicationStartedEvent</code>。 <code>ApplicationStartedEvent</code>在上下文刷新之后但在任何应用程序和命令行参数被调用之前发送。 <code>ApplicationReadyEvent</code>在任何应用程序和命令行参数被调用后发送。它表示应用程序已准备好为请求提供服务。</p><p>请参阅<a href="https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#boot-features-application-events-and-listeners" target="_blank" rel="noopener">更新的参考文档</a>。</p><h5 id="Banner"><a href="#Banner" class="headerlink" title="Banner"></a>Banner</h5><p>在我们限制 Spring Boot 使用的根名称空间的数量的过程中，与标志相关的属性已被重定位到<code>spring.banner</code>。</p><h4 id="外部化配置"><a href="#外部化配置" class="headerlink" title="外部化配置"></a>外部化配置</h4><h5 id="轻松的绑定"><a href="#轻松的绑定" class="headerlink" title="轻松的绑定"></a>轻松的绑定</h5><p>有关宽松绑定的规则已经收紧。我们假设一个现有的<code>acme.my-project.my-name</code>属性：</p><ol><li>所有前缀必须是 kebab格式（小写，连字符分隔）<code>acme.myProject</code>或<code>acme.my_project</code>无效 - 您必须<code>acme.my-project</code>在此处使用。</li><li>属性名称可以使用 kebab-case（<code>my-name</code>），camel-case（<code>myName</code>）或 snake-case（<code>my_name</code>）。</li><li>环境属性（来自操作系统环境变量）<em>必须使用</em>通常的大写下划线格式，下划线<em>只能</em>用于分隔键的各个部分<code>ACME_MYPROJECT_MYNAME</code>。</li></ol><p>这种新的放松绑定具有以下几个优点：</p><ul><li>无需担心密钥的结构<code>@ConditionalOnProperty</code>：只要密钥是以规范格式定义的，支持的松散变体就可以透明地工作。如果您正在使用该<code>prefix</code>属性，则现在只需使用<code>name</code>或<code>value</code>属性即可放置完整密钥。</li><li><code>RelaxedPropertyResolver</code>不再可以<code>Environment</code>自动处理：<code>env.getProperty(&quot;com.foo.my-bar&quot;)</code>将找到一个<code>com.foo.myBar</code>属性。</li></ul><p>该<code>org.springframework.boot.bind</code>软件包不再可用，并被<a href="https://github.com/spring-projects/spring-boot/wiki/Relaxed-Binding-2.0" target="_blank" rel="noopener">新的宽松绑定规则</a>所取代。特别是，<code>RelaxedDataBinder</code>朋友已被新的<code>Binder</code>API 取代。以下样品<code>MyProperties</code>从<code>app.acme</code>前缀中进行绑定。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MyProperties target = Binder.get(environment)</span><br><span class="line">.bind(<span class="string">"app.acme"</span>, MyProperties.class)</span><br><span class="line">.orElse(<span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><p>由于现在内置了轻松绑定，因此只要使用其中一种支持的格式，就可以请求任何属性而不必关心案例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FlagType flagType = Binder.get(environment)</span><br><span class="line">.bind(<span class="string">"acme.app.my-flag"</span>, FlagType.class)</span><br><span class="line">.orElse(FlagType.DEFAULT);</span><br></pre></td></tr></table></figure><h5 id="ConfigurationProperties-验证"><a href="#ConfigurationProperties-验证" class="headerlink" title="@ConfigurationProperties 验证"></a><code>@ConfigurationProperties</code> 验证</h5><p>如果您想打开验证，现在必须为您的<code>@ConfigurationProperties</code>对象添加注释<code>@Validated</code>。</p><h5 id="配置位置"><a href="#配置位置" class="headerlink" title="配置位置"></a>配置位置</h5><p><code>spring.config.location</code>配置的方式已被修复; 它提前将一个位置添加到默认位置列表中，现在它将替换默认位置。如果你是按照以前的方式进行处理，现在应该使用它<code>spring.config.additional-location</code>进行替换。</p><h4 id="开发-Web-应用程序"><a href="#开发-Web-应用程序" class="headerlink" title="开发 Web 应用程序"></a>开发 Web 应用程序</h4><h5 id="嵌入式容器包装结构"><a href="#嵌入式容器包装结构" class="headerlink" title="嵌入式容器包装结构"></a>嵌入式容器包装结构</h5><p>为了支持响应式用例，嵌入式容器包结构已经被大幅度的重构。 <code>EmbeddedServletContainer</code>已被重新命名为，<code>WebServer</code>并且该<code>org.springframework.boot.context.embedded</code>包已被重新定位到<code>org.springframework.boot.web.embedded</code>。例如，如果您使用<code>TomcatEmbeddedServletContainerFactory</code>回调接口定制嵌入式 Tomcat 容器，则应该使用<code>TomcatServletWebServerFactory</code>。</p><h5 id="特定于-Servlet-的服务器属性"><a href="#特定于-Servlet-的服务器属性" class="headerlink" title="特定于 Servlet 的服务器属性"></a>特定于 Servlet 的服务器属性</h5><p>许多<code>server.*</code> 属性 ( Servlet 特有的) 已经转移到<code>server.servlet</code>：</p><table><thead><tr><th style="text-align:center">旧的属性</th><th style="text-align:center">新的属性</th></tr></thead><tbody><tr><td style="text-align:center">server.context-parameters.*</td><td style="text-align:center">server.servlet.context-parameters.*</td></tr><tr><td style="text-align:center">server.context-path</td><td style="text-align:center">server.servlet.context-path</td></tr><tr><td style="text-align:center">server.jsp.class-name</td><td style="text-align:center">server.servlet.jsp.class-name</td></tr><tr><td style="text-align:center">server.jsp.init-parameters.*</td><td style="text-align:center">server.servlet.jsp.init-parameters.*</td></tr><tr><td style="text-align:center">server.jsp.registered</td><td style="text-align:center">server.servlet.jsp.registered</td></tr><tr><td style="text-align:center">server.servlet-path</td><td style="text-align:center">server.servlet.path</td></tr></tbody></table><h5 id="Web-Starter-作为传递依赖"><a href="#Web-Starter-作为传递依赖" class="headerlink" title="Web Starter 作为传递依赖"></a>Web Starter 作为传递依赖</h5><p>以前有几个 Spring Boot starter 是依赖于 Spring MVC 而传递的<code>spring-boot-starter-web</code>。在 <code>Spring WebFlux</code> 新的支持下，<code>spring-boot-starter-mustache</code>，<code>spring-boot-starter-freemarker</code>并<code>spring-boot-starter-thymeleaf</code>不再依赖它。开发者有责任选择和添加<code>spring-boot-starter-web</code>或<code>spring-boot-starter-webflux</code>。</p><h5 id="模板引擎"><a href="#模板引擎" class="headerlink" title="模板引擎"></a>模板引擎</h5><p>Mustache 模板曾经的文件扩展名是<code>.html</code>，现在的扩展名为 <code>.mustache</code> ，与官方规范和大多数 IDE 插件一致。您可以通过更改<code>spring.mustache.suffix</code>配置键来覆盖此新的默认值。</p><h5 id="Jackson-JSON-支持"><a href="#Jackson-JSON-支持" class="headerlink" title="Jackson / JSON 支持"></a>Jackson / JSON 支持</h5><p>在 2.0 中，我们改变了 Jackson 配置的默认值，将 ISO-8601 字符串 写为 JSR-310 日期 。如果你想回到以前的行为，你可以添加<code>spring.jackson.serialization.write-dates-as-timestamps=true</code>到你的配置。</p><p>新的<code>spring-boot-starter-json</code> starter 收集了必要的位去读写 JSON。它不仅提供了<code>jackson-databind</code>，而且提供了和 Java8 一起运作的时候相当有用的组件：<code>jackson-datatype-jdk8</code>,  <code>jackson-datatype-jsr310</code> 和 <code>jackson-module-parameter-names</code>。如果你曾经手动地依赖这些组件，现在可以依赖这个新的 starter 取代。</p><h5 id="Spring-MVC-路径匹配默认行为更改"><a href="#Spring-MVC-路径匹配默认行为更改" class="headerlink" title="Spring MVC 路径匹配默认行为更改"></a>Spring MVC 路径匹配默认行为更改</h5><p>我们已决定在 Spring MVC 应用程序中更改后缀路径匹配的默认值（请参阅<a href="https://github.com/spring-projects/spring-boot/issues/11105" target="_blank" rel="noopener">＃11105</a>）。按照 Spring Framework 中记录的<a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-ann-requestmapping-suffix-pattern-match" target="_blank" rel="noopener">最佳实践</a>，此功能不再默认启用。</p><p>如果您的应用程序希望将请求<code>&quot;GET /projects/spring-boot.json&quot;</code>映射到<code>@GetMapping(&quot;/projects/spring-boot&quot;)</code>映射，则此更改会影响您。</p><p>有关此更多信息以及如何减轻此更改，请查阅<a href="https://docs.spring.io/spring-boot/docs/2.0.0.RC1/reference/html/boot-features-developing-web-applications.html#boot-features-spring-mvc-pathmatch" target="_blank" rel="noopener">Spring Boot中有关路径匹配和内容协商的参考文档</a>。</p><h5 id="Servlet-过滤器"><a href="#Servlet-过滤器" class="headerlink" title="Servlet 过滤器"></a>Servlet 过滤器</h5><p>Servlet 过滤器的默认调度程序类型现在是<code>DipatcherType.REQUEST</code>; 这使 Spring Boot 的默认值与 Servlet 规范的默认值一致。如果您希望将过滤器映射到其他调度程序类型，请使用<code>FilterRegistrationBean</code>注册您的过滤器。</p><p>注意：Spring Security 和 Spring Session 过滤器配置  <code>ASYNC</code>, <code>ERROR</code>以及 <code>REQUEST</code> 调度类型。</p><h5 id="RestTemplateBuilder"><a href="#RestTemplateBuilder" class="headerlink" title="RestTemplateBuilder"></a>RestTemplateBuilder</h5><p>该<code>requestFactory(ClientHttpRequestFactory)</code>方法已被新<code>requestFactory(Supplier&lt;ClientHttpRequestFactory&gt; requestFactorySupplier)</code>方法所取代。<code>Supplier</code>允许构建器生成的每个模板使用它自己的请求工厂，从而避免共享工厂可能导致的副作用。见<a href="https://github.com/spring-projects/spring-boot/issues/11255" target="_blank" rel="noopener">＃11255</a>。</p><h5 id="WebJars-定位器"><a href="#WebJars-定位器" class="headerlink" title="WebJars 定位器"></a>WebJars 定位器</h5><p>Spring Boot 1.x 使用并提供依赖关系管理<code>org.webjars:webjars-locator</code>。<code>webjars-locator</code>是一个<a href="https://github.com/webjars/webjars-locator/tree/ec6b793f2d6f031f6aa384a06c059ff499055652" target="_blank" rel="noopener">“命名不佳的库……包装<code>webjars-locator-core</code>项目”</a>。<code>org.webjars:webjars-locator</code>应该更新依赖项来<code>org.webjars:webjars-locator-core</code>代替使用。</p><h4 id="Security"><a href="#Security" class="headerlink" title="Security"></a>Security</h4><p>Spring Boot 2 极大地简化了默认的安全配置，并使添加定制安全变得简单。Spring Boot 现在具有一种行为，只要您添加自己的 <code>WebSecurityConfigurerAdapter</code> 就会退出，而不是进行多种与安全性相关的自动配置。</p><p>如果您使用以下任何属性，则会受到影响：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">security.basic.authorize-mode</span><br><span class="line">security.basic.enabled</span><br><span class="line">security.basic.path</span><br><span class="line">security.basic.realm</span><br><span class="line">security.enable-csrf</span><br><span class="line">security.headers.cache</span><br><span class="line">security.headers.content-security-policy</span><br><span class="line">security.headers.content-security-policy-mode</span><br><span class="line">security.headers.content-type</span><br><span class="line">security.headers.frame</span><br><span class="line">security.headers.hsts</span><br><span class="line">security.headers.xss</span><br><span class="line">security.ignored</span><br><span class="line">security.require-ssl</span><br><span class="line">security.sessions</span><br></pre></td></tr></table></figure><h5 id="默认安全"><a href="#默认安全" class="headerlink" title="默认安全"></a>默认安全</h5><p>安全自动配置不再公开选项，并尽可能使用 Spring Security 默认值。一个明显的副作用是使用 Spring Security 的内容协商进行授权（表单登录）。</p><h5 id="默认用户"><a href="#默认用户" class="headerlink" title="默认用户"></a>默认用户</h5><p>默认情况下，Spring Boot 使用生成的密码配置单个用户。用户可以使用 <code>spring.security.user.*</code> 属性进行配置。要进一步定制用户或添加其他用户，您将不得不公开一个<code>UserDetailsService</code>bean。</p><h5 id="AuthenticationManager-Bean"><a href="#AuthenticationManager-Bean" class="headerlink" title="AuthenticationManager Bean"></a>AuthenticationManager Bean</h5><p>如果您想将 Spring Security <code>AuthenticationManager</code>作为 bean 公开，请覆盖<code>authenticationManagerBean</code>您的方法<code>WebSecurityConfigurerAdapter</code>并为其添加注释<code>@Bean</code>。</p><h5 id="OAuth2"><a href="#OAuth2" class="headerlink" title="OAuth2"></a>OAuth2</h5><p>从功能的 <a href="http://projects.spring.io/spring-security-oauth/" target="_blank" rel="noopener">Spring Security OAuth 项目</a> 迁移到核心 <a href="https://projects.spring.io/spring-security/" target="_blank" rel="noopener">Spring Security</a>。不再为依赖关系提供依赖管理，Spring Boot 2 通过 Spring Security 5 提供 <a href="https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#boot-features-security-oauth2" target="_blank" rel="noopener">OAuth 2.0 客户端支持</a>。</p><p>如果您依赖尚未迁移的 Spring Security OAuth 功能，则需要在其他 jar 上添加依赖项，请查看<a href="https://docs.spring.io/spring-security-oauth2-boot/docs/current/reference/htmlsingle/" target="_blank" rel="noopener">文档</a>以获取更多详细信息。我们还继续支持 Spring Boot 1.5，以便旧版应用程序可以继续使用它，直到提供升级路径。</p><h5 id="执行器安全"><a href="#执行器安全" class="headerlink" title="执行器安全"></a>执行器安全</h5><p>执行器不再有单独的安全自动配置（<code>management.security.*</code>属性消失）。<code>sensitive</code>每个端点的标志也没有在安全配置中变得更加明确。如果您依赖于此行为，则需要创建或调整您的安全配置，以保护您选择角色的端点。</p><p>例如，假设以下配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">endpoints.flyway.sensitive=false</span><br><span class="line">endpoints.info.sensitive=true</span><br><span class="line">management.security.roles=MY_ADMIN</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">http</span><br><span class="line">.authorizeRequests()</span><br><span class="line">.requestMatchers(EndpointRequest.to(<span class="string">"health"</span>, <span class="string">"flyway"</span>)).permitAll()</span><br><span class="line">.requestMatchers(EndpointRequest.toAnyEndpoint()).hasRole(<span class="string">"MY_ADMIN"</span>)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>需要注意的是在<code>2.x</code>，<code>health</code>和<code>info</code>在默认情况下启用（与<code>health</code>默认情况下不显示其细节）。为了与这些新的默认值一致，<code>health</code>已被添加到第一个匹配器。</p><h4 id="使用-SQL-数据库"><a href="#使用-SQL-数据库" class="headerlink" title="使用 SQL 数据库"></a>使用 SQL 数据库</h4><h5 id="配置数据源"><a href="#配置数据源" class="headerlink" title="配置数据源"></a>配置数据源</h5><p>默认连接池已从 Tomcat 切换到 HikariCP。如果您过去<code>spring.datasource.type</code>在基于 Tomcat 的应用程序中强制使用 Hikari，现在可以删除重写。</p><p>特别是，如果你有这样的设置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-jpa<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.zaxxer<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>HikariCP<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>现在可以这样修改：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-jpa<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="WARN-消息隐含的’打开在视图’"><a href="#WARN-消息隐含的’打开在视图’" class="headerlink" title="WARN 消息隐含的’打开在视图’"></a>WARN 消息隐含的’打开在视图’</h5><p>从现在起，未明确启用的应用程序<code>spring.jpa.open-in-view</code>将在启动过程中收到警告消息。虽然这种行为是一种友好的默认行为，但如果您没有完全意识到为您做了什么，这可能会导致问题。此消息可确保您了解可在查看呈现期间执行数据库查询。如果你没有问题，你可以明确地配置这个属性来消除警告信息。</p><h5 id="JPA-和-Spring-Data"><a href="#JPA-和-Spring-Data" class="headerlink" title="JPA 和 Spring Data"></a>JPA 和 Spring Data</h5><p>在 Spring Boot 1.x 中，一些用户正在扩展<code>HibernateJpaAutoConfiguration</code>以将高级自定义应用于自动配置<code>EntityManagerFactory</code>。为了防止发生这种错误的用例，Spring Boot 2 中不再可能扩展它。</p><p>为了支持这些用例，现在可以定义一个<code>HibernatePropertiesCustomizer</code>bean，它可以完全控制 Hibernate 属性，包括注册在上下文中声明为 bean 的 Hibernate 拦截器的能力。</p><h5 id="Flyway"><a href="#Flyway" class="headerlink" title="Flyway"></a>Flyway</h5><p>Flyway 配置键被移动到<code>spring</code>命名空间（即<code>spring.flyway</code>）</p><p>升级到 Spring Boot 2 将会将 Flyway 升级<code>3.x</code>到<code>5.x</code>。为确保模式升级顺利进行，请按照以下说明操作：</p><ul><li>首先将您的<code>1.5.x</code>Spring Boot 应用程序升级到 Flyway 4，请参阅<a href="https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#using-boot-maven-parent-pom" target="_blank" rel="noopener">Maven</a>和<a href="https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/gradle-plugin/reference/html//#managing-dependencies-customizing" target="_blank" rel="noopener">Gradle</a>的说明。</li><li>一旦您的架构升级到了 Flyway 4，升级到 Spring Boot 2 并再次运行迁移以将您的应用程序移植到 Flyway 5。</li></ul><h5 id="Liquibase"><a href="#Liquibase" class="headerlink" title="Liquibase"></a>Liquibase</h5><p>Liquibase 配置键被移动到<code>spring</code>命名空间（即<code>spring.liquibase</code>）</p><h5 id="数据库初始化"><a href="#数据库初始化" class="headerlink" title="数据库初始化"></a>数据库初始化</h5><p>基本<code>DataSource</code>初始化现在仅针对嵌入式数据源启用，并将在您使用生产数据库时立即关闭。新的<code>spring.datasource.initialization-mode</code>（替换<code>spring.datasource.initialize</code>）提供更多的控制。</p><h5 id="更新默认的’创建-删除’处理"><a href="#更新默认的’创建-删除’处理" class="headerlink" title="更新默认的’创建 - 删除’处理"></a>更新默认的’创建 - 删除’处理</h5><p><code>spring.jpa.hibernate.ddl-auto</code> 属性默认为只有在没有使用 Liquibase 或 Flyway 等模式管理器时才使用嵌入式数据库进行创建。一旦检测到模式管理器，默认更改为 <code>none</code>。</p><h4 id="整合-NoSQL"><a href="#整合-NoSQL" class="headerlink" title="整合 NoSQL"></a>整合 NoSQL</h4><h5 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h5><p>现在使用的是 <a href="https://lettuce.io/" target="_blank" rel="noopener">Lettuce</a> 而不是 <a href="https://github.com/xetorthio/jedis" target="_blank" rel="noopener">Jedis</a> 作为 Redis 驱动程序<code>spring-boot-starter-redis</code>。如果您使用更高级别的Spring Data 构造，则应该发现变化是透明的。我们仍然支持 Jedis，如果您愿意，通过排除 <code>io.lettuce：lettuce-core</code>并添加 <code>redis.clients：jedis</code>，则可以自由切换依赖项。</p><h5 id="Elasticsearch"><a href="#Elasticsearch" class="headerlink" title="Elasticsearch"></a>Elasticsearch</h5><p>Elasticsearch 已经升级到 6.0+。与 <a href="https://www.elastic.co/blog/elasticsearch-the-server" target="_blank" rel="noopener">Elastic 宣布嵌入式 Elasticsearch 不再受支持一致</a>，自动配置<code>NodeClient</code>已被删除。<code>TransportClient</code>可以通过使用<code>spring.data.elasticsearch.cluster-nodes</code>提供要连接的一个或多个节点的地址来自动配置。</p><h4 id="高速缓存"><a href="#高速缓存" class="headerlink" title="高速缓存"></a>高速缓存</h4><p>用于缓存的专用 Hazelcast 自动配置。</p><p>无法自动配置常规<code>HazelcastInstance</code>和专用<code>HazelcastInstance</code>缓存。因此，该<code>spring.cache.hazelcast.config</code>属性已不再可用。</p><h4 id="批量"><a href="#批量" class="headerlink" title="批量"></a>批量</h4><p>在启动时执行批处理作业的 CommandLineRunner 的顺序为 0。</p><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><h5 id="Mockito-1-x"><a href="#Mockito-1-x" class="headerlink" title="Mockito 1.x"></a>Mockito 1.x</h5><p>Mockito 1.x 不再支持<code>@MockBean</code>和<code>@SpyBean</code>。如果你不用<code>spring-boot-starter-test</code>来管理你的依赖关系，你应该升级到 Mockito 2.x.</p><h3 id="Spring-Boot-Actuator"><a href="#Spring-Boot-Actuator" class="headerlink" title="Spring Boot Actuator"></a>Spring Boot Actuator</h3><p>Spring Boot 2 为 Actuator 带来了重要变化，无论是内部还是面向用户，请查阅<a href="https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#production-ready" target="_blank" rel="noopener">参考指南中</a>的<a href="https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#production-ready" target="_blank" rel="noopener">更新部分</a>和<a href="https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/actuator-api/html" target="_blank" rel="noopener">新的Actuator API文档</a>。</p><p>您应该期望编程模型，配置密钥和某些端点的响应格式发生变化。Actuator 现在在 Spring MVC，Spring WebFlux 和Jersey 上得到本地支持。</p><h4 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h4><p>Actuator 的代码分为两个模块：现有的<code>spring-boot-actuator</code>和新的<code>spring-boot-actuator-autoconfigure</code>。如果您使用原始模块（<code>spring-boot-actuator</code>）导入 actuator，请考虑使用<code>spring-boot-starter-actuator</code>启动器替代它。</p><h4 id="Keys-的配置结构"><a href="#Keys-的配置结构" class="headerlink" title="Keys 的配置结构"></a>Keys 的配置结构</h4><p>Endpoints 基础配置 key 已经统一：</p><table><thead><tr><th style="text-align:center">旧的属性</th><th style="text-align:center">新的属性</th></tr></thead><tbody><tr><td style="text-align:center"><code>endpoints.&lt;id&gt;.*</code></td><td style="text-align:center"><code>management.endpoint.&lt;id&gt;.*</code></td></tr><tr><td style="text-align:center"><code>endpoints.cors.*</code></td><td style="text-align:center"><code>management.endpoints.web.cors.*</code></td></tr><tr><td style="text-align:center"><code>endpoints.jmx.*</code></td><td style="text-align:center"><code>management.endpoints.jmx.*</code></td></tr><tr><td style="text-align:center"><code>management.address</code></td><td style="text-align:center"><code>management.server.address</code></td></tr><tr><td style="text-align:center"><code>management.context-path</code></td><td style="text-align:center"><code>management.server.servlet.context-path</code></td></tr><tr><td style="text-align:center"><code>management.ssl.*</code></td><td style="text-align:center"><code>management.server.ssl.*</code></td></tr><tr><td style="text-align:center"><code>management.port</code></td><td style="text-align:center">management.server.port</td></tr></tbody></table><h4 id="基本路径"><a href="#基本路径" class="headerlink" title="基本路径"></a>基本路径</h4><p>所有 endpoints 默认情况下都已移至 <code>/actuator</code>。</p><p>我们修改了 <code>management.server.servlet.context-path</code> 的含义：它现在是 <code>server.servlet.context-path</code> 的端点管理的等价替代（只有在设置了 <code>management.server.port</code> 时才有效）。另外，您还可以使用新的单独属性 <code>management.endpoints.web.base-path</code> 为管理端点设置基本路径。</p><p>例如，如果你设置<code>management.server.servlet.context-path=/management</code>和<code>management.endpoints.web.base-path=/application</code>，你就可以在下面的路径到达终点健康：<code>/management/application/health</code>。</p><p>如果你想恢复 1.x 的行为（即具有<code>/health</code>代替<code>/actuator/health</code>），设置以下属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">management.endpoints.web.base-path=/</span><br></pre></td></tr></table></figure><h4 id="审计事件-API-更改"><a href="#审计事件-API-更改" class="headerlink" title="审计事件 API 更改"></a>审计事件 API 更改</h4><p><code>AuditEventRepository</code> 现在有一个包含所有可选参数的单一方法。</p><h4 id="Endpoints"><a href="#Endpoints" class="headerlink" title="Endpoints"></a>Endpoints</h4><p>要通过 HTTP 使执行器端点可用，它需要同时<strong>启用</strong>和<strong>公开</strong>。默认：</p><ul><li><strong>无论您的应用程序中是否存在和配置 Spring Security</strong>，只有端点<code>/health</code>和<code>/info</code>端点都是暴露的。</li><li>所有端点，但<code>/shutdown</code>已启用。</li></ul><p>您可以按如下方式公开所有端点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">management.endpoints.web.exposure.include=*</span><br></pre></td></tr></table></figure><p>您可以通过以下方式显式启用<code>/shutdown</code>端点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">management.endpoint.shutdown.enabled=true</span><br></pre></td></tr></table></figure><p>要公开所有（已启用）网络端点除<code>env</code>端点之外：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">management.endpoints.web.exposure.include=*</span><br><span class="line">management.endpoints.web.exposure.exclude=env</span><br></pre></td></tr></table></figure><h5 id="Endpoint-changes"><a href="#Endpoint-changes" class="headerlink" title="Endpoint changes"></a>Endpoint changes</h5><table><thead><tr><th>1.x 端点</th><th>2.0 端点（改变）</th></tr></thead><tbody><tr><td><code>/actuator</code></td><td>不再可用。 但是，在 <code>management.endpoints.web.base-path</code> 的根目录中有一个映射，它提供了到所有暴露端点的链接。</td></tr><tr><td><code>/auditevents</code></td><td>该<code>after</code>参数不再需要</td></tr><tr><td><code>/autoconfig</code></td><td>重命名为 <code>/conditions</code></td></tr><tr><td><code>/docs</code></td><td>不再可用</td></tr><tr><td><code>/health</code></td><td>现在有一个 <code>management.endpoint.health.show-details</code> 选项  <code>never</code>, <code>always</code>, <code>when-authenticated</code>，而不是依靠  <code>sensitive</code> 标志来确定 <code>health</code> 端点是否必须显示全部细节。  默认情况下，<code>/actuator/health</code>公开并且不显示细节。</td></tr><tr><td><code>/trace</code></td><td>重命名为 <code>/httptrace</code></td></tr></tbody></table><p>端点属性已更改如下：</p><ul><li><code>endpoints.&lt;id&gt;.enabled</code> 已经转移到了 <code>management.endpoint.&lt;id&gt;.enabled</code></li><li><code>endpoints.&lt;id&gt;.id</code> 没有替换（端点的 ID 不再可配置）</li><li><code>endpoints.&lt;id&gt;.sensitive</code>没有替代品（请参见<a href="https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-2.0-Migration-Guide#actuator-security" target="_blank" rel="noopener">执行器安全</a>）</li><li><code>endpoints.&lt;id&gt;.path</code> 已经转移到了 <code>management.endpoints.web.path-mapping.&lt;id&gt;</code></li></ul><h4 id="端点格式"><a href="#端点格式" class="headerlink" title="端点格式"></a>端点格式</h4><h5 id="actuator-mappings-端点大改变"><a href="#actuator-mappings-端点大改变" class="headerlink" title="/actuator/mappings 端点大改变"></a><code>/actuator/mappings</code> 端点大改变</h5><p>JSON 格式已经更改为现在正确地包含有关上下文层次结构，多个<code>DispatcherServlets，</code>部署的 Servlet 和 Servlet 过滤器的信息。详情请参阅<a href="https://github.com/spring-projects/spring-boot/issues/9979#issuecomment-357930821" target="_blank" rel="noopener">＃9979</a>。</p><p>Actuator API 文档的<a href="https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/actuator-api/html/#mappings" target="_blank" rel="noopener">相关部分</a>提供了一个示例文档。</p><h5 id="actuator-httptrace-端点大改变"><a href="#actuator-httptrace-端点大改变" class="headerlink" title="/actuator/httptrace 端点大改变"></a><code>/actuator/httptrace</code> 端点大改变</h5><p>响应的结构已经过改进，以反映端点关注跟踪 HTTP 请求 - 响应交换的情况。</p><h4 id="迁移自定义端点"><a href="#迁移自定义端点" class="headerlink" title="迁移自定义端点"></a>迁移自定义端点</h4><p>如果您有自定义执行器端点，请<a href="https://spring.io/blog/2017/08/22/introducing-actuator-endpoints-in-spring-boot-2-0" target="_blank" rel="noopener">查看专用博客文章</a>。该团队还撰写了一个 wiki 页面，介绍<a href="https://github.com/spring-projects/spring-boot/wiki/Migrating-a-custom-Actuator-endpoint-to-Spring-Boot-2" target="_blank" rel="noopener">如何将现有的执行器端点迁移</a>到新的基础架构。</p><h3 id="Metrics"><a href="#Metrics" class="headerlink" title="Metrics"></a>Metrics</h3><p>Spring Boot 自己的指标已被支持取代，包括自动配置，用于 <a href="https://micrometer.io/" target="_blank" rel="noopener">icrometer</a>  和 dimensional 指标。</p><h4 id="设置-icrometer"><a href="#设置-icrometer" class="headerlink" title="设置 icrometer"></a>设置 icrometer</h4><p>如果您的 Spring Boot 2.0 应用程序已依赖于 Actuator，则 icrometer 已在此处并自动配置。如果您希望将度量标准导出到 Prometheus，Atlas 或 Datadog 等外部注册表，Micrometer 将为许多注册表提供依赖关系; 您可以使用<code>spring.metrics.*</code>属性配置您的应用程序以导出到特定的注册表。</p><h4 id="迁移定制计数器-量表"><a href="#迁移定制计数器-量表" class="headerlink" title="迁移定制计数器/量表"></a>迁移定制计数器/量表</h4><p>您可以通过以下方式创建各种指标，而不是在应用程序代码中注入<code>CounterService</code>或<code>GaugeService</code>的实例：</p><ul><li>注入<code>MeterRegistry</code>和调用方法。</li><li>直接调用静态方法<code>Counter featureCounter = Metrics.counter(&quot;feature&quot;);</code>。</li></ul><h3 id="开发者工具"><a href="#开发者工具" class="headerlink" title="开发者工具"></a>开发者工具</h3><h4 id="热拔插"><a href="#热拔插" class="headerlink" title="热拔插"></a>热拔插</h4><p>由于 Spring Loaded 项目被搁置，它在 Spring Boot 的支持已被删除。我们建议使用 Devtools。</p><h4 id="Devtools-远程调试隧道"><a href="#Devtools-远程调试隧道" class="headerlink" title="Devtools 远程调试隧道"></a>Devtools 远程调试隧道</h4><p>已经从 Devtools 中删除了对通过 HTTP 进行隧道远程调试的支持。</p><h3 id="已删除的功能"><a href="#已删除的功能" class="headerlink" title="已删除的功能"></a>已删除的功能</h3><p>以下功能不再可用：</p><ul><li>CRaSH 支持</li><li>Spring Mobile 的自动配置和依赖关系管理。</li><li>Spring Social 的自动配置和依赖关系管理。</li><li>依赖关系管理<code>commons-digester</code>。</li></ul><h3 id="依赖版本"><a href="#依赖版本" class="headerlink" title="依赖版本"></a>依赖版本</h3><p>以下库的最低支持版本已更改：</p><ul><li>Elasticsearch 5.6</li><li>Gradle 4</li><li>Hibernate 5.2</li><li>Jetty 9.4</li><li>Spring Framework 5</li><li>Spring Security 5</li><li>Tomcat 8.5</li></ul><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="">https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-2.0-Migration-Guide</a></p><h3 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h3><p>1、<a href="http://www.54tianzhisheng.cn/2018/03/06/SpringBoot2-Migration-Guide/" target="_blank" rel="noopener">Spring Boot 2.0系列文章(一)：Spring Boot 2.0 迁移指南</a></p><p>2、<a href="http://www.54tianzhisheng.cn/2018/03/06/SpringBoot2-new-features/" target="_blank" rel="noopener">Spring Boot 2.0系列文章(二)：Spring Boot 2.0 新特性详解</a></p><p>3、<a href="http://www.54tianzhisheng.cn/2018/04/13/Spring_Boot_2.0_Configuration_Changelog/" target="_blank" rel="noopener">Spring Boot 2.0系列文章(三)：Spring Boot 2.0 配置改变</a></p><p>4、<a href="http://www.54tianzhisheng.cn/2018/04/15/springboot2_code/" target="_blank" rel="noopener">Spring Boot 2.0系列文章(四)：Spring Boot 2.0 源码阅读环境搭建</a></p><p>5、<a href="http://www.54tianzhisheng.cn/2018/04/18/spring_boot2_project/" target="_blank" rel="noopener">Spring Boot 2.0系列文章(五)：Spring Boot 2.0 项目源码结构预览</a></p><p>6、<a href="http://www.54tianzhisheng.cn/2018/04/19/SpringBootApplication-annotation/" target="_blank" rel="noopener">Spring Boot 2.0系列文章(六)：Spring boot 2.0 中 SpringBootApplication 注解详解</a></p><p>7、<a href="http://www.54tianzhisheng.cn/2018/04/30/springboot_SpringApplication/" target="_blank" rel="noopener">Spring Boot 2.0系列文章(七)：SpringApplication 深入探索</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://ws4.sinaimg.cn/large/006tNc79gy1fp3h0820m2j31hc0zkwxr.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;前提&quot;&gt;&lt;a href=&quot;#前提&quot; class=&quot;headerlink&quot; title=&quot;前提&quot;&gt;&lt;/a&gt;前提&lt;/h3&gt;&lt;p&gt;希望本文档将帮助您把应用程序迁移到 Spring Boot 2.0。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="SpringBoot" scheme="http://yoursite.com/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot 2.0系列文章(二)：Spring Boot 2.0 新特性详解</title>
    <link href="http://yoursite.com/2018/03/06/SpringBoot2-new-features/"/>
    <id>http://yoursite.com/2018/03/06/SpringBoot2-new-features/</id>
    <published>2018-03-05T16:00:00.000Z</published>
    <updated>2018-05-02T13:28:09.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fp34jn0xb3j31hc140aji.jpg" alt=""></p><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>在 3 月 1 号，Spring Boot<code>2.0.0.RELEASE</code>正式发布，这是 Spring Boot1.0 发布 4 年之后第一次重大修订，因此有多的新功能和特性值得大家期待！下面带大家了解下 Spring Boot 2.0 中的新特性。</p><a id="more"></a><h3 id="关注我"><a href="#关注我" class="headerlink" title="关注我"></a>关注我</h3><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180103/C6LG3mGa12.jpg" alt="mark"></p><p>转载请务必注明原创地址为：<a href="http://www.54tianzhisheng.cn/2018/03/06/SpringBoot2-new-features/" target="_blank" rel="noopener">http://www.54tianzhisheng.cn/2018/03/06/SpringBoot2-new-features/</a></p><h3 id="从-Spring-Boot-1-5-升级"><a href="#从-Spring-Boot-1-5-升级" class="headerlink" title="从 Spring Boot 1.5 升级"></a>从 Spring Boot 1.5 升级</h3><p>由于 Spring Boot 2.0 的改变幅度有点大，所以升级现有的程序可能会比平常更大一些。</p><p>如果你还在考虑是否要升级，这里推荐 DD 的博客文章：<a href="http://blog.didispace.com/spring-boot-2-release/" target="_blank" rel="noopener">Spring Boot 2.0 正式发布，升还是不升呢？</a></p><p>如果要升级可以参考我的另外一篇文章：<a href="http://www.54tianzhisheng.cn/2018/03/06/SpringBoot2-Migration-Guide/" target="_blank" rel="noopener">Spring Boot 2.0 迁移指南</a></p><p>如果您目前正在运行较早版本的 Spring Boot，我们强烈建议您在迁移到 Spring Boot 2.0 之前先升级到 Spring Boot 1.5。</p><h3 id="新的和值得注意的特性"><a href="#新的和值得注意的特性" class="headerlink" title="新的和值得注意的特性"></a>新的和值得注意的特性</h3><p>小技巧：检查 <a href="https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-2.0-Configuration-Changelog" target="_blank" rel="noopener">配置更改日志</a> 来获取配置更改的完整描述。</p><h3 id="起码-JDK-8-和支持-JDK-9"><a href="#起码-JDK-8-和支持-JDK-9" class="headerlink" title="起码 JDK 8 和支持 JDK 9"></a>起码 JDK 8 和支持 JDK 9</h3><p>Spring Boot 2.0 要求 Java 8 作为最低版本。许多现有的 API 已更新，以利用 Java 8 的特性，例如：接口上的默认方法，函数回调以及新的 API，如<code>javax.time</code>。如果您当前正在使用 Java 7 或更早版本，则在开发 Spring Boot 2.0 应用程序之前，您需要升级您的 JDK。</p><p>Spring Boot 2.0 通过了在 JDK 9 下的测试，可以在 JDK 9 下正常运行，。我们所有的 jar 包都在模块系统兼容性的清单中附带了自动模块名称条目。</p><h3 id="第三方库的升级"><a href="#第三方库的升级" class="headerlink" title="第三方库的升级"></a>第三方库的升级</h3><p>Spring Boot 2.0 建立在 Spring Framework 5 之上，并且需要 Spring Framework 5 。你可以通过  <a href="https://github.com/spring-projects/spring-framework/wiki/What%27s-New-in-Spring-Framework-5.x" target="_blank" rel="noopener">What’s New in Spring Framework 5.x</a>  了解 Spring 5 的新特性。并在继续之前查看其升级指南 <a href="https://github.com/spring-projects/spring-framework/wiki/Upgrading-to-Spring-Framework-5.x" target="_blank" rel="noopener">Upgrading to Spring Framework 5.x</a> 。</p><p>我们已尽可能升级到其他第三方库的最新稳定版本。 本版本中一些显着的依赖性升级包括：</p><ul><li>Tomcat 8.5</li><li>Flyway 5</li><li>Hibernate 5.2</li><li>Thymeleaf 3</li></ul><h3 id="Reactive-Spring"><a href="#Reactive-Spring" class="headerlink" title="Reactive Spring"></a>Reactive Spring</h3><p>Spring 产品组合中的许多项目现在都为开发<a href="https://github.com/reactive-streams/reactive-streams-jvm#reactive-streams" target="_blank" rel="noopener">反应式应用程序</a>提供一流的支持。反应性应用程序是完全异步和非阻塞的。它们旨在用于事件循环执行模型（而不是更传统的每个请求线程执行模型）。Spring 框架参考文档中的<a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web-reactive.html" target="_blank" rel="noopener">“Web 反应堆栈”</a>部分为这个主题提供了一个很好的入门。</p><p>Spring Boot 2.0 通过自动配置和启动器 POM 完全支持反应式应用。Spring Boot 的内部本身也在必要时进行了更新，以提供反应性的反应（最明显的是我们的嵌入式服务器支持）。</p><h4 id="Spring-WebFlux＆WebFlux-fn"><a href="#Spring-WebFlux＆WebFlux-fn" class="headerlink" title="Spring WebFlux＆WebFlux.fn"></a>Spring WebFlux＆WebFlux.fn</h4><p>Spring WebFlux 是 Spring MVC 的完全非阻塞反应式替代方案。Spring Boot 为基于注释的 Spring WebFlux 应用程序以及 WebFlux.fn 提供了自动配置，WebFlux.fn 提供了更实用的样式 API。</p><p>要开始，请添加 <code>spring-boot-starter-webflux</code> 到 POM，它将提供由嵌入式 Netty 服务器支持的 Spring WebFlux。</p><h4 id="Reactive-Spring-Data"><a href="#Reactive-Spring-Data" class="headerlink" title="Reactive Spring Data"></a>Reactive Spring Data</h4><p>在底层技术支持的情况下，Spring Data 还为反应式应用程序提供支持。目前 Cassandra，MongoDB，Couchbase 和 Redis 都有反应式 API 支持。</p><p>Spring Boot 包含针对这些技术的特殊 starter-POMs，可为您提供启动所需的一切。例如，<code>spring-boot-starter-data-mongodb-reactive</code>包括对反应性 mongo 驱动程序和项目反应堆的依赖性。</p><h4 id="Reactive-Spring-Security"><a href="#Reactive-Spring-Security" class="headerlink" title="Reactive Spring Security"></a>Reactive Spring Security</h4><p>Spring Boot 2.0 可以充分利用 Spring Security 5.0 来保护您的反应式应用程序。当 Spring Security 位于类路径中时，会为 WebFlux 应用程序提供自动配置。</p><p>使用 WebFlux 的 Spring Security 访问规则可以通过<code>SecurityWebFilterChain</code>。如果你之前整合过 Spring MVC 和 Spring Security，应该会感到非常熟悉。有关更多详细信息，请参阅 <a href="http://docs.spring.io/spring-boot/docs/2.0.x-SNAPSHOT/reference/htmlsingle/#boot-features-security-webflux" target="_blank" rel="noopener">Spring Boot 参考文档</a>和 <a href="https://docs.spring.io/spring-security/site/docs/5.0.0.RELEASE/reference/htmlsingle/#jc-webflux" target="_blank" rel="noopener">Spring Security 文档</a>。</p><h4 id="嵌入式-Netty-服务器"><a href="#嵌入式-Netty-服务器" class="headerlink" title="嵌入式 Netty 服务器"></a>嵌入式 Netty 服务器</h4><p>由于 WebFlux 不依赖于 Servlet API，我们现在可以首次为 Netty 作为嵌入式服务器提供支持。该<code>spring-boot-starter-webflux</code>  启动 POM 将拉取 Netty  4.1 和 <a href="https://github.com/reactor/reactor-netty" target="_blank" rel="noopener">Ractor Netty</a> 。</p><p>注意：您只能将 Netty 用作反应式服务器。不提供阻止 servlet API 支持。</p><h3 id="HTTP-2-支持"><a href="#HTTP-2-支持" class="headerlink" title="HTTP/2 支持"></a>HTTP/2 支持</h3><p>为 Tomcat，Undertow 和 Jetty 提供 HTTP / 2 支持。支持取决于所选的 Web 服务器和应用程序环境（因为 JDK 8 不支持该协议）。</p><p>如何配置 HTTP／2，请参考 <a href="https://docs.spring.io/spring-boot/docs/2.0.x-SNAPSHOT/reference/htmlsingle/#howto-configure-http2" target="_blank" rel="noopener">官方文档</a> 。</p><h3 id="配置属性的绑定"><a href="#配置属性的绑定" class="headerlink" title="配置属性的绑定"></a>配置属性的绑定</h3><p>在 Spring Boot 2.0 中，用于绑定<code>Environment</code>属性的机制<code>@ConfigurationProperties</code>已经完全彻底修改。我们借此机会收紧了松散绑定的规则，并修复了 Spring Boot 1.x 中的许多不一致之处。</p><p>新的<code>Binder</code>API 也可以<code>@ConfigurationProperties</code>直接在你自己的代码之外使用。例如，下面将结合到<code>List</code>的<code>PersonName</code>对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;PersonName&gt; people = Binder.get(environment)</span><br><span class="line">    .bind(<span class="string">"my.property"</span>, Bindable.listOf(PersonName.class))</span><br><span class="line">    .orElseThrow(IllegalStateException::<span class="keyword">new</span>);</span><br></pre></td></tr></table></figure><p>配置源可以像这样在 YAML 中表示：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">my:</span></span><br><span class="line"><span class="attr">  property:</span></span><br><span class="line"><span class="attr">  - first-name:</span> <span class="string">zhisheng</span></span><br><span class="line"><span class="attr">    last-name:</span> <span class="string">tian</span></span><br><span class="line"><span class="attr">  - first-name:</span> <span class="string">zhisheng</span></span><br><span class="line"><span class="attr">    last-name:</span> <span class="string">tian</span></span><br></pre></td></tr></table></figure><p>有关更新绑定规则的更多信息，<a href="https://github.com/spring-projects/spring-boot/wiki/Relaxed-Binding-2.0" target="_blank" rel="noopener">请参阅此Wiki页面</a>。</p><h4 id="配置起源"><a href="#配置起源" class="headerlink" title="配置起源"></a>配置起源</h4><p>YAML 文件和被 Spring Boot 加载的 Properties 文件现在包含<code>Origin</code>信息，可帮助您跟踪项目从何处加载的信息。有些 Spring Boot 特性利用了这个信息可以在适当的时候展示出来。</p><p>例如，<code>BindException</code>绑定失败时抛出的类是一个<code>OriginProvider</code>。这意味着原始信息可以很好地从故障分析器中显示出来。</p><p>另一个例子是<code>env</code>执行器端点，当它有可用时包含了原始信息。下面的代码片断显示该<code>spring.security.user.name</code>属性来自 jar 包中的 application.properties 文件的第 1行，第 27 列。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"applicationConfig: [classpath:/application.properties]"</span>,</span><br><span class="line">  <span class="attr">"properties"</span>: &#123;</span><br><span class="line">    <span class="attr">"spring.security.user.name"</span>: &#123;</span><br><span class="line">      <span class="attr">"value"</span>: <span class="string">"user"</span>,</span><br><span class="line">      <span class="attr">"origin"</span>: <span class="string">"class path resource [application.properties]:1:27"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="转换器支持"><a href="#转换器支持" class="headerlink" title="转换器支持"></a>转换器支持</h4><p>Binding 利用了一个新的 <code>ApplicationConversionService</code> 类，它提供了一些对属性绑定特别有用的额外转换器。最引人注目的是转换器的<code>Duration</code>类型和分隔字符串。</p><p>该<code>Duration</code>转换器允许在任一 ISO-8601 格式中指定的持续时间，或作为一个简单的字符串（例如<code>10m</code>，10 分钟）。现有的属性已更改为始终使用<code>Duration</code>。该<code>@DurationUnit</code>注释通过设置如果没有指定所使用的单元确保向后兼容性。例如，Spring Boot 1.5 中需要秒数的属性现在必须<code>@DurationUnit(ChronoUnit.SECONDS)</code>确保一个简单的值，例如<code>10</code>实际使用的值<code>10s</code>。</p><p>分隔字符串转换允许您将简单绑定<code>String</code>到<code>Collection</code>或<code>Array</code>不必分割逗号。例如，LDAP <code>base-dn</code> 属性用 <code>@Delimiter(Delimiter.NONE)</code>，所以 LDAP DN（通常包含逗号）不会被错误解释。</p><h3 id="Gradle-插件"><a href="#Gradle-插件" class="headerlink" title="Gradle 插件"></a>Gradle 插件</h3><p>Spring Boot 的 Gradle 插件已在很大程度上进行了重新编写，以实现<a href="https://github.com/spring-projects/spring-boot/issues?utf8=%E2%9C%93&amp;q=label%3A%22theme%3A%20gradle-plugin%22%20milestone%3A2.0.0.M1%20" target="_blank" rel="noopener">许多重大改进</a>。您可以在其<a href="http://docs.spring.io/spring-boot/docs/2.0.x-SNAPSHOT/gradle-plugin/reference" target="_blank" rel="noopener">参考文献</a>和 <a href="https://docs.spring.io/spring-boot/docs/2.0.0.BUILD-SNAPSHOT/gradle-plugin/api" target="_blank" rel="noopener">API</a> 文档中阅读关于插件功能的更多信息。</p><p>Spring Boot 现在需要 Gradle 4.x. 如果您要升级使用 Gradle 的项目，请查看<a href="https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-2.0-Migration-Guide" target="_blank" rel="noopener">迁移指南</a>。</p><h3 id="Kotlin"><a href="#Kotlin" class="headerlink" title="Kotlin"></a>Kotlin</h3><p>Spring Boot 2.0 现在包含对 Kotlin 1.2.x 的支持，并提供了<code>runApplication</code> ，一个使用 Kotlin 运行 Spring Boot 应用程序的方法。我们还公开和利用了 Kotlin 对其他 Spring 项目（如Spring Framework，Spring Data 和 Reactor）已添加到其最近版本中的支持。</p><p>有关更多信息，请参阅<a href="http://docs.spring.io/spring-boot/docs/2.0.x-SNAPSHOT/reference/htmlsingle/#boot-features-kotlin" target="_blank" rel="noopener">参考文档</a>的<a href="http://docs.spring.io/spring-boot/docs/2.0.x-SNAPSHOT/reference/htmlsingle/#boot-features-kotlin" target="_blank" rel="noopener">Kotlin支持部分</a>。</p><h3 id="Actuator-改进"><a href="#Actuator-改进" class="headerlink" title="Actuator 改进"></a>Actuator 改进</h3><p>在 Spring Boot 2.0 中 Actuator endpoints 有很大的改进。所有 HTTP Actuator endpoints 现在都在该<code>/actuator</code>路径下公开，并且生成的 JSON 有效负载得到了改进。</p><p>我们现在也不会在默认情况下暴露很多端点。如果您要升级现有的 Spring Boot 1.5 应用程序，请务必查看<a href="https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-2.0-Migration-Guide" target="_blank" rel="noopener">迁移指南</a>并特别注意该<code>management.endpoints.web.exposure.include</code>属性。</p><h4 id="Actuator-JSON"><a href="#Actuator-JSON" class="headerlink" title="Actuator JSON"></a>Actuator JSON</h4><p>Spring Boot 2.0 改进了从许多端点返回的 JSON 有效负载。</p><p>现在许多端点都具有更精确地反映底层数据的 JSON。例如，<code>/actuator/conditions</code>终端（<code>/autoconfig</code>在Spring Boot 1.5中）现在有一个顶级<code>contexts</code>密钥来将结果分组<code>ApplicationContext</code>。</p><p>现在还使用 <a href="https://projects.spring.io/spring-restdocs/" target="_blank" rel="noopener">Spring REST Docs</a> 生成了广泛的 <a href="https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/actuator-api/html/" target="_blank" rel="noopener">REST API </a> <a href="https://projects.spring.io/spring-restdocs/" target="_blank" rel="noopener">文档，</a>并随每个版本发布。</p><h4 id="Jersey-and-WebFlux-支持"><a href="#Jersey-and-WebFlux-支持" class="headerlink" title="Jersey and WebFlux 支持"></a>Jersey and WebFlux 支持</h4><p>除了支持 Spring MVC 和 JMX，您现在可以在开发 Jersey 或 WebFlux 应用程序时访问执行器端点。Jersey 支持通过自定义 Jersey 提供<code>Resource</code>，WebFlux 使用自定义<code>HandlerMapping</code>。</p><h4 id="Hypermedia-links"><a href="#Hypermedia-links" class="headerlink" title="Hypermedia links"></a>Hypermedia links</h4><p>该<code>/actuator</code>端点现在提供了一个 HAL 格式的响应提供链接到所有活动端点（即使你没有 Spring HATEOAS 在classpath）。</p><h4 id="Actuator-Endpoints"><a href="#Actuator-Endpoints" class="headerlink" title="Actuator @Endpoints"></a>Actuator @Endpoints</h4><p>为了支持 Spring MVC，JMX，WebFlux 和 Jersey，我们为 Actuator @Endpoints 开发了一种新的编程模型。该<code>@Endpoint</code>注解可以与<code>@ReadOperation</code>，<code>@WriteOperation</code> 和 <code>@DeleteOperation</code> 组合使用开发 endpoints。</p><p>您还可以使用<code>@EndpointWebExtension</code>或<code>@EndpointJmxExtension</code>编写技术特定的增强功能到 endpoints。详细信息请参阅<a href="http://docs.spring.io/spring-boot/docs/2.0.x-SNAPSHOT/reference/htmlsingle/#production-ready-endpoints-custom" target="_blank" rel="noopener">更新的参考文档</a>。</p><h4 id="Micrometer"><a href="#Micrometer" class="headerlink" title="Micrometer"></a>Micrometer</h4><p>Spring Boot 2.0 不再提供自己的指标 API。相反，我们依靠 <a href="https://micrometer.io/" target="_blank" rel="noopener">micrometer.io</a> 来满足所有应用程序监视需求。</p><p>Micrometer 包括尺寸指标的支持，当与尺寸监测系统配对时，尺寸指标可以有效访问特定的指定度量标准，并且可以在其尺寸范围内向下钻取。</p><p>指标可以输出到各种系统和开箱即用的 Spring Boot 2.0，为 Atlas，Datadog，Ganglia，Graphite，Influx，JMX，New Relic，Prometheus，SignalFx，StatsD 和 Wavefront 提供支持。另外还可以使用简单的内存中度量标准。</p><p>集成随 JVM 指标（包括 CPU，内存，线程和 GC），Logback，Tomcat，Spring MVC＆提供<code>RestTemplate</code>。</p><p>有关更多详细信息，请参阅参考文档的更新<a href="http://docs.spring.io/spring-boot/docs/2.0.x-SNAPSHOT/reference/htmlsingle/#production-ready-metrics" target="_blank" rel="noopener">“指标”部分</a>。</p><h3 id="数据支持"><a href="#数据支持" class="headerlink" title="数据支持"></a>数据支持</h3><p>除了上面提到的 <code>Reactive Spring Data</code> 支持外，在数据领域还进行了其他一些更新和改进。</p><h4 id="HikariCP"><a href="#HikariCP" class="headerlink" title="HikariCP"></a>HikariCP</h4><p>Spring Boot 2.0 中的默认数据库池技术已从 Tomcat Pool 切换到 HikariCP。我们发现 Hakari 提供了卓越的性能，我们的许多用户更喜欢 Tomcat Pool。</p><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>数据库初始化逻辑在 Spring Boot 2.0 中已经合理化。Spring Batch，Spring Integration，Spring Session 和 Quartz的初始化现在仅在使用嵌入式数据库时才会默认发生。该<code>enabled</code>属性已被替换为更具表现力枚举。例如，如果你想一直执行 Spring Batch 的初始化，您可以设置<code>spring.batch.initialize-schema=always</code>。</p><p>如果 Flyway 或 Liquibase 正在管理您的 DataSource 的模式，并且您正在使用嵌入式数据库，Spring Boot 现在会自动关闭 Hibernate 的自动 DDL 功能。</p><h4 id="JOOQ"><a href="#JOOQ" class="headerlink" title="JOOQ"></a>JOOQ</h4><p>Spring Boot 2.0 现在基于 DataSource 自动检测 JOOQ 方言（类似于为 JPA 方言所做的）。<code>@JooqTest</code>是新引入的注解用来简化那些只有 JOOQ 必须被使用的测试。</p><h4 id="JdbcTemplate"><a href="#JdbcTemplate" class="headerlink" title="JdbcTemplate"></a>JdbcTemplate</h4><p>Spring Boot 自动配置的 <code>JdbcTemplate</code> 现在可以通过 <code>spring.jdbc.template</code> 属性进行自定义。此外，<code>NamedParameterJdbcTemplate</code>自动配置的内容会重用<code>JdbcTemplate</code>。</p><h4 id="Spring-Data-Web-配置"><a href="#Spring-Data-Web-配置" class="headerlink" title="Spring Data Web 配置"></a>Spring Data Web 配置</h4><p>Spring Boot 公开了一个新的<code>spring.data.web</code>配置名称空间，可以轻松配置分页和排序。</p><h4 id="InfluxDB"><a href="#InfluxDB" class="headerlink" title="InfluxDB"></a>InfluxDB</h4><p>Spring Boot 现在自动配置开源时间序列数据库 InfluxDB。要启用 InfluxDB 支持，您需要设置一个<code>spring.influx.url</code>属性，并将其包含<code>influxdb-java</code>在您的类路径中。</p><h4 id="Flyway-Liquibase-灵活配置"><a href="#Flyway-Liquibase-灵活配置" class="headerlink" title="Flyway/Liquibase 灵活配置"></a>Flyway/Liquibase 灵活配置</h4><p>如果仅提供自定义<code>url</code>或<code>user</code>属性，则 Flyway 和 Liquibase 的自动配置现在将重用标准数据源属性，而不是忽略它们。这使您可以创建一个自定义的数据源，仅用于所需信息的迁移。</p><h4 id="Hibernate"><a href="#Hibernate" class="headerlink" title="Hibernate"></a>Hibernate</h4><p>现在支持自定义 Hibernate 命名策略。对于高级场景，现在可以在上下文中定义<code>ImplicitNamingStrategy</code>或<code>PhysicalNamingStrategy</code>使用常规 bean。</p><p>现在也可以通过公开<code>HibernatePropertiesCustomizer</code>bean 来更加细致地定制 Hibernate 使用的属性。</p><h4 id="MongoDB-客户端自定义"><a href="#MongoDB-客户端自定义" class="headerlink" title="MongoDB 客户端自定义"></a>MongoDB 客户端自定义</h4><p>现在可以通过定义一个类型的 bean 来为 Spring Boot 自动配置的 Mongo 客户端应用高级定制<code>MongoClientSettingsBuilderCustomizer</code>。</p><h4 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h4><p>现在可以使用<code>spring.cache.redis.*</code>属性配置 Redis 的缓存默认值。</p><h3 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h3><p>除了上面提到的 WebFlux 和 WebFlux.fn 支持之外，还在开发 Web 应用程序时进行了以下改进。</p><h4 id="上下文路径记录"><a href="#上下文路径记录" class="headerlink" title="上下文路径记录"></a>上下文路径记录</h4><p>当使用嵌入式容器时，当您的应用程序启动时，上下文路径将与 HTTP 端口一起记录。例如，嵌入式 Tomcat 现在看起来像这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Tomcat 在端口上启动：8080（http），其上下文路径为 &apos;/foo&apos;</span><br></pre></td></tr></table></figure><h4 id="Web过滤器初始化"><a href="#Web过滤器初始化" class="headerlink" title="Web过滤器初始化"></a>Web过滤器初始化</h4><p>Web 过滤器现在在所有支持的容器上急切地初始化。</p><h4 id="Thymeleaf"><a href="#Thymeleaf" class="headerlink" title="Thymeleaf"></a>Thymeleaf</h4><p>Thymeleaf 初始化现在包括<code>thymeleaf-extras-java8time</code>，提供<code>javax.time</code>类型支持。</p><h4 id="JSON-支持"><a href="#JSON-支持" class="headerlink" title="JSON 支持"></a>JSON 支持</h4><p>新的<code>spring-boot-starter-json</code>起始者收集必要的位以读取和写入 JSON。它不仅提供了<code>jackson-databind</code>与Java8 工作时，也是有用的模块：<code>jackson-datatype-jdk8</code>，<code>jackson-datatype-jsr310</code>和<code>jackson-module-parameter-names</code>。这个新的起动器现在被用于<code>jackson-databind</code>之前定义的地方。</p><p>如果您更喜欢 Jackson 之外的其他产品，我们对 GSON 的支持在 Spring Boot 2.0  已经大大提高。我们还引入了对 JSON-B 的支持（包括 JSON-B 测试支持）。</p><h3 id="Quartz"><a href="#Quartz" class="headerlink" title="Quartz"></a>Quartz</h3><p>自动配置支持目前包含了  <a href="http://www.quartz-scheduler.org/" target="_blank" rel="noopener">Quartz Scheduler</a>。我们还添加了新的<code>spring-boot-starter-quartz</code> 初始化 POM。</p><p>您可以使用内存<code>JobStores</code>中或完整的基于 JDBC 的存储。所有<code>JobDetail</code>，<code>Calendar</code>并<code>Trigger</code>从你的 Spring应用程序上下文豆将自动注册<code>Scheduler</code>。</p><p>有关更多详细信息，请阅读参考文档的新<a href="http://docs.spring.io/spring-boot/docs/2.0.x-SNAPSHOT/reference/htmlsingle/#boot-features-quartz" target="_blank" rel="noopener">“Quartz Scheduler”部分</a>。</p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>对 Spring Boot 2.0 中提供的测试支持进行了一些补充和调整：</p><ul><li><code>@WebFluxTest</code>已添加新注释以支持 WebFlux 应用程序的“切片”测试。</li><li><code>Converter</code>和<code>GenericConverter</code>豆类现在自动扫描<code>@WebMvcTest</code>和<code>@WebFluxTest</code>。</li><li><code>@AutoConfigureWebTestClient</code>已经添加了一个注释来提供一个<code>WebTestClient</code>bean 供测试使用。注释会自动应用于<code>@WebFluxTest</code>测试。</li><li>增加了一个新的<code>ApplicationContextRunner</code>测试实用程序，可以很容易地测试您的自动配置。我们已将大部分内部测试套件移至此新模型。详细信息请参阅<a href="http://docs.spring.io/spring-boot/docs/2.0.x-SNAPSHOT/reference/htmlsingle/#boot-features-test-autoconfig" target="_blank" rel="noopener">更新的文档</a>。</li></ul><h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><p>除了上面列出的变化外，还有很多小的调整和改进，包括：</p><ul><li><code>@ConditionalOnBean</code>现在在确定是否满足条件时使用逻辑<code>AND</code>而不是逻辑<code>OR</code>。</li><li>无条件类现在包含在自动配置报告中。</li><li>该<code>spring</code>CLI 应用程序现在包括<code>encodepassword</code>可用于创建 Spring Security 的兼容散列密码命令。</li><li>计划任务（即 <code>@EnableScheduling</code>）可以使用<code>scheduledtasks</code>执行器端点进行审查。</li><li>该<code>loggers</code>驱动器终端现在允许你重新设置一个记录器级别为它的默认。</li><li>Spring Session 用户现在可以通过<code>sessions</code>执行器端点查找和删除会话。</li><li>使用<code>spring-boot-starter-parent</code>现在基于 Maven 的应用程序<code>-parameters</code>默认使用标志。</li><li>我们的构建现在使用 <a href="http://concourse.ci/" target="_blank" rel="noopener">concourse</a> 的 CI 和我们的项目 POM 文件已被重构，使它们更简单的。</li></ul><h3 id="动画-ASCII-艺术"><a href="#动画-ASCII-艺术" class="headerlink" title="动画 ASCII 艺术"></a>动画 ASCII 艺术</h3><p>最后，为了好玩，Spring Boot 2.0 现在支持动画 GIF 横幅。</p><p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1fp34jnoouij30dc093dfp.jpg" alt="animated-ascii-art"></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="">https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-2.0-Release-Notes</a></p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fp3jkmizmpj30o00didgn.jpg" alt=""></p><h3 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h3><p>1、<a href="http://www.54tianzhisheng.cn/2018/03/06/SpringBoot2-Migration-Guide/" target="_blank" rel="noopener">Spring Boot 2.0系列文章(一)：Spring Boot 2.0 迁移指南</a></p><p>2、<a href="http://www.54tianzhisheng.cn/2018/03/06/SpringBoot2-new-features/" target="_blank" rel="noopener">Spring Boot 2.0系列文章(二)：Spring Boot 2.0 新特性详解</a></p><p>3、<a href="http://www.54tianzhisheng.cn/2018/04/13/Spring_Boot_2.0_Configuration_Changelog/" target="_blank" rel="noopener">Spring Boot 2.0系列文章(三)：Spring Boot 2.0 配置改变</a></p><p>4、<a href="http://www.54tianzhisheng.cn/2018/04/15/springboot2_code/" target="_blank" rel="noopener">Spring Boot 2.0系列文章(四)：Spring Boot 2.0 源码阅读环境搭建</a></p><p>5、<a href="http://www.54tianzhisheng.cn/2018/04/18/spring_boot2_project/" target="_blank" rel="noopener">Spring Boot 2.0系列文章(五)：Spring Boot 2.0 项目源码结构预览</a></p><p>6、<a href="http://www.54tianzhisheng.cn/2018/04/19/SpringBootApplication-annotation/" target="_blank" rel="noopener">Spring Boot 2.0系列文章(六)：Spring boot 2.0 中 SpringBootApplication 注解详解</a></p><p>7、<a href="http://www.54tianzhisheng.cn/2018/04/30/springboot_SpringApplication/" target="_blank" rel="noopener">Spring Boot 2.0系列文章(七)：SpringApplication 深入探索</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://ws2.sinaimg.cn/large/006tKfTcgy1fp34jn0xb3j31hc140aji.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;在 3 月 1 号，Spring Boot&lt;code&gt;2.0.0.RELEASE&lt;/code&gt;正式发布，这是 Spring Boot1.0 发布 4 年之后第一次重大修订，因此有多的新功能和特性值得大家期待！下面带大家了解下 Spring Boot 2.0 中的新特性。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="SpringBoot" scheme="http://yoursite.com/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>小马哥 《Java 微服务实践 - Spring Cloud 系列》强烈推荐</title>
    <link href="http://yoursite.com/2018/03/04/springcloud-vedio/"/>
    <id>http://yoursite.com/2018/03/04/springcloud-vedio/</id>
    <published>2018-03-03T16:00:00.000Z</published>
    <updated>2018-03-06T16:22:50.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fp0tsq2q8vj30dc07idg8.jpg" alt="u=1933229855,2353978820&amp;fm=27&amp;gp=0"></p><h3 id="视频内容"><a href="#视频内容" class="headerlink" title="视频内容"></a>视频内容</h3><p>Spring Cloud 系列课程致力于以实战的方式覆盖所有功能特性，结合小马哥十余年的学习方法和工作经验，体会作者设计意图。结合源码加深理解，最终达到形成系统性的知识和技术体系的目的。</p><a id="more"></a><h3 id="讲师介绍"><a href="#讲师介绍" class="headerlink" title="讲师介绍"></a>讲师介绍</h3><blockquote><p><strong>小马哥</strong>，一线互联网公司技术专家，十余年 Java EE 从业经验，架构师、微服务布道师。目前主要负责微服务技术实施、架构衍进、基础设施构建等。重点关注云计算、微服务以及软件架构等领域。通过 SUN Java（SCJP、SCWCD、SCBCD）以及 Oracle OCA 等的认证。</p></blockquote><h3 id="视频列表"><a href="#视频列表" class="headerlink" title="视频列表"></a>视频列表</h3><p>1、<a href="https://segmentfault.com/l/1500000011384570" target="_blank" rel="noopener">Java 微服务实践 - Spring Cloud 系列（一）云原生应用</a></p><p>2、<a href="https://segmentfault.com/l/1500000011385195" target="_blank" rel="noopener">Java 微服务实践 - Spring Cloud 系列（二）配置客户端</a></p><p>3、<a href="https://segmentfault.com/l/1500000011385904" target="_blank" rel="noopener">Java 微服务实践 - Spring Cloud 系列（三）配置服务器</a></p><p>4、<a href="https://segmentfault.com/l/1500000011386051" target="_blank" rel="noopener">Java 微服务实践 - Spring Cloud 系列（四）服务发现/注册</a></p><p>5、<a href="https://segmentfault.com/l/1500000011386082" target="_blank" rel="noopener">Java 微服务实践 - Spring Cloud 系列（五）高可用服务治理</a></p><p>6、<a href="https://segmentfault.com/l/1500000011386110" target="_blank" rel="noopener">Java 微服务实践 - Spring Cloud 系列（六）负载均衡</a></p><p>7、<a href="https://segmentfault.com/l/1500000011386180" target="_blank" rel="noopener">Java 微服务实践 - Spring Cloud 系列（七）Ribbon 源码</a></p><p>8、<a href="https://segmentfault.com/l/1500000011386237" target="_blank" rel="noopener">Java 微服务实践 - Spring Cloud 系列（八）服务短路</a></p><p>9、<a href="https://segmentfault.com/l/1500000011386273" target="_blank" rel="noopener">Java 微服务实践 - Spring Cloud 系列（九）Hystrix源码</a></p><p>10、<a href="https://segmentfault.com/l/1500000011386274" target="_blank" rel="noopener">Java 微服务实践 - Spring Cloud 系列（十）服务调用</a></p><p>11、<a href="https://segmentfault.com/l/1500000011386451" target="_blank" rel="noopener">Java 微服务实践 - Spring Cloud 系列（十一）服务网关</a></p><p>12、<a href="https://segmentfault.com/l/1500000011386642" target="_blank" rel="noopener">Java 微服务实践 - Spring Cloud 系列（十二）消息驱动整合</a></p><p>13、<a href="https://segmentfault.com/l/1500000011386655" target="_blank" rel="noopener">Java 微服务实践 - Spring Cloud 系列（十三）Binder实现</a></p><p>14、<a href="https://segmentfault.com/l/1500000011386685" target="_blank" rel="noopener">Java 微服务实践 - Spring Cloud 系列（十四）消息总线</a></p><p>15、<a href="https://segmentfault.com/l/1500000011386721" target="_blank" rel="noopener">Java 微服务实践 - Spring Cloud 系列（十五）分布式应用跟踪</a></p><p>16、<a href="https://segmentfault.com/l/1500000011386751" target="_blank" rel="noopener">Java 微服务实践 - Spring Cloud 系列（十六）系列回顾</a></p><h3 id="购买链接"><a href="#购买链接" class="headerlink" title="购买链接"></a>购买链接</h3><p>你可以使用下面链接购买（有优惠的哦）</p><p><strong><a href="https://segmentfault.com/ls/1650000011386794?r=bPrFW3" target="_blank" rel="noopener">https://segmentfault.com/ls/1650000011386794?r=bPrFW3</a></strong></p><p>或者你也可以扫描下面的二维码购买（同样也有优惠的哦）</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fp0td2936xj308c0aujsd.jpg" alt="sc视频"></p><h3 id="课程评价"><a href="#课程评价" class="headerlink" title="课程评价"></a>课程评价</h3><blockquote><p>1、小马哥讲的很好，实践和原理一起结合讲，理解的很深刻。<br>期待小马哥的下一个高并发的系列讲座，还有那本万众瞩目的新书<br>2、<br>这些系列课程怎么说呢，就我来说其实学的不是知识，是学习方法。小马哥厉害的，给个赞。<br>3、满满的赞，社会套路太多，须加强学习，期待下期与小马哥相逢<br>4、基本是都是守者直播时间，跟着 Spring Boot 系列和 Spring Cloud 系列的课程，小马哥讲得很有启发性。讲一种技术的从哪里来，解决了什么问题，以及优缺点。讲源码又不仅限制于源码。总的来说值得花时间来学习和讨论的。值得推荐，五星好评。<br>5、可以的，解答问题很耐心。从你这学到了浏览JSR等之类的规范，在用一些框架的时候发现国外的，很多都实现了JSR，比如spring batch，而国内的话，个人觉得这方面稍微差了点，这方面我们还要努力，加油！</p></blockquote><p>以上评价摘自 segmentfault</p><h3 id="相关课程"><a href="#相关课程" class="headerlink" title="相关课程"></a>相关课程</h3><p><strong>Java 微服务实践 - Spring Boot 系列</strong></p><p>优惠地址：<strong><a href="https://segmentfault.com/ls/1650000011063780?r=bPrFW3" target="_blank" rel="noopener">https://segmentfault.com/ls/1650000011063780?r=bPrFW3</a></strong></p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fp0td375okj308c0augml.jpg" alt="sb视频"></p><p>另外：还有这个 <strong>Java 微服务实践 - Spring Boot / Spring Cloud</strong>，算是两个的合集了，合买的话优惠更大。</p><p>优惠地址：<strong><a href="https://segmentfault.com/ls/1650000011387052?r=bPrFW3" target="_blank" rel="noopener">https://segmentfault.com/ls/1650000011387052?r=bPrFW3</a></strong></p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fp0td1fomnj308c0au75b.jpg" alt="sb-sc合集"></p><h3 id="关注我"><a href="#关注我" class="headerlink" title="关注我"></a>关注我</h3><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fp0t1k9vd8j3076076mxo.jpg" alt="C6LG3mGa12"></p><p>建了个不错的微信群，如果有感兴趣的可以加我微信，然后拉你进群交流。</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fp0t1jn6s4j30qi0z10x1.jpg" alt="1520091522031"></p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fp3jkmizmpj30o00didgn.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://ws4.sinaimg.cn/large/006tNc79gy1fp0tsq2q8vj30dc07idg8.jpg&quot; alt=&quot;u=1933229855,2353978820&amp;amp;fm=27&amp;amp;gp=0&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;视频内容&quot;&gt;&lt;a href=&quot;#视频内容&quot; class=&quot;headerlink&quot; title=&quot;视频内容&quot;&gt;&lt;/a&gt;视频内容&lt;/h3&gt;&lt;p&gt;Spring Cloud 系列课程致力于以实战的方式覆盖所有功能特性，结合小马哥十余年的学习方法和工作经验，体会作者设计意图。结合源码加深理解，最终达到形成系统性的知识和技术体系的目的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="SpringCloud" scheme="http://yoursite.com/tags/SpringCloud/"/>
    
      <category term="微服务" scheme="http://yoursite.com/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>小马哥 《Java 微服务实践 - Spring Boot 系列》强烈推荐</title>
    <link href="http://yoursite.com/2018/03/04/springboot-vedio/"/>
    <id>http://yoursite.com/2018/03/04/springboot-vedio/</id>
    <published>2018-03-03T16:00:00.000Z</published>
    <updated>2018-03-06T16:20:40.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fp0ts4i1hfj30id08t3yn.jpg" alt="timg"></p><h3 id="视频内容"><a href="#视频内容" class="headerlink" title="视频内容"></a>视频内容</h3><p>Java 微服务实践 - Spring Boot 为系列讲座，二十节专题直播，时长高达50个小时，包括目前最流行技术，深入源码分析，授人以渔的方式，帮助初学者深入浅出地掌握，为高阶从业人员抛砖引玉。</p><a id="more"></a><h3 id="讲师介绍"><a href="#讲师介绍" class="headerlink" title="讲师介绍"></a>讲师介绍</h3><blockquote><p><strong>小马哥</strong>，一线互联网公司技术专家，十余年 Java EE 从业经验，架构师、微服务布道师。目前主要负责微服务技术实施、架构衍进、基础设施构建等。重点关注云计算、微服务以及软件架构等领域。通过 SUN Java（SCJP、SCWCD、SCBCD）以及 Oracle OCA 等的认证。</p></blockquote><h3 id="视频列表"><a href="#视频列表" class="headerlink" title="视频列表"></a>视频列表</h3><p>1、<a href="https://segmentfault.com/l/1500000009515571" target="_blank" rel="noopener">Java 微服务实践 - Spring Boot 系列（一）初体验</a></p><p>2、<a href="https://segmentfault.com/l/1500000009659111" target="_blank" rel="noopener">Java 微服务实践 - Spring Boot 系列（二） Web篇（上）</a></p><p>3、<a href="https://segmentfault.com/l/1500000009767025" target="_blank" rel="noopener">Java 微服务实践 - Spring Boot 系列（三）Web篇（中）</a></p><p>4、<a href="https://segmentfault.com/l/1500000009830944" target="_blank" rel="noopener"> Java 微服务实践 - Spring Boot 系列（四）Web篇（下）</a></p><p>5、<a href="https://segmentfault.com/l/1500000009844304" target="_blank" rel="noopener">Java 微服务实践 - Spring Boot 系列（五）嵌入式Web容器</a></p><p>6、<a href="https://segmentfault.com/l/1500000009904190" target="_blank" rel="noopener">Java 微服务实践 - Spring Boot 系列（六）数据库 JDBC</a></p><p>7、<a href="https://segmentfault.com/l/1500000009952220" target="_blank" rel="noopener"> Java 微服务实践 - Spring Boot 系列（七）MyBatis</a></p><p>8、<a href="https://segmentfault.com/l/1500000009952527" target="_blank" rel="noopener"> Java 微服务实践 - Spring Boot 系列（八）JPA</a></p><p>9、<a href="https://segmentfault.com/l/1500000009957330" target="_blank" rel="noopener"> Java 微服务实践 - Spring Boot 系列（九）NoSQL</a></p><p>10、<a href="https://segmentfault.com/l/1500000009970812" target="_blank" rel="noopener"> Java 微服务实践 - Spring Boot 系列（十）缓存</a></p><p>11、<a href="https://segmentfault.com/l/1500000009971600" target="_blank" rel="noopener"> Java 微服务实践 - Spring Boot 系列（十一）消息</a></p><p>12、<a href="https://segmentfault.com/l/1500000009971716" target="_blank" rel="noopener"> Java 微服务实践 - Spring Boot 系列（十二）验证</a></p><p>13、<a href="https://segmentfault.com/l/1500000009971764" target="_blank" rel="noopener">Java 微服务实践 - Spring Boot 系列（十三）WebSocket</a></p><p>14、<a href="https://segmentfault.com/l/1500000009978309" target="_blank" rel="noopener"> Java 微服务实践- Spring Boot 系列（十四）WebService</a></p><p>15、<a href="https://segmentfault.com/l/1500000009978481" target="_blank" rel="noopener"> Java 微服务实践 - Spring Boot 系列（十五）安全</a></p><p>16、<a href="https://segmentfault.com/l/1500000009978585" target="_blank" rel="noopener">Java 微服务实践 - Spring Boot 系列（十六）日志</a></p><p>17、<a href="https://segmentfault.com/l/1500000009978661" target="_blank" rel="noopener">Java 微服务实践 - Spring Boot 系列（十七）监管</a></p><p>18、<a href="https://segmentfault.com/l/1500000009978729" target="_blank" rel="noopener">Java 微服务实践 - Spring Boot 系列（十八）配置</a></p><p>19、<a href="https://segmentfault.com/l/1500000009978826" target="_blank" rel="noopener"> Java 微服务实践 - Spring Boot 系列（十九）测试</a></p><p>20、<a href="https://segmentfault.com/l/1500000009978904" target="_blank" rel="noopener">Java 微服务实践 - Spring Boot 系列（二十）自定义启动器</a></p><h3 id="购买链接"><a href="#购买链接" class="headerlink" title="购买链接"></a>购买链接</h3><p>你可以使用下面链接购买（有优惠的哦）</p><p><strong><a href="https://segmentfault.com/ls/1650000011063780?r=bPrFW3" target="_blank" rel="noopener">https://segmentfault.com/ls/1650000011063780?r=bPrFW3</a></strong></p><p>或者你也可以扫描下面的二维码购买（同样也有优惠的哦）</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fp0t6idjt0j308c0augml.jpg" alt="sb视频"></p><h3 id="课程评价"><a href="#课程评价" class="headerlink" title="课程评价"></a>课程评价</h3><blockquote><p>1、小马哥讲的好详细，以前似是而非的东东，现在都懂了<br>2、学到了怎么使用，也学到了怎么自定义校验，知其然也知其所以然<br>3、6666 起飞了 websocket 之前看了写 这次更加深入和标准化 感谢小马哥带来的干货<br>4、深入浅出，思路清晰。<br>5、深入浅出啊。非常好，而且如果有问题，不管简单还是难的，都从不同的角度和层次来解答了。学到的东西非常多。谢谢。</p></blockquote><p>以上评价摘自 segmentfault</p><h3 id="相关课程"><a href="#相关课程" class="headerlink" title="相关课程"></a>相关课程</h3><p><strong>Java 微服务实践 - Spring Cloud 系列</strong></p><p>优惠地址：<strong><a href="https://segmentfault.com/ls/1650000011386794?r=bPrFW3" target="_blank" rel="noopener">https://segmentfault.com/ls/1650000011386794?r=bPrFW3</a></strong></p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fp0tc1p3e1j308c0aujsd.jpg" alt="sc视频"></p><p>另外：还有这个 <strong>Java 微服务实践 - Spring Boot / Spring Cloud</strong>，算是两个的合集了，合买的话优惠更大。</p><p>优惠地址：<strong><a href="https://segmentfault.com/ls/1650000011387052?r=bPrFW3" target="_blank" rel="noopener">https://segmentfault.com/ls/1650000011387052?r=bPrFW3</a></strong></p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fp0tc1df8vj308c0au75b.jpg" alt="sb-sc合集"></p><h3 id="关注我"><a href="#关注我" class="headerlink" title="关注我"></a>关注我</h3><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fp0t1k9vd8j3076076mxo.jpg" alt="C6LG3mGa12"></p><p>建了个不错的微信群，如果有感兴趣的可以加我微信，然后拉你进群交流。</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fp0t1jn6s4j30qi0z10x1.jpg" alt="1520091522031"></p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fp3jkmizmpj30o00didgn.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://ws3.sinaimg.cn/large/006tNc79gy1fp0ts4i1hfj30id08t3yn.jpg&quot; alt=&quot;timg&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;视频内容&quot;&gt;&lt;a href=&quot;#视频内容&quot; class=&quot;headerlink&quot; title=&quot;视频内容&quot;&gt;&lt;/a&gt;视频内容&lt;/h3&gt;&lt;p&gt;Java 微服务实践 - Spring Boot 为系列讲座，二十节专题直播，时长高达50个小时，包括目前最流行技术，深入源码分析，授人以渔的方式，帮助初学者深入浅出地掌握，为高阶从业人员抛砖引玉。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="SpringBoot" scheme="http://yoursite.com/tags/SpringBoot/"/>
    
      <category term="微服务" scheme="http://yoursite.com/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>《深入理解 Java 内存模型》读书笔记</title>
    <link href="http://yoursite.com/2018/02/28/Java-Memory-Model/"/>
    <id>http://yoursite.com/2018/02/28/Java-Memory-Model/</id>
    <published>2018-02-27T16:00:00.000Z</published>
    <updated>2018-04-23T14:14:52.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fow7l5mj64j31hc0zbh9n.jpg" alt="fairyland-canyon-1632749_1920"></p><h3 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h3><p>《深入理解 Java 内存模型》程晓明著，该书在以前看过一遍，现在学的东西越多，感觉那块越重要，于是又再细看一遍，于是便有了下面的读书笔记总结。全书页数虽不多，内容讲得挺深的。细看的话，也是挺花时间的，看完收获绝对挺大的。也建议 Java 开发者都去看看。里面主要有 Java 内存模型的基础、重排序、顺序一致性、Volatile 关键字、锁、final。本文参考书中内容。</p><a id="more"></a><h3 id="关注我"><a href="#关注我" class="headerlink" title="关注我"></a>关注我</h3><p>如果你想查看这本书可以关注我的公众号: <strong>zhisheng</strong> ，然后里面回复关键字 <strong>JMM</strong> 可以查看我分享的百度云链接。</p><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180103/C6LG3mGa12.jpg" alt="mark"></p><p>转载请务必注明原创地址为：<a href="http://www.54tianzhisheng.cn/2018/02/28/Java-Memory-Model/" target="_blank" rel="noopener">http://www.54tianzhisheng.cn/2018/02/28/Java-Memory-Model/</a></p><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><h4 id="并发编程的模型分类"><a href="#并发编程的模型分类" class="headerlink" title="并发编程的模型分类"></a>并发编程的模型分类</h4><p>在并发编程需要处理的两个关键问题是：<strong>线程之间如何通信</strong> 和 <strong>线程之间如何同步</strong>。</p><h5 id="通信"><a href="#通信" class="headerlink" title="通信"></a>通信</h5><p><strong>通信</strong> 是指线程之间以何种机制来交换信息。在命令式编程中，线程之间的通信机制有两种：<strong>共享内存</strong> 和 <strong>消息传递</strong>。</p><p>在<strong>共享内存</strong>的并发模型里，线程之间共享程序的公共状态，线程之间通过写-读内存中的<strong>公共状态</strong>来<strong>隐式</strong>进行通信。</p><p>在<strong>消息传递</strong>的并发模型里，线程之间没有公共状态，线程之间必须通过明确的<strong>发送消息</strong>来<strong>显式</strong>进行通信。</p><h5 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h5><p><strong>同步</strong> 是指程序用于控制不同线程之间操作发生相对顺序的机制。</p><p>在<strong>共享内存</strong>的并发模型里，同步是<strong>显式</strong>进行的。程序员必须显式指定某个方法或某段代码需要在线程之间<strong>互斥执行</strong>。</p><p>在<strong>消息传递</strong>的并发模型里，由于消息的发送必须在消息的接收之前，因此同步是<strong>隐式</strong>进行的。</p><p>Java 的并发采用的是共享内存模型，Java 线程之间的通信总是隐式进行，整个通信过程对程序员完全透明。</p><h4 id="Java-内存模型的抽象"><a href="#Java-内存模型的抽象" class="headerlink" title="Java 内存模型的抽象"></a>Java 内存模型的抽象</h4><p>在 Java 中，所有实例域、静态域 和 数组元素存储在堆内存中，堆内存在线程之间共享。局部变量、方法定义参数 和 异常处理器参数 不会在线程之间共享，它们不会有内存可见性问题，也不受内存模型的影响。</p><p>Java 线程之间的通信由 Java 内存模型（JMM）控制。JMM 决定了一个线程对共享变量的写入何时对另一个线程可见。从抽象的角度来看，JMM 定义了线程与主内存之间的抽象关系：线程之间的共享变量存储在主内存中，每一个线程都有一个自己私有的本地内存，本地内存中存储了该变量以读／写共享变量的副本。本地内存是 JMM 的一个抽象概念，并不真实存在。</p><p>JMM 抽象示意图：</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fow7l9q3hsj30zi0rq41t.jpg" alt="jmm"></p><p>从上图来看，如果线程 A 和线程 B 要通信的话，要如下两个步骤：</p><p>1、线程 A 需要将本地内存 A 中的共享变量副本刷新到主内存去</p><p>2、线程 B 去主内存读取线程 A 之前已更新过的共享变量</p><p>步骤示意图：</p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fow7lh7qm2j30wo0ocq58.jpg" alt="tongxin"></p><p>举个例子：</p><p>本地内存 A 和 B 有主内存共享变量 X 的副本。假设一开始时，这三个内存中 X 的值都是 0。线程 A 正执行时，把更新后的 X 值（假设为 1）临时存放在自己的本地内存 A 中。当线程 A 和 B 需要通信时，线程 A 首先会把自己本地内存 A 中修改后的 X 值刷新到主内存去，此时主内存中的 X 值变为了 1。随后，线程 B 到主内存中读取线程 A 更新后的共享变量 X 的值，此时线程 B 的本地内存的 X 值也变成了 1。</p><p>整体来看，这两个步骤实质上是线程 A 再向线程 B 发送消息，而这个通信过程必须经过主内存。JMM 通过控制主内存与每个线程的本地内存之间的交互，来为 Java 程序员提供内存可见性保证。</p><h3 id="重排序"><a href="#重排序" class="headerlink" title="重排序"></a>重排序</h3><p>在执行程序时为了提高性能，编译器和处理器常常会对指令做重排序。重排序分三类：</p><p>1、<strong>编译器优化的重排序</strong>。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。</p><p>2、<strong>指令级并行的重排序</strong>。现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</p><p>3、<strong>内存系统的重排序</strong>。由于处理器使用缓存和读／写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。</p><p>从 Java 源代码到最终实际执行的指令序列，会分别经历下面三种重排序：</p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fow7l4iv44j313e07wmyw.jpg" alt="sort-again"></p><p>上面的这些重排序都可能导致多线程程序出现内存可见性问题。对于编译器，JMM 的编译器重排序规则会禁止特定类型的编译器重排序（不是所有的编译器重排序都要禁止）。对于处理器重排序，JMM 的处理器重排序规则会要求 Java 编译器在生成指令序列时，插入特定类型的内存屏障指令，通过内存屏障指令来禁止特定类型的处理器重排序（不是所有的处理器重排序都要禁止）。</p><p>JMM 属于语言级的内存模型，它确保在不同的编译器和不同的处理器平台之上，通过禁止特定类型的编译器重排序和处理器重排序，为程序员提供一致的内存可见性保证。</p><h4 id="处理器重排序"><a href="#处理器重排序" class="headerlink" title="处理器重排序"></a>处理器重排序</h4><p>现代的处理器使用<strong>写缓冲区</strong>来临时保存向内存写入的数据。写缓冲区可以保证指令流水线持续运行，它可以避免由于处理器停顿下来等待向内存写入数据而产生的延迟。同时，通过以批处理的方式刷新写缓冲区，以及合并写缓冲区中对同一内存地址的多次写，可以减少对内存总线的占用。虽然写缓冲区有这么多好处，但每个处理器上的写缓冲区，仅仅对它所在的处理器可见。这个特性会对内存操作的执行顺序产生重要的影响：处理器对内存的读/写操作的执行顺序，不一定与内存实际发生的读/写操作顺序一致！</p><p>举个例子：</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fow7l6udu0j30uc0c8zls.jpg" alt="example1"></p><p>假设处理器A和处理器B按程序的顺序并行执行内存访问，最终却可能得到 x = y = 0。具体的原因如下图所示：</p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fow7lftsaxj30wg0mcwgz.jpg" alt="exam1-ans"></p><p>处理器 A 和 B 同时把共享变量写入在写缓冲区中（A1、B1），然后再从内存中读取另一个共享变量（A2、B2），最后才把自己写缓冲区中保存的脏数据刷新到内存中（A3、B3）。当以这种时序执行时，程序就可以得到 x = y = 0 的结果。</p><p>从内存操作实际发生的顺序来看，直到处理器 A 执行 A3 来刷新自己的写缓存区，写操作 A1 才算真正执行了。虽然处理器 A 执行内存操作的顺序为：A1 -&gt; A2，但内存操作实际发生的顺序却是：A2 -&gt; A1。此时，处理器 A 的内存操作顺序被重排序了。</p><p>这里的关键是，由于<strong>写缓冲区仅对自己的处理器可见，它会导致处理器执行内存操作的顺序可能会与内存实际的操作执行顺序不一致</strong>。由于现代的处理器都会使用写缓冲区，因此现代的处理器都会允许对写-读操作重排序。</p><h4 id="内存屏障指令"><a href="#内存屏障指令" class="headerlink" title="内存屏障指令"></a>内存屏障指令</h4><p>为了保证内存可见性，Java 编译器在生成指令序列的适当位置会插入<strong>内存屏障指令</strong>来禁止特定类型的处理器重排序。JMM 把内存屏障指令分为下列四类：</p><table><thead><tr><th>屏障类型</th><th style="text-align:center">指令示例</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td>LoadLoad Barriers</td><td style="text-align:center">Load1; LoadLoad; Load2</td><td style="text-align:center">确保 Load1 数据的装载，之前于 Load2 及所有后续装载指令的装载。</td></tr><tr><td>StoreStore Barriers</td><td style="text-align:center">Store1; StoreStore; Store2</td><td style="text-align:center">确保 Store1 数据对其他处理器可见（刷新到内存），之前于 Store2 及所有后续存储指令的存储。</td></tr><tr><td>LoadStore Barriers</td><td style="text-align:center">Load1; LoadStore; Store2</td><td style="text-align:center">确保 Load1 数据装载，之前于 Store2 及所有后续的存储指令刷新到内存。</td></tr><tr><td>StoreLoad Barriers</td><td style="text-align:center">Store1; StoreLoad; Load2</td><td style="text-align:center">确保 Store1 数据对其他处理器变得可见（指刷新到内存），之前于 Load2 及所有后续装载指令的装载。<strong>StoreLoadBarriers 会使该屏障之前的所有内存访问指令（存储和装载指令）完成之后，才执行该屏障之后的内存访问指令</strong>。</td></tr></tbody></table><h4 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h4><p>JSR-133 内存模型使用 happens-before 的概念来阐述操作之间的内存可见性。在 JMM 中，如果<strong>一个操作执行的结果需要对另一个操作可见</strong>，那么这两个操作之间必须要存在 happens-before 关系。这里提到的两个操作既可以是在一个线程之内，也可以是在不同线程之间。</p><p>与程序员密切相关的 happens-before 规则如下：</p><ul><li>程序顺序规则：一个线程中的每个操作，happens-before 于该线程中的任意后续操作。</li><li>监视器锁规则：对一个监视器的解锁，happens-before 于随后对这个监视器的加锁。</li><li>volatile 变量规则：对一个 volatile 域的写，happens-before 于任意后续对这个 volatile 域的读。</li><li>传递性：如果  A happens-before B，且 B happens-before C，那么 A happens-before C。</li></ul><p>注意，两个操作之间具有 happens-before 关系，并不意味着前一个操作必须要在后一个操作之前执行！happens-before 仅仅要求前一个操作（执行的结果）对后一个操作可见，且前一个操作按顺序排在第二个操作之前（the first is visible to and ordered before the second）。</p><p>happens-before 与 JMM 的关系如下图所示：</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fow7l7e9zij312s0titdo.jpg" alt="happens-before-jmm"></p><p>如上图所示，一个 happens-before 规则对应于一个或多个编译器和处理器重排序规则。</p><h4 id="数据依赖性"><a href="#数据依赖性" class="headerlink" title="数据依赖性"></a>数据依赖性</h4><p>如果两个操作访问同一个变量，且这两个操作中有一个为写操作，此时这两个操作之间就存在数据依赖性。数据依赖分下列三种类型：</p><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">代码示例</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">写后读</td><td style="text-align:center">a = 1;   b = a;</td><td style="text-align:center">写一个变量之后，再读这个位置。</td></tr><tr><td style="text-align:center">写后写</td><td style="text-align:center">a = 1;  a = 2;</td><td style="text-align:center">写一个变量之后，再写这个变量。</td></tr><tr><td style="text-align:center">读后写</td><td style="text-align:center">a = b;  b = 1;</td><td style="text-align:center">读一个变量之后，再写这个变量。</td></tr></tbody></table><p>上面三种情况，只要重排序两个操作的执行顺序，程序的执行结果将会被改变。</p><p>前面提到过，编译器和处理器可能会对操作做重排序。编译器和处理器在重排序时，会遵守数据依赖性，编译器和处理器不会改变存在数据依赖关系的两个操作的执行顺序。</p><p>注意，这里所说的数据依赖性仅针对单个处理器中执行的指令序列和单个线程中执行的操作，不同处理器之间和不同线程之间的数据依赖性不被编译器和处理器考虑。</p><h4 id="as-if-serial-语义"><a href="#as-if-serial-语义" class="headerlink" title="as-if-serial 语义"></a>as-if-serial 语义</h4><p>as-if-serial 语义的意思指：<strong>不管怎么重排序</strong>（编译器和处理器为了提高并行度），（单线程）<strong>程序的执行结果不能被改变</strong>。编译器，runtime 和处理器都必须遵守 as-if-serial 语义。</p><p>为了遵守 as-if-serial 编译器和处理器不会对存在数据依赖关系的操作做重排序，因为这种重排序会改变执行结果。但是如果操作之间没有数据依赖关系，这些操作就可能被编译器和处理器重排序。</p><p>举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">double pi = 3.14;     //A</span><br><span class="line">double r  = 1.0;       //B</span><br><span class="line">double area = pi * r * r;     //C</span><br></pre></td></tr></table></figure><p>上面三个操作的数据依赖关系如下图所示：</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fow7l7q6paj30fa0aoq33.jpg" alt="abc"></p><p>如上图所示，A 和 C 之间存在数据依赖关系，同时 B 和 C 之间也存在数据依赖关系。因此在最终执行的指令序列中，C 不能被重排序到 A 和 B 的前面（C 排到 A 和 B 的前面，程序的结果将会被改变）。但 A 和 B 之间没有数据依赖关系，编译器和处理器可以重排序 A 和 B 之间的执行顺序。下图是该程序的两种执行顺序：</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fow7l97fx2j30zu0cwdh1.jpg" alt="2018-02-27_16-52-44"></p><p>在计算机中，软件技术和硬件技术有一个共同的目标：在不改变程序执行结果的前提下，尽可能的开发并行度。编译器和处理器遵从这一目标，从 happens-before 的定义我们可以看出，JMM 同样遵从这一目标。</p><h4 id="重排序对多线程的影响"><a href="#重排序对多线程的影响" class="headerlink" title="重排序对多线程的影响"></a>重排序对多线程的影响</h4><p>举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    a = <span class="number">1</span>;<span class="comment">//1</span></span><br><span class="line">    flag = <span class="keyword">true</span>;<span class="comment">//2</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(flag) &#123;<span class="comment">//3</span></span><br><span class="line">      <span class="keyword">int</span> i = a * a;<span class="comment">//4</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于操作 1 和 2 没有数据依赖关系，编译器和处理器可以对这两个操作重排序；操作 3 和操作 4 没有数据依赖关系，编译器和处理器也可以对这两个操作重排序。</p><p>1、当操作 1 和操作 2 重排序时，可能会产生什么效果？</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fow7lcgkgej30tw0ki3zd.jpg" alt="sort12"></p><p>如上图所示，操作 1 和操作 2 做了重排序。程序执行时，线程 A 首先写标记变量 flag，随后线程 B 读这个变量。由于条件判断为真，线程 B 将读取变量 a。此时，变量 a 还根本没有被线程 A 写入，在这里多线程程序的语义被重排序破坏了！</p><p>2、当操作 3 和操作 4 重排序时会产生什么效果（借助这个重排序，可以顺便说明控制依赖性）。</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fow7l4zjfkj30zy0owq4r.jpg" alt="sort34"></p><p>在程序中，操作 3 和操作 4 存在<strong>控制依赖关系</strong>。当代码中存在控制依赖性时，<strong>会影响指令序列执行的并行度</strong>。为此，编译器和处理器会采用<strong>猜测</strong>（Speculation）执行来克服控制相关性对并行度的影响。以处理器的猜测执行为例，执行线程 B 的处理器可以提前读取并计算 a * a，然后把计算结果临时保存到一个名为重排序缓冲（reorder buffer ROB）的硬件缓存中。当接下来操作 3 的条件判断为真时，就把该计算结果写入变量 i 中。</p><p>从图中我们可以看出，猜测执行实质上对操作3和4做了重排序。重排序在这里破坏了多线程程序的语义！</p><p>在单线程程序中，对存在控制依赖的操作重排序，不会改变执行结果（这也是 as-if-serial 语义允许对存在控制依赖的操作做重排序的原因）；但在多线程程序中，对存在控制依赖的操作重排序，可能会改变程序的执行结果。</p><h3 id="顺序一致性"><a href="#顺序一致性" class="headerlink" title="顺序一致性"></a>顺序一致性</h3><h4 id="顺序一致性内存模型"><a href="#顺序一致性内存模型" class="headerlink" title="顺序一致性内存模型"></a>顺序一致性内存模型</h4><p>顺序一致性内存模型有两大特性：</p><ul><li>一个线程中的所有操作必须按照程序的顺序来执行。</li><li>（不管程序是否同步）所有线程都只能看到一个单一的操作执行顺序。在顺序一致性内存模型中，每个操作都必须原子执行且立刻对所有线程可见。</li></ul><p>顺序一致性内存模型为程序员提供的视图如下：</p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fow7l6dyuaj30sk0mumyg.jpg" alt="2018-02-27_17-55-09"></p><p>在概念上，顺序一致性模型有一个单一的全局内存，这个内存通过一个左右摆动的开关可以连接到任意一个线程，同时每一个线程必须按照程序的顺序来执行内存读/写操作。从上面的示意图我们可以看出，在任意时间点最多只能有一个线程可以连接到内存。当多个线程并发执行时，图中的开关装置能把所有线程的所有内存读/写操作串行化。</p><p>举个例子：</p><p>假设有两个线程 A 和 B 并发执行。其中 A 线程有三个操作，它们在程序中的顺序是：A1 -&gt; A2 -&gt; A3。B 线程也有三个操作，它们在程序中的顺序是：B1 -&gt; B2 -&gt; B3。</p><p>假设这两个线程使用监视器锁来正确同步：A 线程的三个操作执行后释放监视器锁，随后 B 线程获取同一个监视器锁。那么程序在顺序一致性模型中的执行效果将如下图所示：</p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fow7ldkj04j31440paaee.jpg" alt="2018-02-27_18-01-51"></p><p>现在我们再假设这两个线程没有做同步，下面是这个未同步程序在顺序一致性模型中的执行示意图：</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fow7lefk10j316c0nytd8.jpg" alt="2018-02-27_18-04-20"></p><p>未同步程序在顺序一致性模型中虽然整体执行顺序是无序的，但所有线程都只能看到一个一致的整体执行顺序。以上图为例，线程 A 和 B 看到的执行顺序都是：B1 -&gt; A1 -&gt; A2 -&gt; B2 -&gt; A3 -&gt; B3。之所以能得到这个保证是因为顺序一致性内存模型中的每个操作必须立即对任意线程可见。</p><p>但是，在 JMM 中就没有这个保证。未同步程序在 JMM 中不但整体的执行顺序是无序的，而且所有线程看到的操作执行顺序也可能不一致。比如，在当前线程把写过的数据缓存在本地内存中，在还没有刷新到主内存之前，这个写操作仅对当前线程可见；从其他线程的角度来观察，会认为这个写操作根本还没有被当前线程执行。只有当前线程把本地内存中写过的数据刷新到主内存之后，这个写操作才能对其他线程可见。在这种情况下，当前线程和其它线程看到的操作执行顺序将不一致。</p><h4 id="同步程序的顺序一致性效果"><a href="#同步程序的顺序一致性效果" class="headerlink" title="同步程序的顺序一致性效果"></a>同步程序的顺序一致性效果</h4><p>下面我们对前面的示例程序用锁来同步，看看正确同步的程序如何具有顺序一致性。</p><p>请看下面的示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">demo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">()</span> </span>&#123;<span class="comment">//获取锁</span></span><br><span class="line">    a = <span class="number">1</span>;</span><br><span class="line">    flag = <span class="keyword">true</span>;</span><br><span class="line">  &#125;<span class="comment">//释放锁</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;<span class="comment">//获取锁</span></span><br><span class="line">    <span class="keyword">if</span>(flag) &#123;</span><br><span class="line">      <span class="keyword">int</span> i = a;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;<span class="comment">//释放锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面示例代码中，假设 A 线程执行 write() 方法后，B 线程执行 reade() 方法。这是一个正确同步的多线程程序。根据JMM规范，该程序的执行结果将与该程序在顺序一致性模型中的执行结果相同。下面是该程序在两个内存模型中的执行时序对比图：</p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fow7ld04ffj312s0tq432.jpg" alt="2018-02-27_22-01-59"></p><p>在顺序一致性模型中，所有操作完全按程序的顺序执行。而在 JMM 中，临界区内的代码可以重排序（但 JMM 不允许临界区内的代码“逸出”到临界区之外，那样会破坏监视器的语义）。JMM 会在退出临界区和进入临界区这两个关键时间点做一些特别处理，使得线程在这两个时间点具有与顺序一致性模型相同的内存视图。虽然线程 A 在临界区内做了重排序，但由于监视器的互斥执行的特性，这里的线程 B 根本无法“观察”到线程 A 在临界区内的重排序。这种重排序既提高了执行效率，又没有改变程序的执行结果。</p><p>从这里我们可以看到 JMM 在具体实现上的基本方针：在不改变（正确同步的）程序执行结果的前提下，尽可能的为编译器和处理器的优化打开方便之门。</p><h4 id="未同步程序的执行特性"><a href="#未同步程序的执行特性" class="headerlink" title="未同步程序的执行特性"></a>未同步程序的执行特性</h4><p>未同步程序在 JMM 中的执行时，整体上是无序的，其执行结果无法预知。未同步程序在两个模型中的执行特性有下面几个差异：</p><ol><li>顺序一致性模型保证单线程内的操作会按程序的顺序执行，而 JMM  不保证单线程内的操作会按程序的顺序执行（比如上面正确同步的多线程程序在临界区内的重排序）。</li><li>顺序一致性模型保证所有线程只能看到一致的操作执行顺序，而 JMM 不保证所有线程能看到一致的操作执行顺序。</li><li><strong>JMM 不保证对 64 位的 long 型和 double 型变量的读/写操作具有原子性</strong>，而<strong>顺序一致性模型保证对所有的内存读/写操作都具有原子</strong> 。</li></ol><p>第三个差异与处理器总线的工作机制密切相关。在计算机中，数据通过总线在处理器和内存之间传递。每次处理器和内存之间的数据传递都是通过<strong>总线事务</strong>来完成的。总线事务包括读事务和写事务。读事务从内存传送数据到处理器，写事务从处理器传递数据到内存，每个事务会读／写内存中一个或多个物理上连续的字。总线会同步试图并发使用总线的事务。在一个处理器执行总线事务期间，总线会禁止其它所有的处理器和 I／O 设备执行内存的读／写。</p><p>总线的工作机制：</p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fow7levu1fj30zm0rgmzu.jpg" alt="2018-02-27_22-53-53"></p><p>如上图所示，假设处理器 A、B、和 C  同时向总线发起总线事务，这时总线仲裁会对竞争作出裁决，假设总线在仲裁后判定处理器 A 在竞争中获胜（总线仲裁会确保所有处理器都能公平的访问内存）。此时处理器 A 继续它的总线事务，而其它两个处理器则要等待处理器 A 的总线事务完成后才能开始再次执行内存访问。假设在处理器 A 执行总线事务期间（不管这个总线事务是读事务还是写事务），处理器 D 向总线发起了总线事务，此时处理器 D 的这个请求会被总线禁止。</p><p>总线的这些工作机制可以<strong>把所有处理器对内存的访问以串行化的方式来执行</strong>；<strong>在任意时间点，最多只能有一个处理器能访问内存</strong>。这个特性<strong>确保了单个总线事务之中的内存读/写操作具有原子性</strong>。</p><p>在一些 32 位的处理器上，如果要求对 64 位数据的写操作具有原子性，会有比较大的开销。为了照顾这种处理器，Java 语言规范鼓励但不强求 JVM 对 64 位的 long 型变量和 double 型变量的写具有原子性。当 JVM 在这种处理器上运行时，会把一个 64 位 long/ double 型变量的写操作拆分为两个 32 位的写操作来执行。这两个 32 位的写操作可能会被分配到不同的总线事务中执行，此时对这个 64 位变量的写将不具有原子性。</p><p>当单个内存操作不具有原子性，将可能会产生意想不到后果。请看下面示意图：</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fow7l88o2aj312i0l8jt0.jpg" alt="2018-02-27_23-06-59"></p><p>如上图所示，假设处理器 A 写一个 long 型变量，同时处理器 B 要读这个 long 型变量。处理器 A 中 64 位的写操作被拆分为两个 32 位的写操作，且这两个 32 位的写操作被分配到不同的写事务中执行。同时处理器 B 中 64 位的读操作被分配到单个的读事务中执行。当处理器 A 和 B 按上图的时序来执行时，处理器 B 将看到仅仅被处理器 A “写了一半“的无效值。</p><p>注意，在 JSR -133 之前的旧内存模型中，一个 64 位 long/ double 型变量的<strong>读/写</strong>操作可以被拆分为两个 32 位的读/写操作来执行。从 JSR -133 内存模型开始（即从JDK5开始），仅仅只允许把一个 64 位 long/ double 型变量的<strong>写</strong>操作拆分为两个 32 位的写操作来执行，<strong>任意的读操作在JSR -133中都必须具有原子性</strong>（即任意读操作必须要在单个读事务中执行）。</p><h3 id="Volatile"><a href="#Volatile" class="headerlink" title="Volatile"></a>Volatile</h3><h4 id="Volatile-特性"><a href="#Volatile-特性" class="headerlink" title="Volatile 特性"></a>Volatile 特性</h4><p>举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">long</span> a = <span class="number">1L</span>; <span class="comment">// 使用 volatile 声明 64 位的 long 型</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">long</span> l)</span> </span>&#123;</span><br><span class="line">        a = l;                  <span class="comment">//单个 volatile 变量的写</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a;               <span class="comment">//单个 volatile 变量的读</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getAndIncreament</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        a++;                    <span class="comment">// 复合（多个） volatile 变量的读 /写</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设有多个线程分别调用上面程序的三个方法，这个程序在语义上和下面程序等价：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> a = <span class="number">1L</span>; <span class="comment">// 64 位的 long 型普通变量</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">long</span> l)</span> </span>&#123;<span class="comment">//对单个普通变量的写用同一个锁同步</span></span><br><span class="line">        a = l;                </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">long</span> <span class="title">get</span><span class="params">()</span> </span>&#123;<span class="comment">//对单个普通变量的读用同一个锁同步</span></span><br><span class="line">        <span class="keyword">return</span> a;           </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getAndIncreament</span><span class="params">()</span> </span>&#123;<span class="comment">//普通方法调用</span></span><br><span class="line">      <span class="keyword">long</span> temp = get();<span class="comment">//调用已同步的读方法</span></span><br><span class="line">        temp += <span class="number">1L</span>;<span class="comment">//普通写操作</span></span><br><span class="line">      set(temp);<span class="comment">//调用已同步的写方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上面示例程序所示，对一个 volatile 变量的单个读/写操作，与对一个普通变量的读/写操作使用同一个锁来同步，它们之间的执行效果相同。</p><p>锁的 happens-before 规则保证释放锁和获取锁的两个线程之间的内存可见性，这意味着<strong>对一个 volatile 变量的读，总是能看到（任意线程）对这个 volatile 变量最后的写入</strong>。</p><p>锁的语义决定了临界区代码的执行具有原子性。这意味着即使是 64 位的 long 型和 double 型变量，只要它是 volatile变量，对该变量的读写就将具有原子性。<strong>如果是多个 volatile 操作或类似于 volatile++ 这种复合操作，这些操作整体上不具有原子性</strong>。</p><p>简而言之，volatile 变量自身具有下列特性：</p><ul><li>可见性。对一个 volatile 变量的读，总是能看到（任意线程）对这个 volatile 变量最后的写入。</li><li>原子性：对任意单个 volatile 变量的读/写具有原子性，但类似于 volatile++ 这种复合操作不具有原子性。</li></ul><h4 id="volatile-写-读的内存定义"><a href="#volatile-写-读的内存定义" class="headerlink" title="volatile 写-读的内存定义"></a>volatile 写-读的内存定义</h4><ul><li>当<strong>写</strong>一个 volatile 变量时，JMM 会把该线程对应的本地内存中的共享变量值刷新到主内存。</li><li>当<strong>读</strong>一个 volatile 变量时，JMM 会把该线程对应的本地内存置为无效。线程接下来将从主内存中读取共享变量。</li></ul><p>假设上面的程序 flag 变量用 volatile 修饰</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fow7lak6kvj30xc0qc76l.jpg" alt="2018-02-28_10-13-39"></p><h4 id="volatile-内存语义的实现"><a href="#volatile-内存语义的实现" class="headerlink" title="volatile 内存语义的实现"></a>volatile 内存语义的实现</h4><p>下面是 JMM 针对编译器制定的 volatile 重排序规则表：</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fow7lg83wdj313u0ckmz8.jpg" alt="2018-02-28_10-26-43"></p><p>为了实现 volatile 的内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。</p><p>下面是基于保守策略的 JMM 内存屏障插入策略：</p><ul><li>在每个 volatile 写操作的前面插入一个 StoreStore 屏障。</li><li>在每个 volatile 写操作的后面插入一个 StoreLoad 屏障。</li><li>在每个 volatile 读操作的后面插入一个 LoadLoad 屏障。</li><li>在每个 volatile 读操作的后面插入一个 LoadStore 屏障。</li></ul><p>下面是保守策略下，volatile 写操作 插入内存屏障后生成的指令序列示意图：</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fow7la65xnj31100lc76r.jpg" alt="2018-02-28_10-31-14"></p><p>下面是在保守策略下，volatile 读操作 插入内存屏障后生成的指令序列示意图：</p><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fow7l35uyuj310w0myju1.jpg" alt="2018-02-28_10-38-12"></p><p>上述 volatile 写操作和 volatile 读操作的内存屏障插入策略非常保守。在实际执行时，只要不改变 volatile 写-读的内存语义，编译器可以根据具体情况省略不必要的屏障。</p><h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><h4 id="锁释放和获取的内存语义"><a href="#锁释放和获取的内存语义" class="headerlink" title="锁释放和获取的内存语义"></a>锁释放和获取的内存语义</h4><p>当线程释放锁时，JMM 会把该线程对应的本地内存中的共享变量刷新到主内存中。</p><p>当线程获取锁时，JMM 会把该线程对应的本地内存置为无效。从而使得被监视器保护的临界区代码必须要从主内存中去读取共享变量。</p><h4 id="锁内存语义的实现"><a href="#锁内存语义的实现" class="headerlink" title="锁内存语义的实现"></a>锁内存语义的实现</h4><p>借助 ReentrantLock 来讲解，PS： 后面专门讲下这块（ReentrantLock、Synchronized、公平锁、非公平锁、AQS等），可以看看大明哥的博客：<a href="">http://cmsblogs.com/?p=2210</a></p><h4 id="concurrent-包的实现"><a href="#concurrent-包的实现" class="headerlink" title="concurrent 包的实现"></a>concurrent 包的实现</h4><p>如果我们仔细分析 concurrent 包的源代码实现，会发现一个通用化的实现模式：</p><ol><li>首先，声明共享变量为 volatile；</li><li>然后，使用 CAS 的原子条件更新来实现线程之间的同步；</li><li>同时，配合以 volatile 的读/写和 CAS 所具有的 volatile 读和写的内存语义来实现线程之间的通信。</li></ol><p>AQS，非阻塞数据结构和原子变量类（java.util.concurrent.atomic 包中的类），这些 concurrent 包中的基础类都是使用这种模式来实现的，而 concurrent 包中的高层类又是依赖于这些基础类来实现的。从整体来看，concurrent 包的实现示意图如下：</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fow7l42rbpj31160qa77a.jpg" alt="2018-02-28_14-58-32"></p><h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><p>对于 final 域，编译器和处理器要遵守两个重排序规则：</p><ol><li>在构造函数内对一个 final 域的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。</li><li>初次读一个包含 final 域的对象的引用，与随后初次读这个 final 域，这两个操作之间不能重排序。</li></ol><h4 id="写-final-域的重排序规则"><a href="#写-final-域的重排序规则" class="headerlink" title="写 final 域的重排序规则"></a>写 final 域的重排序规则</h4><p>写 final 域的重排序规则禁止把 final 域的写重排序到构造函数之外。这个规则的实现包含下面2个方面：</p><ul><li>JMM 禁止编译器把 final 域的写重排序到构造函数之外。</li><li>编译器会在 final 域的写之后，构造函数 return 之前，插入一个 StoreStore 屏障。这个屏障禁止处理器把 final 域的写重排序到构造函数之外。</li></ul><h4 id="读-final-域的重排序规则"><a href="#读-final-域的重排序规则" class="headerlink" title="读 final 域的重排序规则"></a>读 final 域的重排序规则</h4><p>在一个线程中，初次读对象引用与初次读该对象包含的 final 域，JMM 禁止处理器重排序这两个操作（注意，这个规则仅仅针对处理器）。编译器会在读 final 域操作的前面插入一个 LoadLoad 屏障。</p><h4 id="final-域是引用类型"><a href="#final-域是引用类型" class="headerlink" title="final 域是引用类型"></a>final 域是引用类型</h4><p>对于引用类型，写 final 域的重排序规则对编译器和处理器增加了如下约束：</p><p>在构造函数内对一个 final 引用的对象的成员域的写入，与随后在构造函数外把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h4 id="JMM，处理器内存模型与顺序一致性内存模型之间的关系"><a href="#JMM，处理器内存模型与顺序一致性内存模型之间的关系" class="headerlink" title="JMM，处理器内存模型与顺序一致性内存模型之间的关系"></a>JMM，处理器内存模型与顺序一致性内存模型之间的关系</h4><p>JMM 是一个语言级的内存模型，处理器内存模型是硬件级的内存模型，顺序一致性内存模型是一个理论参考模型。下面是语言内存模型，处理器内存模型和顺序一致性内存模型的强弱对比示意图：</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fow7l8rgjej30ys0r6n05.jpg" alt="2018-02-28_15-34-39"></p><h4 id="JMM-的设计示意图"><a href="#JMM-的设计示意图" class="headerlink" title="JMM 的设计示意图"></a>JMM 的设计示意图</h4><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fow7lb5c5kj310y0z4q7w.jpg" alt="jmm-"></p><h4 id="JMM-的内存可见性保证"><a href="#JMM-的内存可见性保证" class="headerlink" title="JMM 的内存可见性保证"></a>JMM 的内存可见性保证</h4><p>Java 程序的内存可见性保证按程序类型可以分为下列三类：</p><p>1.单线程程序。单线程程序不会出现内存可见性问题。编译器，runtime 和处理器会共同确保单线程程序的执行结果与该程序在顺序一致性模型中的执行结果相同。</p><p>2.正确同步的多线程程序。正确同步的多线程程序的执行将具有顺序一致性（程序的执行结果与该程序在顺序一致性内存模型中的执行结果相同）。这是 JMM 关注的重点，JMM通过限制编译器和处理器的重排序来为程序员提供内存可见性保证。</p><p>3.未同步/未正确同步的多线程程序。JMM 为它们提供了最小安全性保障：线程执行时读取到的值，要么是之前某个线程写入的值，要么是默认值（0，null，false）。</p><p>下图展示了这三类程序在 JMM 中与在顺序一致性内存模型中的执行结果的异同：</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fow7lgmupij311m0sqtcg.jpg" alt="2018-02-28_15-43-10"></p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fp3jkmizmpj30o00didgn.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://ws3.sinaimg.cn/large/006tNc79gy1fow7l5mj64j31hc0zbh9n.jpg&quot; alt=&quot;fairyland-canyon-1632749_1920&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;前提&quot;&gt;&lt;a href=&quot;#前提&quot; class=&quot;headerlink&quot; title=&quot;前提&quot;&gt;&lt;/a&gt;前提&lt;/h3&gt;&lt;p&gt;《深入理解 Java 内存模型》程晓明著，该书在以前看过一遍，现在学的东西越多，感觉那块越重要，于是又再细看一遍，于是便有了下面的读书笔记总结。全书页数虽不多，内容讲得挺深的。细看的话，也是挺花时间的，看完收获绝对挺大的。也建议 Java 开发者都去看看。里面主要有 Java 内存模型的基础、重排序、顺序一致性、Volatile 关键字、锁、final。本文参考书中内容。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="JMM" scheme="http://yoursite.com/tags/JMM/"/>
    
  </entry>
  
  <entry>
    <title>RocketMQ系列文章（三）：RocketMQ 简单的消息示例</title>
    <link href="http://yoursite.com/2018/02/07/rocketmq-example/"/>
    <id>http://yoursite.com/2018/02/07/rocketmq-example/</id>
    <published>2018-02-06T16:00:00.000Z</published>
    <updated>2018-03-24T02:36:27.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1fo6h2isc2lj31hc0vhaqg.jpg" alt="father-and-son-2258681_1920"></p><p>使用 RocketMQ 以三种方式发送消息：可靠的同步，可靠的异步和单向传输。<br><a id="more"></a></p><h3 id="可靠的同步传输"><a href="#可靠的同步传输" class="headerlink" title="可靠的同步传输"></a>可靠的同步传输</h3><p>应用：可靠的同步传输广泛应用于重要通知消息，短信通知，短信营销系统等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncProducer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//Instantiate with a producer group name.</span></span><br><span class="line">        DefaultMQProducer producer = <span class="keyword">new</span></span><br><span class="line">            DefaultMQProducer(<span class="string">"please_rename_unique_group_name"</span>);</span><br><span class="line">        <span class="comment">//Launch the instance.</span></span><br><span class="line">        producer.start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//Create a message instance, specifying topic, tag and message body.</span></span><br><span class="line">            Message msg = <span class="keyword">new</span> Message(<span class="string">"TopicTest"</span> <span class="comment">/* Topic */</span>,</span><br><span class="line">                <span class="string">"TagA"</span> <span class="comment">/* Tag */</span>,</span><br><span class="line">                (<span class="string">"Hello RocketMQ "</span> +</span><br><span class="line">                    i).getBytes(RemotingHelper.DEFAULT_CHARSET) <span class="comment">/* Message body */</span></span><br><span class="line">            );</span><br><span class="line">            <span class="comment">//Call send message to deliver message to one of brokers.</span></span><br><span class="line">            SendResult sendResult = producer.send(msg);</span><br><span class="line">            System.out.printf(<span class="string">"%s%n"</span>, sendResult);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//Shut down once the producer instance is not longer in use.</span></span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="可靠的异步传输"><a href="#可靠的异步传输" class="headerlink" title="可靠的异步传输"></a>可靠的异步传输</h3><p>应用：异步传输一般用于响应时间敏感的业务场景。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncProducer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//Instantiate with a producer group name.</span></span><br><span class="line">        DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">"ExampleProducerGroup"</span>);</span><br><span class="line">        <span class="comment">//Launch the instance.</span></span><br><span class="line">        producer.start();</span><br><span class="line">        producer.setRetryTimesWhenSendAsyncFailed(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> index = i;</span><br><span class="line">                <span class="comment">//Create a message instance, specifying topic, tag and message body.</span></span><br><span class="line">                Message msg = <span class="keyword">new</span> Message(<span class="string">"TopicTest"</span>,</span><br><span class="line">                    <span class="string">"TagA"</span>,</span><br><span class="line">                    <span class="string">"OrderID188"</span>,</span><br><span class="line">                    <span class="string">"Hello world"</span>.getBytes(RemotingHelper.DEFAULT_CHARSET));</span><br><span class="line">                producer.send(msg, <span class="keyword">new</span> SendCallback() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(SendResult sendResult)</span> </span>&#123;</span><br><span class="line">                        System.out.printf(<span class="string">"%-10d OK %s %n"</span>, index,</span><br><span class="line">                            sendResult.getMsgId());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onException</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">                        System.out.printf(<span class="string">"%-10d Exception %s %n"</span>, index, e);</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//Shut down once the producer instance is not longer in use.</span></span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单向传输"><a href="#单向传输" class="headerlink" title="单向传输"></a>单向传输</h3><p>应用：单向传输用于需要中等可靠性的情况，例如日志收集。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OnewayProducer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">//Instantiate with a producer group name.</span></span><br><span class="line">        DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">"ExampleProducerGroup"</span>);</span><br><span class="line">        <span class="comment">//Launch the instance.</span></span><br><span class="line">        producer.start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//Create a message instance, specifying topic, tag and message body.</span></span><br><span class="line">            Message msg = <span class="keyword">new</span> Message(<span class="string">"TopicTest"</span> <span class="comment">/* Topic */</span>,</span><br><span class="line">                <span class="string">"TagA"</span> <span class="comment">/* Tag */</span>,</span><br><span class="line">                (<span class="string">"Hello RocketMQ "</span> +</span><br><span class="line">                    i).getBytes(RemotingHelper.DEFAULT_CHARSET) <span class="comment">/* Message body */</span></span><br><span class="line">            );</span><br><span class="line">            <span class="comment">//Call send message to deliver message to one of brokers.</span></span><br><span class="line">            producer.sendOneway(msg);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//Shut down once the producer instance is not longer in use.</span></span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="关注我"><a href="#关注我" class="headerlink" title="关注我"></a>关注我</h3><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180103/C6LG3mGa12.jpg" alt="mark"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文是 RocketMQ 的三种发送消息的方式。</p><p>转发请注明地址：<a href="http://www.54tianzhisheng.cn/2018/02/07/rocketmq-example/" target="_blank" rel="noopener">http://www.54tianzhisheng.cn/2018/02/07/rocketmq-example/</a></p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fp3jkmizmpj30o00didgn.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://ws4.sinaimg.cn/large/006tKfTcgy1fo6h2isc2lj31hc0vhaqg.jpg&quot; alt=&quot;father-and-son-2258681_1920&quot;&gt;&lt;/p&gt;
&lt;p&gt;使用 RocketMQ 以三种方式发送消息：可靠的同步，可靠的异步和单向传输。&lt;br&gt;
    
    </summary>
    
    
      <category term="RocketMQ" scheme="http://yoursite.com/tags/RocketMQ/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot系列文章（六）：SpringBoot RocketMQ 整合使用和监控</title>
    <link href="http://yoursite.com/2018/02/07/SpringBoot-RocketMQ/"/>
    <id>http://yoursite.com/2018/02/07/SpringBoot-RocketMQ/</id>
    <published>2018-02-06T16:00:00.000Z</published>
    <updated>2018-03-24T02:34:38.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fo8vqfuapwj31hc0zhtro.jpg" alt="photoshop-2845779_1920"></p><h3 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h3><p>通过前面两篇文章可以简单的了解 RocketMQ 和 安装 RocketMQ ，今天就将 SpringBoot 和 RocketMQ 整合起来使用。<br><a id="more"></a></p><h3 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h3><p>1、<a href="http://www.54tianzhisheng.cn/2018/01/05/SpringBoot-Kafka/" target="_blank" rel="noopener">SpringBoot Kafka 整合使用</a></p><p>2、<a href="http://www.54tianzhisheng.cn/2018/01/26/SpringBoot-RabbitMQ/" target="_blank" rel="noopener">SpringBoot RabbitMQ 整合使用</a></p><p>3、<a href="http://www.54tianzhisheng.cn/2018/01/27/SpringBoot-ActiveMQ/" target="_blank" rel="noopener">SpringBoot ActiveMQ 整合使用</a></p><p>4、<a href="http://www.54tianzhisheng.cn/2018/01/04/Kafka/" target="_blank" rel="noopener">Kafka 安装及快速入门</a></p><p>5、<a href="http://www.54tianzhisheng.cn/2018/01/28/RabbitMQ/" target="_blank" rel="noopener">SpringBoot RabbitMQ 整合进阶版</a></p><p>6、<a href="http://www.54tianzhisheng.cn/2018/02/05/RocketMQ/" target="_blank" rel="noopener">RocketMQ 初探</a></p><p>7、<a href="http://www.54tianzhisheng.cn/2018/02/06/RocketMQ-install/" target="_blank" rel="noopener">RocketMQ 安装及快速入门</a></p><h3 id="关注我"><a href="#关注我" class="headerlink" title="关注我"></a>关注我</h3><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180103/C6LG3mGa12.jpg" alt="mark"></p><p>转载请务必注明原创地址为：<a href="http://www.54tianzhisheng.cn/2018/02/07/SpringBoot-RocketMQ/" target="_blank" rel="noopener">http://www.54tianzhisheng.cn/2018/02/07/SpringBoot-RocketMQ/</a></p><h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><p>在 IDEA 创建一个 SpringBoot 项目，项目结构如下：</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fo8vq6ufg3j30pe0yoacc.jpg" alt="rocketmq01"></p><h4 id="pom-文件"><a href="#pom-文件" class="headerlink" title="pom 文件"></a>pom 文件</h4><p>引入 RocketMQ 的一些相关依赖，最后的 pom 文件如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span><span class="meta">?&gt;</span></span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.zhisheng<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>rocketmq<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>rocketmq<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot RocketMQ<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.reporting.outputEncoding</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.rocketmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>rocketmq-common<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>4.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.rocketmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>rocketmq-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>4.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h4><p>application.properties 中如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 消费者的组名</span><br><span class="line">apache.rocketmq.consumer.PushConsumer=PushConsumer</span><br><span class="line"># 生产者的组名</span><br><span class="line">apache.rocketmq.producer.producerGroup=Producer</span><br><span class="line"># NameServer地址</span><br><span class="line">apache.rocketmq.namesrvAddr=localhost:9876</span><br></pre></td></tr></table></figure><h4 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhisheng.rocketmq.client;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.producer.DefaultMQProducer;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.common.message.Message;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.remoting.common.RemotingHelper;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.StopWatch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.PostConstruct;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by zhisheng_tian on 2018/2/6</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RocketMQClient</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生产者的组名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;apache.rocketmq.producer.producerGroup&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String producerGroup;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * NameServer 地址</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;apache.rocketmq.namesrvAddr&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String namesrvAddr;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">defaultMQProducer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//生产者的组名</span></span><br><span class="line">        DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(producerGroup);</span><br><span class="line">        <span class="comment">//指定NameServer地址，多个地址以 ; 隔开</span></span><br><span class="line">        producer.setNamesrvAddr(namesrvAddr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * Producer对象在使用之前必须要调用start初始化，初始化一次即可</span></span><br><span class="line"><span class="comment">             * 注意：切记不可以在每次发送消息时，都调用start方法</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            producer.start();</span><br><span class="line"></span><br><span class="line">           <span class="comment">//创建一个消息实例，包含 topic、tag 和 消息体</span></span><br><span class="line">             <span class="comment">//如下：topic 为 "TopicTest"，tag 为 "push"</span></span><br><span class="line">            Message message = <span class="keyword">new</span> Message(<span class="string">"TopicTest"</span>, <span class="string">"push"</span>, <span class="string">"发送消息----zhisheng-----"</span>.getBytes(RemotingHelper.DEFAULT_CHARSET));</span><br><span class="line"></span><br><span class="line">            StopWatch stop = <span class="keyword">new</span> StopWatch();</span><br><span class="line">            stop.start();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">                SendResult result = producer.send(message);</span><br><span class="line">                System.out.println(<span class="string">"发送响应：MsgId:"</span> + result.getMsgId() + <span class="string">"，发送状态:"</span> + result.getSendStatus());</span><br><span class="line">            &#125;</span><br><span class="line">            stop.stop();</span><br><span class="line">            System.out.println(<span class="string">"----------------发送一万条消息耗时："</span> + stop.getTotalTimeMillis());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            producer.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhisheng.rocketmq.server;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.common.consumer.ConsumeFromWhere;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.common.message.MessageExt;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.remoting.common.RemotingHelper;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.PostConstruct;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by zhisheng_tian on 2018/2/6</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RocketMQServer</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消费者的组名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;apache.rocketmq.consumer.PushConsumer&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String consumerGroup;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * NameServer 地址</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;apache.rocketmq.namesrvAddr&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String namesrvAddr;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">defaultMQPushConsumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//消费者的组名</span></span><br><span class="line">        DefaultMQPushConsumer consumer = <span class="keyword">new</span> DefaultMQPushConsumer(consumerGroup);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//指定NameServer地址，多个地址以 ; 隔开</span></span><br><span class="line">        consumer.setNamesrvAddr(namesrvAddr);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//订阅PushTopic下Tag为push的消息</span></span><br><span class="line">            consumer.subscribe(<span class="string">"TopicTest"</span>, <span class="string">"push"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//设置Consumer第一次启动是从队列头部开始消费还是队列尾部开始消费</span></span><br><span class="line">            <span class="comment">//如果非第一次启动，那么按照上次消费的位置继续消费</span></span><br><span class="line">            consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);</span><br><span class="line">            consumer.registerMessageListener((MessageListenerConcurrently) (list, context) -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (MessageExt messageExt : list) &#123;</span><br><span class="line"></span><br><span class="line">                        System.out.println(<span class="string">"messageExt: "</span> + messageExt);<span class="comment">//输出消息内容</span></span><br><span class="line"></span><br><span class="line">                        String messageBody = <span class="keyword">new</span> String(messageExt.getBody(), RemotingHelper.DEFAULT_CHARSET);</span><br><span class="line"></span><br><span class="line">                        System.out.println(<span class="string">"消费响应：msgId : "</span> + messageExt.getMsgId() + <span class="string">",  msgBody : "</span> + messageBody);<span class="comment">//输出消息内容</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                    <span class="keyword">return</span> ConsumeConcurrentlyStatus.RECONSUME_LATER; <span class="comment">//稍后再试</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS; <span class="comment">//消费成功</span></span><br><span class="line">            &#125;);</span><br><span class="line">            consumer.start();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="启动类"><a href="#启动类" class="headerlink" title="启动类"></a>启动类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhisheng.rocketmq;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RocketmqApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">SpringApplication.run(RocketmqApplication.class, args);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="RocketMQ"><a href="#RocketMQ" class="headerlink" title="RocketMQ"></a>RocketMQ</h3><p>代码已经都写好了，接下来我们需要将与 RocketMQ 有关的启动起来。</p><h4 id="启动-Name-Server"><a href="#启动-Name-Server" class="headerlink" title="启动 Name Server"></a>启动 Name Server</h4><p>在前面文章中已经写过怎么启动，<a href="http://www.54tianzhisheng.cn/2018/02/06/RocketMQ-install/#%E5%90%AF%E5%8A%A8-NameServer" target="_blank" rel="noopener">http://www.54tianzhisheng.cn/2018/02/06/RocketMQ-install/#%E5%90%AF%E5%8A%A8-NameServer</a></p><p>进入到目录 ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd distribution/target/apache-rocketmq</span><br></pre></td></tr></table></figure><p>启动：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nohup sh bin/mqnamesrv &amp;</span><br><span class="line"></span><br><span class="line">tail -f ~/logs/rocketmqlogs/namesrv.log //通过日志查看是否启动成功</span><br></pre></td></tr></table></figure><h4 id="启动-Broker"><a href="#启动-Broker" class="headerlink" title="启动 Broker"></a>启动 Broker</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nohup sh bin/mqbroker -n localhost:9876 &amp;</span><br><span class="line"></span><br><span class="line">tail -f ~/logs/rocketmqlogs/broker.log//通过日志查看是否启动成功</span><br></pre></td></tr></table></figure><p>然后运行启动类，运行效果如下：</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fo8vqiq0jvj31kw0x1x6m.jpg" alt="2018-02-07_22-21-14"></p><h3 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h3><p>RocketMQ有一个对其扩展的开源项目 ocketmq-console ，如今也提交给了 Apache ，地址在：<a href="">https://github.com/apache/rocketmq-externals/tree/master/rocketmq-console</a> ，官方也给出了其支持的功能的中文文档：<a href="">https://github.com/apache/rocketmq-externals/blob/master/rocketmq-console/doc/1_0_0/UserGuide_CN.md</a> ， 那么该如何安装？</p><h4 id="Docker-安装"><a href="#Docker-安装" class="headerlink" title="Docker 安装"></a>Docker 安装</h4><p>1、获取 Docker 镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull styletang/rocketmq-console-ng</span><br></pre></td></tr></table></figure><p>2、运行，注意将你自己的 NameServer 地址替换下面的 127.0.0.1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -e &quot;JAVA_OPTS=-Drocketmq.namesrv.addr=127.0.0.1:9876 -Dcom.rocketmq.sendMessageWithVIPChannel=false&quot; -p 8080:8080 -t styletang/rocketmq-console-ng</span><br></pre></td></tr></table></figure><h4 id="非-Docker-安装"><a href="#非-Docker-安装" class="headerlink" title="非 Docker 安装"></a>非 Docker 安装</h4><p>我们 git clone 一份代码到本地：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/apache/rocketmq-externals.git</span><br><span class="line"></span><br><span class="line">cd rocketmq-externals/rocketmq-console/</span><br></pre></td></tr></table></figure><p>需要 jdk 1.7 以上。  执行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn spring-boot:run</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mvn clean package -Dmaven.test.skip=true</span><br><span class="line"></span><br><span class="line">java -jar target/rocketmq-console-ng-1.0.0.jar</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><p>1、如果你下载依赖缓慢，你可以重新设置 maven 的 mirror 为阿里云的镜像</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirrors</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">id</span>&gt;</span>alimaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span>        </span><br><span class="line">    <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirrors</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2、如果你使用的 RocketMQ 版本小于 3.5.8，如果您使用 rocketmq &lt; 3.5.8，请在启动 rocketmq-console-ng 时添加 <code>-Dcom.rocketmq.sendMessageWithVIPChannel = false</code>（或者您可以在 ops 页面中更改它）</p><p>3、更改 resource / application.properties 中的 rocketmq.config.namesrvAddr（或者可以在ops页面中更改它）</p><h3 id="错误解决方法"><a href="#错误解决方法" class="headerlink" title="错误解决方法"></a>错误解决方法</h3><p>1、Docker 启动项目报错</p><p><code>org.apache.rocketmq.remoting.exception.RemotingConnectException: connect to &lt;null&gt; failed</code></p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fo8vqhpxcrj31kw0qc4ln.jpg" alt="2018-02-07_23-28-51"></p><p>将 Docker 启动命令改成如下以后：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -e &quot;JAVA_OPTS=-Drocketmq.config.namesrvAddr=127.0.0.1:9876 -Drocketmq.config.isVIPChannel=false&quot; -p 8080:8080 -t styletang/rocketmq-console-ng</span><br></pre></td></tr></table></figure><p>报错信息改变了，新的报错信息如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ERROR op=global_exception_handler_print_error</span><br><span class="line"></span><br><span class="line">org.apache.rocketmq.console.exception.ServiceException: This date have&apos;t data!</span><br></pre></td></tr></table></figure><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fo8vql4zvij31kw0vz1kx.jpg" alt="2018-02-08_00-23-15"></p><p>看到网上有人也遇到这个问题，他们都通过自己的方式解决了，但是方法我都试了，不适合我。不得不说，阿里，你能再用心点吗？既然把 RocketMQ 捐给 Apache 了，这些文档啥的都必须更新啊，不要还滞后着呢，不然少不了被吐槽！</p><p> 搞了很久这种方法没成功，暂时放弃！mmp</p><p>2、非 Docker 安装，只好把源码编译打包了。</p><p>1) 注意需要修改如下图中的配置：</p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fo8vq7xv71j31kw0nktmi.jpg" alt="2018-02-08_10-26-03"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rocketmq.config.namesrvAddr=localhost:9876//注意替换你自己的ip</span><br><span class="line"></span><br><span class="line">#如果你 rocketmq 版本小于 3.5.8 才需设置 `rocketmq.config.isVIPChannel` 为 false，默认是 true, 这个可以在源码中可以看到的</span><br><span class="line">rocketmq.config.isVIPChannel=</span><br></pre></td></tr></table></figure><p>2) 执行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn clean package -Dmaven.test.skip=true</span><br></pre></td></tr></table></figure><p>编译成功：</p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fo8vqk3r9ej31kw0tsh2z.jpg" alt="2018-02-08_10-41-35"></p><p>可以看到已经打好了 jar 包：</p><p>运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar rocketmq-console-ng-1.0.0.jar</span><br></pre></td></tr></table></figure><p>成功，不报错了，开心😄，访问 <a href="http://localhost:8080/" target="_blank" rel="noopener">http://localhost:8080/</a></p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fo8vqdzp1kj31kw0vyqap.jpg" alt="2018-02-08_11-06-26"></p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fo8vqlthfqj31e20liwgz.jpg" alt="2018-02-08_11-08-01"></p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fo8vqgsrl8j31kw09pjur.jpg" alt="2018-02-08_11-09-16"></p><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fo8vqaazsyj31kw0p8qce.jpg" alt="2018-02-08_11-09-31"></p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fo8vqbosxvj31kw0vowp0.jpg" alt="2018-02-08_11-09-47"></p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fo8vqet48yj31kw0bsmzk.jpg" alt="2018-02-08_11-10-03"></p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fo8vq8q3v9j31kw0dfn0m.jpg" alt="2018-02-08_11-10-22"></p><p>整个监控大概就是这些了。</p><p>然后我运行之前的 SpringBoot 整合项目，查看监控信息如下：</p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fo8vqcyj00j31kw0up46m.jpg" alt="2018-02-08_11-22-11"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>整篇文章讲述了 SpringBoot 与 RocketMQ 整合和 RocketMQ 监控平台的搭建。</p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p>1、<a href="">http://www.ymq.io/2018/02/02/spring-boot-rocketmq-example/#%E6%96%B0%E5%8A%A0%E9%A1%B9%E7%9B%AE</a></p><p>2、GitHub 官方 README</p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fp3jkmizmpj30o00didgn.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://ws2.sinaimg.cn/large/006tNc79gy1fo8vqfuapwj31hc0zhtro.jpg&quot; alt=&quot;photoshop-2845779_1920&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;前提&quot;&gt;&lt;a href=&quot;#前提&quot; class=&quot;headerlink&quot; title=&quot;前提&quot;&gt;&lt;/a&gt;前提&lt;/h3&gt;&lt;p&gt;通过前面两篇文章可以简单的了解 RocketMQ 和 安装 RocketMQ ，今天就将 SpringBoot 和 RocketMQ 整合起来使用。&lt;br&gt;
    
    </summary>
    
    
      <category term="SpringBoot" scheme="http://yoursite.com/tags/SpringBoot/"/>
    
      <category term="RocketMQ" scheme="http://yoursite.com/tags/RocketMQ/"/>
    
  </entry>
  
  <entry>
    <title>RocketMQ系列文章（二）：RocketMQ 安装及快速入门</title>
    <link href="http://yoursite.com/2018/02/06/RocketMQ-install/"/>
    <id>http://yoursite.com/2018/02/06/RocketMQ-install/</id>
    <published>2018-02-05T16:00:00.000Z</published>
    <updated>2018-03-24T02:36:03.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fo5pxy3w8oj31hc0u0b29.jpg" alt="tree-3097419_1920"></p><p>如果你对 RocketMQ 还没了解，建议先看下上一篇文章：<a href="http://www.54tianzhisheng.cn/2018/02/05/RocketMQ/" target="_blank" rel="noopener">RocketMQ 初探</a></p><a id="more"></a><h3 id="安装条件"><a href="#安装条件" class="headerlink" title="安装条件"></a>安装条件</h3><ol><li>64位操作系统，建议使用 Linux / Unix / Mac;</li><li>64位JDK 1.8+;</li><li>Maven 3.2.x</li></ol><h3 id="下载和构建"><a href="#下载和构建" class="headerlink" title="下载和构建"></a>下载和构建</h3><p>从 <a href="https://www.apache.org/dyn/closer.cgi?path=rocketmq/4.2.0/rocketmq-all-4.2.0-source-release.zip" target="_blank" rel="noopener">https://www.apache.org/dyn/closer.cgi?path=rocketmq/4.2.0/rocketmq-all-4.2.0-source-release.zip</a> 下载 4.2.0 的源码版本，执行以下命令来解压4.2.0源码版本并构建二进制文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">unzip rocketmq-all-4.2.0-source-release.zip</span><br><span class="line"></span><br><span class="line">cd rocketmq-all-4.2.0/</span><br><span class="line"></span><br><span class="line">mvn -Prelease-all -DskipTests clean install -U</span><br></pre></td></tr></table></figure><p>构建成功如下：</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fo7ukit9wbj31kw14o7l8.jpg" alt="2018-02-07_14-04-25"></p><p>进入到目录 ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd distribution/target/apache-rocketmq</span><br></pre></td></tr></table></figure><h3 id="启动-NameServer"><a href="#启动-NameServer" class="headerlink" title="启动 NameServer"></a>启动 NameServer</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nohup sh bin/mqnamesrv &amp;</span><br><span class="line"></span><br><span class="line">tail -f ~/logs/rocketmqlogs/namesrv.log</span><br></pre></td></tr></table></figure><p>结果如下就代表启动成功了：</p><p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1fo5pxzbap2j31kw0h413p.jpg" alt="rocketmq01"></p><h3 id="启动-Broker"><a href="#启动-Broker" class="headerlink" title="启动 Broker"></a>启动 Broker</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nohup sh bin/mqbroker -n localhost:9876 &amp;</span><br><span class="line"></span><br><span class="line">tail -f ~/logs/rocketmqlogs/broker.log</span><br></pre></td></tr></table></figure><p>结果如下就代表启动成功了：从日志中可以看到 broker 注册到了 nameserver 上了（localhost:9876）</p><p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fo5pxt2wavj31kw0jeqi0.jpg" alt="rocketmq02"></p><h3 id="发送和接收消息"><a href="#发送和接收消息" class="headerlink" title="发送和接收消息"></a>发送和接收消息</h3><p>在发送/接收消息之前，我们需要告诉客户名称服务器的位置。RocketMQ 提供了多种方法来实现这一点。为了简单起见，我们使用环境变量<code>NAMESRV_ADDR</code></p><h4 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export NAMESRV_ADDR=localhost:9876</span><br><span class="line"></span><br><span class="line">sh bin/tools.sh org.apache.rocketmq.example.quickstart.Producer</span><br></pre></td></tr></table></figure><p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fo5py0e7lgj31kw0d47j2.jpg" alt="rocketmq03"></p><h4 id="接收消息"><a href="#接收消息" class="headerlink" title="接收消息"></a>接收消息</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh bin/tools.sh org.apache.rocketmq.example.quickstart.Consumer</span><br></pre></td></tr></table></figure><p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fo5pxwox08j31kw0rib29.jpg" alt="rocketmq04"></p><h3 id="关闭服务器"><a href="#关闭服务器" class="headerlink" title="关闭服务器"></a>关闭服务器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sh bin/mqshutdown broker//停止 broker</span><br><span class="line"></span><br><span class="line">sh bin/mqshutdown namesrv//停止 nameserver</span><br></pre></td></tr></table></figure><p> 关闭成功后如下：</p><p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1fo5pxsgyywj31kw0b5dov.jpg" alt="rocketmq05"></p><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><p>上面几个启动和关闭 name server 和 broker 的就不再说了，</p><ul><li>查看集群情况  <code>./mqadmin clusterList -n 127.0.0.1:9876</code></li><li>查看 broker 状态   <code>./mqadmin brokerStatus -n 127.0.0.1:9876 -b 172.20.1.138:10911</code>   (注意换成你的 broker 地址)</li><li>查看 topic 列表    <code>./mqadmin topicList -n 127.0.0.1:9876</code></li><li>查看 topic 状态    <code>./mqadmin topicStatus -n 127.0.0.1:9876 -t  MyTopic</code>  (换成你想查询的 topic)</li><li>查看 topic 路由    <code>./mqadmin topicRoute  -n 127.0.0.1:9876 -t  MyTopic</code></li></ul><h3 id="关注我"><a href="#关注我" class="headerlink" title="关注我"></a>关注我</h3><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180103/C6LG3mGa12.jpg" alt="mark"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文是 RocketMQ 的安装及快速入门案例。</p><p>转发请注明地址：<a href="http://www.54tianzhisheng.cn/2018/02/06/RocketMQ-install/" target="_blank" rel="noopener">http://www.54tianzhisheng.cn/2018/02/06/RocketMQ-install/</a></p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fp3jkmizmpj30o00didgn.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://ws3.sinaimg.cn/large/006tKfTcgy1fo5pxy3w8oj31hc0u0b29.jpg&quot; alt=&quot;tree-3097419_1920&quot;&gt;&lt;/p&gt;
&lt;p&gt;如果你对 RocketMQ 还没了解，建议先看下上一篇文章：&lt;a href=&quot;http://www.54tianzhisheng.cn/2018/02/05/RocketMQ/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;RocketMQ 初探&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="RocketMQ" scheme="http://yoursite.com/tags/RocketMQ/"/>
    
  </entry>
  
  <entry>
    <title>RocketMQ系列文章（一）：RocketMQ 初探</title>
    <link href="http://yoursite.com/2018/02/05/RocketMQ/"/>
    <id>http://yoursite.com/2018/02/05/RocketMQ/</id>
    <published>2018-02-04T16:00:00.000Z</published>
    <updated>2018-03-24T02:35:31.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fo4vbrj17mj31hc0zj7hb.jpg" alt="gooafoss-1840758_1920"></p><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>RocketMQ 是阿里开源的消息中间件，前不久捐献给了 Apache 。正如<a href="http://rocketmq.apache.org/" target="_blank" rel="noopener">官网</a>介绍如下：它是一个开源的分布式消息传递和流式数据平台。</p><a id="more"></a><p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fo4vbtu01lj31kw0jbjzw.jpg" alt="rocketmq01"></p><p>特点如下：</p><p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fo4vbvbgisj31kw0yw7c9.jpg" alt="rocketmq02"></p><h3 id="产品发展历史"><a href="#产品发展历史" class="headerlink" title="产品发展历史"></a>产品发展历史</h3><p>大约经历了三个主要版本迭代</p><p><strong>一、Metaq（Metamorphosis）1.x</strong></p><p>由开源社区killme2008维护，开源社区非常活跃。</p><p><strong>二、Metaq 2.x</strong></p><p>于2012年10月份上线，在淘宝内部被广泛使用。</p><p><strong>三、RocketMQ 3.x</strong></p><p>基于公司内部开源共建原则，RocketMQ 项目只维护核心功能，且去除了所有其他运行时依赖，核心功能最简化。每个 BU 的个性化需求都在 RocketMQ 项目之上进行深度定制。RocketMQ 向其他 BU 提供的仅仅是 Jar 包，例如要定制一个 Broker，那么只需要依赖 rocketmq-broker 这个 jar 包即可，可通过 API 进行交互，如果定制 client，则依赖 rocketmq-client 这个 jar 包，对其提供的 api 进行再封装。</p><p>在 RocketMQ 项目基础上衍生的项目如下</p><ul><li><p>com.taobao.metaq v3.0 = RocketMQ + 淘宝个性化需求</p><p>为<strong>淘宝</strong>应用提供消息服务</p></li><li><p>com.alipay.zpullmsg v1.0 =RocketMQ + 支付宝个性化需求</p><p>为<strong>支付宝</strong>应用提供消息服务</p></li><li><p>com.alibaba.commonmq v1.0 = Notify + RocketMQ + B2B个性化需求</p><p>为 <strong>B2B</strong> 应用提供消息服务</p></li></ul><p><strong>四、RocketMQ 3.x</strong></p><p>目前它的最新版本是 4.2 版本。</p><h3 id="概念专业术语"><a href="#概念专业术语" class="headerlink" title="概念专业术语"></a>概念专业术语</h3><p><strong>Producer</strong></p><p>消息生产者，负责产生消息，一般由业务系统负责产生消息。</p><p><strong>Consumer</strong></p><p>消息消费者，负责消费消息，一般是后台系统负责异步消费。</p><p><strong>Push Consumer</strong></p><p>Consumer 的一种，应用通常向 Consumer 对象注册一个 Listener 接口，一旦收到消息，Consumer 对象立刻回调 Listener 接口方法。</p><p><strong>Pull Consumer</strong></p><p>Consumer 的一种，应用通常主动调用 Consumer 的拉消息方法从 Broker 拉消息，主动权由应用控制。</p><p><strong>Producer Group</strong></p><p>一类 Producer 的集合名称，这类 Producer 通常发送一类消息，且发送逻辑一致。</p><p><strong>Consumer Group</strong></p><p>一类 Consumer 的集合名称，这类 Consumer 通常消费一类消息，且消费逻辑一致。</p><p><strong>Broker</strong></p><p>消息中转角色，负责存储消息，转发消息，一般也称为 Server。在 JMS 规范中称为 Provider。</p><h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fo4vbs0dn7j30r30c23zl.jpg" alt="rmq-basic-arc"></p><p>从这架构图中可以看到它主要由四部分组成：Producer（生产者）、NameServer、Broker、Consumer（消费者）。</p><h3 id="Producer"><a href="#Producer" class="headerlink" title="Producer"></a>Producer</h3><p>生产者支持分布式部署。分布式生产者通过多种负载均衡模式向 Broker 集群发送消息。发送过程支持快速失败并具有低延迟。</p><h4 id="NameServer"><a href="#NameServer" class="headerlink" title="NameServer"></a>NameServer</h4><p>它提供轻量级服务发现和路由，每个 Name Server 记录完整的路由信息，提供相应的读写服务，支持快速存储扩展。主要包括两个功能：</p><ul><li>代理管理，  <strong>NameServer</strong> 接受来自 Broker 集群的注册，并提供检测代理是否存在的心跳机制。</li><li>路由管理，每个 NameServer 将保存有关代理群集的全部路由信息以及客户端查询的<strong>队列</strong>信息。</li></ul><p>我们知道，RocketMQ客户端（生产者/消费者）将从NameServer查询队列路由信息，但客户端如何找到NameServer地址？</p><p>将NameServer地址列表提供给客户端有四种方法：</p><ul><li>编程方式，就像<code>producer.setNamesrvAddr(&quot;ip:port&quot;)</code>。</li><li>Java选项，使用<code>rocketmq.namesrv.addr</code>。</li><li>环境变量，使用<code>NAMESRV_ADDR</code>。</li><li>HTTP 端点。</li></ul><h4 id="Broker"><a href="#Broker" class="headerlink" title="Broker"></a>Broker</h4><p>Broker 通过提供轻量级的 Topic 和 Queue 机制来照顾消息存储。它们支持 Push 和 Pull 模式，包含容错机制（2个拷贝或者3个拷贝），并且提供了强大的峰值填充和以原始时间顺序累计数千亿条消息的能力。此外，broker 还提供灾难恢复，丰富的指标统计数据和警报机制，而传统的消息传递系统都缺乏这些机制。</p><p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1fo4vbpoxtej30r30dsdgs.jpg" alt="rmq-basic-component"></p><p>如上图：Broker 服务器重要的子模块：</p><ul><li>远程处理模块是 broker 的入口，处理来自客户的请求。</li><li>Client manager，管理客户（生产者/消费者）并维护消费者的主题订阅。</li><li>Store Service，提供简单的 API 来存储或查询物理磁盘中的消息。</li><li>HA 服务，提供主代理和从代理之间的数据同步功能。</li><li>索引服务，通过指定键为消息建立索引，并提供快速的消息查询。</li></ul><h4 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h4><p>消费者也支持 Push 和 Pull 模型中的分布式部署。它还支持群集消费和消息广播。它提供了实时的消息订阅机制，可以满足大多数消费者的需求。</p><h3 id="关注我"><a href="#关注我" class="headerlink" title="关注我"></a>关注我</h3><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180103/C6LG3mGa12.jpg" alt="mark"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文是对 RocketMQ 的简单点了解，参考了官网介绍。</p><p>转载请注明地址：<a href="http://www.54tianzhisheng.cn/2018/02/05/RocketMQ/" target="_blank" rel="noopener">http://www.54tianzhisheng.cn/2018/02/05/RocketMQ/</a></p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fp3jkmizmpj30o00didgn.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://ws3.sinaimg.cn/large/006tKfTcgy1fo4vbrj17mj31hc0zj7hb.jpg&quot; alt=&quot;gooafoss-1840758_1920&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h3&gt;&lt;p&gt;RocketMQ 是阿里开源的消息中间件，前不久捐献给了 Apache 。正如&lt;a href=&quot;http://rocketmq.apache.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官网&lt;/a&gt;介绍如下：它是一个开源的分布式消息传递和流式数据平台。&lt;/p&gt;
    
    </summary>
    
    
      <category term="RocketMQ" scheme="http://yoursite.com/tags/RocketMQ/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot系列文章（五）：SpringBoot RabbitMQ 整合进阶版</title>
    <link href="http://yoursite.com/2018/01/28/RabbitMQ/"/>
    <id>http://yoursite.com/2018/01/28/RabbitMQ/</id>
    <published>2018-01-27T16:00:00.000Z</published>
    <updated>2018-03-24T02:34:12.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://ws4.sinaimg.cn/large/006tNc79ly1fnu3cojj9rj31hc0u079o.jpg" alt="sea-2561397_1920"></p><h3 id="消息中间件"><a href="#消息中间件" class="headerlink" title="消息中间件"></a>消息中间件</h3><p>RabbitMQ 是消息中间件的一种, 消息中间件即分布式系统中完成消息的发送和接收的基础软件. 这些软件有很多, 包括 ActiveMQ ( apache 公司的), RocketMQ (阿里巴巴公司的, 现已经转让给 apache), 还有性能极高的 Kafka。</p><a id="more"></a><p>消息中间件的工作过程可以用<strong>生产者消费者模型</strong>来表示. 即生产者不断的向消息队列发送信息, 而消费者从消息队列中消费信息. 具体过程如下:</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79ly1fnuk4o5optj30pz07xdg7.jpg" alt="972319-20170311160512014-1914425149"></p><p>从上图可看出, 对于消息队列来说, 生产者,消息队列,消费者 是最重要的三个概念。生产者发消息到消息队列中去,  消费者监听指定的消息队列, 并且当消息队列收到消息之后, 接收消息队列传来的消息, 并且给予相应的处理. 消息队列常用于分布式系统之间互相信息的传递.</p><h3 id="RabbitMQ-工作原理"><a href="#RabbitMQ-工作原理" class="headerlink" title="RabbitMQ 工作原理"></a>RabbitMQ 工作原理</h3><p>对于 RabbitMQ 来说, 除了这三个基本模块以外, 还添加了一个模块, 即交换机(Exchange). 它使得生产者和消息队列之间产生了隔离, 生产者将消息发送给交换机,而交换机则根据调度策略把相应的消息转发给对应的消息队列. 那么 RabitMQ 的工作流程如下所示:</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79ly1fnuk4ohjbmj30dd08zjrw.jpg" alt="972319-20170311161512951-1006030113"></p><p>说一下交换机: 交换机的主要作用是接收相应的消息并且绑定到指定的队列. 交换机有四种类型, 分别为Direct, topic, headers, Fanout.</p><p>Direct 是 RabbitMQ 默认的交换机模式,也是最简单的模式.即创建消息队列的时候,指定一个 BindingKey. 当发送者发送消息的时候, 指定对应的 Key. 当 Key 和消息队列的 BindingKey 一致的时候,消息将会被发送到该消息队列中.</p><p>topic 转发信息主要是依据通配符, 队列和交换机的绑定主要是依据一种模式(通配符+字符串), 而当发送消息的时候, 只有指定的 Key 和该模式相匹配的时候, 消息才会被发送到该消息队列中.</p><p>headers 也是根据一个规则进行匹配, 在消息队列和交换机绑定的时候会指定一组键值对规则, 而发送消息的时候也会指定一组键值对规则, 当两组键值对规则相匹配的时候, 消息会被发送到匹配的消息队列中.</p><p>Fanout 是路由广播的形式, 将会把消息发给绑定它的全部队列, 即便设置了 key, 也会被忽略.</p><h3 id="关注我"><a href="#关注我" class="headerlink" title="关注我"></a>关注我</h3><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180103/C6LG3mGa12.jpg" alt="mark"></p><p>转载请务必注明原创地址为：<a href="http://www.54tianzhisheng.cn/2018/01/28/RabbitMQ/" target="_blank" rel="noopener">http://www.54tianzhisheng.cn/2018/01/28/RabbitMQ/</a></p><h3 id="SpringBoot-整合-RabbitMQ（Topic-转发模式）"><a href="#SpringBoot-整合-RabbitMQ（Topic-转发模式）" class="headerlink" title="SpringBoot 整合 RabbitMQ（Topic 转发模式）"></a>SpringBoot 整合 RabbitMQ（Topic 转发模式）</h3><p>在上一篇文章中，我们也将 SpringBoot 和 RabbitMQ 整合过，不过那是使用 Direct 模式，文章地址是：<a href="http://www.54tianzhisheng.cn/2018/01/26/SpringBoot-RabbitMQ/" target="_blank" rel="noopener">SpringBoot RabbitMQ 整合使用</a></p><h3 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h3><p>1、<a href="http://www.54tianzhisheng.cn/2018/01/05/SpringBoot-Kafka/" target="_blank" rel="noopener">SpringBoot Kafka 整合使用</a></p><p>2、<a href="http://www.54tianzhisheng.cn/2018/01/26/SpringBoot-RabbitMQ/" target="_blank" rel="noopener">SpringBoot RabbitMQ 整合使用</a></p><p>3、<a href="http://www.54tianzhisheng.cn/2018/01/27/SpringBoot-ActiveMQ/" target="_blank" rel="noopener">SpringBoot ActiveMQ 整合使用</a></p><p>4、<a href="http://www.54tianzhisheng.cn/2018/01/04/Kafka/" target="_blank" rel="noopener">Kafka 安装及快速入门</a></p><h3 id="整合"><a href="#整合" class="headerlink" title="整合"></a>整合</h3><p>接下来，我要带大家继续整合（Topic 转发模式）：</p><p>1、配置文件和 pom.xml 这些还都是一样的，我们不用再修改</p><p>2、启动类中创建 Queue 和 Exchange，并把 Queue 按照相应的规则绑定到交换机Queue 上。代码如下图：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Queue <span class="title">queue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">"rpc-queue-zhisheng"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> TopicExchange <span class="title">exchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> TopicExchange(<span class="string">"rpc-exchange-zhisheng"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Binding <span class="title">binding</span><span class="params">(Queue queue, TopicExchange exchange)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> BindingBuilder.bind(queue).to(exchange).with(<span class="string">"rpc-zhisheng"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里创建一个 Queue 和 Exchange ，然后绑定。</p><p>注意：上面代码中的 with(“rpc-zhisheng”)  这个 “zhisheng” 是 routingkey，RabbitMQ 将会根据这个参数去寻找有没有匹配此规则的队列，如果有，则会把消息发送给它，如果不止有一个，则会把消息分发给所有匹配的队列。</p><p>3、消息发送类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhisheng.rabbitmq.rpc.client;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.TopicExchange;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by zhisheng_tian on 2018/1/25</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitMQClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TopicExchange exchange;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        rabbitTemplate.convertAndSend(exchange.getName(), <span class="string">"rpc-zhisheng"</span>, message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是发送消息的代码，“rpc-zhisheng” 就是上面我们设置的 routingkey。</p><p>4、消息接收端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhisheng.rabbitmq.rpc.server;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by zhisheng_tian on 2018/1/25</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitMQServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener</span>(queues = <span class="string">"rpc-queue-zhisheng"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"--------receive ------- "</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、启动类中注入 发送消息类，然后调用 send 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RabbitMQClient client;</span><br><span class="line"></span><br><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  StopWatch stopWatch = <span class="keyword">new</span> StopWatch();</span><br><span class="line">  stopWatch.start();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">  client.send(<span class="string">"  zhisheng, ---------  send "</span> + i);</span><br><span class="line">  &#125;</span><br><span class="line">  stopWatch.stop();</span><br><span class="line">  System.out.println(<span class="string">"总共耗时："</span> +      stopWatch.getTotalTimeMillis());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行此 SpringBoot 项目，则可以发现结果如下：</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79ly1fnu3cn8zwjj31kw0y9kfi.jpg" alt="Snip20180126_2"></p><p>这里测试的是匹配一个消息队列的情况，感兴趣的可以测试下匹配多个消息队列的。</p><h3 id="SpringBoot-整合-RabbitMQ-Fanout-Exchange-形式"><a href="#SpringBoot-整合-RabbitMQ-Fanout-Exchange-形式" class="headerlink" title="SpringBoot 整合 RabbitMQ( Fanout Exchange 形式)"></a>SpringBoot 整合 RabbitMQ( Fanout Exchange 形式)</h3><p>Fanout Exchange 形式又叫广播形式。</p><p>任何发送到 Fanout Exchange 的消息都会被转发到与该 Exchange 绑定(Binding)的所有 Queue 上。</p><ul><li>这种模式需要提前将 Exchange 与 Queue 进行绑定，一个 Exchange 可以绑定多个 Queue，一个 Queue 可以同多个 Exchange 进行绑定</li><li>这种模式不需要 RoutingKey</li><li>如果接受到消息的 Exchange 没有与任何 Queue 绑定，则消息会被抛弃。</li></ul><p>1、消息发送类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhisheng.rabbitmq.rpc.client;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by zhisheng_tian on 2018/1/25</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitMQClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send2</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">"fanout-exchange"</span>, <span class="string">""</span>, message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里可以不设置 routingkey 了。</p><p>2、启动类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhisheng.rabbitmq.rpc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.zhisheng.rabbitmq.rpc.client.RabbitMQClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Binding;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.BindingBuilder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.FanoutExchange;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Queue;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.support.converter.Jackson2JsonMessageConverter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Qualifier;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.PostConstruct;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitmqRpcApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitMQClient client;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        client.send2(<span class="string">"zhisheng ++++++++++ send2 "</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">SpringApplication.run(RabbitmqRpcApplication.class, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"queue"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">queue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">"rpc.queue"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"queue2"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">queue2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">"rpc.queue2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"queue3"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">queue3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">"rpc.queue3"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FanoutExchange <span class="title">exchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FanoutExchange(<span class="string">"fanout-exchange"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">binding</span><span class="params">(@Qualifier(<span class="string">"queue"</span>)</span> Queue queue, FanoutExchange exchange) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue).to(exchange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">binding2</span><span class="params">(@Qualifier(<span class="string">"queue2"</span>)</span> Queue queue, FanoutExchange exchange) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue).to(exchange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">binding3</span><span class="params">(@Qualifier(<span class="string">"queue3"</span>)</span> Queue queue, FanoutExchange exchange) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue).to(exchange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Jackson2JsonMessageConverter <span class="title">messageConverter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Jackson2JsonMessageConverter();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在启动类中我创建三个 Queue： <code>rpc.queue</code>,  <code>rpc.queue2</code> , <code>rpc.queue3</code></p><p>也创建一个 FanoutExchange，并把这三个 Queue 绑定在同一个交换机 <code>fanout-exchange</code> 上面</p><p>注意：这个 <code>fanout-exchange</code> 交换机不知为啥，我自己在应用程序里创建，运行程序会出错，下面讲讲我是怎么解决的。</p><p>我是从 RabbitMQ 管理界面直接添加个 exchange 的。</p><p><img src="https://ws1.sinaimg.cn/large/006tNc79ly1fnu3co30lkj31hy1bun4z.jpg" alt="Snip20180126_3"></p><p>3、消息接收类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhisheng.rabbitmq.rpc.server;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by zhisheng_tian on 2018/1/25</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitMQServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener</span>(queues = <span class="string">"rpc.queue"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"--------receive ------- "</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener</span>(queues = <span class="string">"rpc.queue2"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive2</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"--------receive2 ------- "</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener</span>(queues = <span class="string">"rpc.queue3"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive3</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"--------receive3 ------- "</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>监听每个 Queue，并有一个方法输出对应接收到的消息。</p><p>4、运行项目</p><p><img src="https://ws1.sinaimg.cn/large/006tNc79ly1fnu3cmf22dj31kw0zoh6u.jpg" alt="Snip20180126_4"></p><p>结果如上，每个队列都打印出自己收到的结果，同时我们看看这三个 Queue 是不是绑定到 Exchange 上呢？</p><p>可以看到三个 Queue 都绑定在 Exchange 上了。</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79ly1fnu3clys6lj31kw1ajjy9.jpg" alt="Snip20180126_5"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>RabbitMQ 与 SpringBoot 整合就到这里为止了，后面如果有时间会深度研究 RabbitMQ 的。</p><p>还请继续关注我的博客：<a href="http://www.54tianzhisheng.cn/" target="_blank" rel="noopener">http://www.54tianzhisheng.cn/</a></p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fp3jkmizmpj30o00didgn.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://ws4.sinaimg.cn/large/006tNc79ly1fnu3cojj9rj31hc0u079o.jpg&quot; alt=&quot;sea-2561397_1920&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;消息中间件&quot;&gt;&lt;a href=&quot;#消息中间件&quot; class=&quot;headerlink&quot; title=&quot;消息中间件&quot;&gt;&lt;/a&gt;消息中间件&lt;/h3&gt;&lt;p&gt;RabbitMQ 是消息中间件的一种, 消息中间件即分布式系统中完成消息的发送和接收的基础软件. 这些软件有很多, 包括 ActiveMQ ( apache 公司的), RocketMQ (阿里巴巴公司的, 现已经转让给 apache), 还有性能极高的 Kafka。&lt;/p&gt;
    
    </summary>
    
    
      <category term="RabbitMQ" scheme="http://yoursite.com/tags/RabbitMQ/"/>
    
      <category term="SpringBoot" scheme="http://yoursite.com/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot系列文章（四）：SpringBoot ActiveMQ 整合使用</title>
    <link href="http://yoursite.com/2018/01/27/SpringBoot-ActiveMQ/"/>
    <id>http://yoursite.com/2018/01/27/SpringBoot-ActiveMQ/</id>
    <published>2018-01-26T16:00:00.000Z</published>
    <updated>2018-03-24T02:33:42.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://ws1.sinaimg.cn/large/006tKfTcly1fns53btbl0j31hc0zldyz.jpg" alt="busan-night-scene-1747130_1920"></p><h3 id="介绍-ActiveMQ"><a href="#介绍-ActiveMQ" class="headerlink" title="介绍 ActiveMQ"></a>介绍 ActiveMQ</h3><p>它是 Apache 出品，最流行的，能力强劲的开源消息总线。ActiveMQ  是一个完全支持 JMS1.1 和 J2EE 1.4 规范的 JMS Provider 实现，尽管 JMS 规范出台已经是很久的事情了，但是 JMS 在当今的J2EE应用中间仍然扮演着特殊的地位。—— 摘自百度百科，偷了个懒。</p><a id="more"></a><h3 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h3><p>1、<a href="http://www.54tianzhisheng.cn/2018/01/05/SpringBoot-Kafka/" target="_blank" rel="noopener">SpringBoot Kafka 整合使用</a></p><p>2、<a href="http://www.54tianzhisheng.cn/2018/01/26/SpringBoot-RabbitMQ/" target="_blank" rel="noopener">SpringBoot RabbitMQ 整合使用</a></p><h3 id="安装-ActiveMQ"><a href="#安装-ActiveMQ" class="headerlink" title="安装 ActiveMQ"></a>安装 ActiveMQ</h3><p>同之前一样，直接在 Docker 里面玩吧。命令也是一行解决：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 8161:8161 -p 61616:61616 -e ACTIVEMQ_ADMIN_LOGIN=admin -e ACTIVEMQ_ADMIN_PASSWORD=admin --name activemq webcenter/activemq</span><br></pre></td></tr></table></figure><p>简单解释下：</p><ul><li>8186: 表示 ActiveMQ 控制台端口号，它和 RabbitMQ 一样都是有控制台的，可以登陆控制台进行操作的</li><li>61616 ： 表示 ActiveMQ 所监听的 TCP 端口号，应用程序可通过该端口号与 ActiveMQ 建立 TCP 连接</li><li>CTIVEMQ_ADMIN_LOGIN ：登陆控制台的用户名</li><li>ACTIVEMQ_ADMIN_PASSWORD ：登陆控制台的密码</li></ul><p>执行后，可在浏览器输入 <a href="http://localhost:8161/" target="_blank" rel="noopener">http://localhost:8161/</a>   查看控制台，</p><p><img src="https://ws3.sinaimg.cn/large/006tKfTcly1fns4zm1yqfj31kw0djn3k.jpg" alt="Snip20180124_1"></p><p><img src="https://ws1.sinaimg.cn/large/006tKfTcly1fns4zmk78ej31kw0ladq0.jpg" alt="Snip20180124_2"></p><p>解释下上面图片中控制台这些按钮的基本信息：</p><ul><li>Home：查看 ActiveMQ 的常见信息</li><li>Queues：查看 ActiveMQ 的队列信息</li><li>Topics：查看 ActiveMQ 的主题信息</li><li>Subscribers：查看主题的订阅者信息</li><li>Connections：查看 ActiveMQ 客户端的连接信息</li><li>Network：查看 ActiveMQ 的网络信息</li><li>Scheduled：查看 ActiveMQ 的定时任务</li><li>Send：用于通过表单方式向队列或者主题发送具体的消息</li></ul><h3 id="整合"><a href="#整合" class="headerlink" title="整合"></a>整合</h3><p>IDEA 创建 SpringBoot 项目，因为 SpringBoot 已经内置了对 ActiveMQ 的支持，所以直接引入依赖 <code>spring-boot-starter-activemq</code> 就行。整体项目结构如下：</p><p><img src="https://ws2.sinaimg.cn/large/006tKfTcly1fns4zkpkhvj30os0tkwg8.jpg" alt="Snip20180124_3"></p><p>1、<strong>pom.xml 文件</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span><span class="meta">?&gt;</span></span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.zhisheng<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>activemq<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>activemq<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot ActiveMQ<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.reporting.outputEncoding</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-activemq<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2、<strong>配置文件</strong>  application.properties</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spring.activemq.broker-url=tcp://localhost:61616</span><br><span class="line">spring.activemq.user=admin</span><br><span class="line">spring.activemq.password=admin</span><br></pre></td></tr></table></figure><p>3、<strong>发送消息类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhisheng.activemq.client;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jms.core.JmsTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActiveMQClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JmsTemplate jmsTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        jmsTemplate.convertAndSend(<span class="string">"zhisheng"</span>, message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样，和 RabbitMQ 类似，不多说了。</p><p>4、<strong>消息接收类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhisheng.activemq.server;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.jms.annotation.JmsListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActiveMQServer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@JmsListener</span>(destination = <span class="string">"zhisheng"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"收到的 message 是："</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、<strong>注意</strong></p><p>这个队列是不需要我们提前定义好的，它和 RabbitMQ 不一样，它会在我们需要的时候动态的创建。</p><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhisheng.activemq;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.zhisheng.activemq.client.ActiveMQClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.StopWatch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.PostConstruct;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActivemqApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">    ActiveMQClient client;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StopWatch stopWatch = <span class="keyword">new</span> StopWatch();</span><br><span class="line">        stopWatch.start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            client.send(<span class="string">"发送消息----zhisheng-----"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        stopWatch.stop();</span><br><span class="line">        System.out.println(<span class="string">"发送消息耗时: "</span> + stopWatch.getTotalTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">SpringApplication.run(ActivemqApplication.class, args);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发送一万条消息运行后需要的时间挺久的：73180 ms</p><p><img src="https://ws1.sinaimg.cn/large/006tKfTcly1fns4zlmbg7j31kw0wutop.jpg" alt="Snip20180124_4"></p><p>比 RabbitMQ 发送 10000 条消息耗时 215 ms 不知道高出多少倍了，可见其性能并不高的。</p><h3 id="关注我"><a href="#关注我" class="headerlink" title="关注我"></a>关注我</h3><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180103/C6LG3mGa12.jpg" alt="mark"></p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>转载请务必注明原创地址为：<a href="http://www.54tianzhisheng.cn/2018/01/27/SpringBoot-ActiveMQ/" target="_blank" rel="noopener">http://www.54tianzhisheng.cn/2018/01/27/SpringBoot-ActiveMQ/</a></p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fp3jkmizmpj30o00didgn.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/006tKfTcly1fns53btbl0j31hc0zldyz.jpg&quot; alt=&quot;busan-night-scene-1747130_1920&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;介绍-ActiveMQ&quot;&gt;&lt;a href=&quot;#介绍-ActiveMQ&quot; class=&quot;headerlink&quot; title=&quot;介绍 ActiveMQ&quot;&gt;&lt;/a&gt;介绍 ActiveMQ&lt;/h3&gt;&lt;p&gt;它是 Apache 出品，最流行的，能力强劲的开源消息总线。ActiveMQ  是一个完全支持 JMS1.1 和 J2EE 1.4 规范的 JMS Provider 实现，尽管 JMS 规范出台已经是很久的事情了，但是 JMS 在当今的J2EE应用中间仍然扮演着特殊的地位。—— 摘自百度百科，偷了个懒。&lt;/p&gt;
    
    </summary>
    
    
      <category term="SpringBoot" scheme="http://yoursite.com/tags/SpringBoot/"/>
    
      <category term="ActiveMQ" scheme="http://yoursite.com/tags/ActiveMQ/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot系列文章（三）：SpringBoot  RabbitMQ 整合使用</title>
    <link href="http://yoursite.com/2018/01/26/SpringBoot-RabbitMQ/"/>
    <id>http://yoursite.com/2018/01/26/SpringBoot-RabbitMQ/</id>
    <published>2018-01-25T16:00:00.000Z</published>
    <updated>2018-03-24T02:33:32.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180107/6DFKcmCgC7.png-1" alt="mark"></p><h3 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h3><p>上次写了篇文章，<a href="http://www.54tianzhisheng.cn/2018/01/05/SpringBoot-Kafka/" target="_blank" rel="noopener">《SpringBoot Kafka 整合使用》</a>，阅读量还挺高的，于是想想还是把其他几种 MQ 也和 SpringBoot 整合使用下。</p><a id="more"></a><p>下面是四种比较流行的 MQ ：</p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fnrqdwnlsej30fw07274m.jpg" alt="rabbitmq-1"></p><p>后面都写写和 SpringBoot 整合的文章。</p><h3 id="安装-RabbitMQ"><a href="#安装-RabbitMQ" class="headerlink" title="安装 RabbitMQ"></a>安装 RabbitMQ</h3><p>由于换 Mac 了，所以一些环境就直接在 Mac 搞，但是像安装 RabbitMQ 这些又会把自己电脑系统给搞的太乱，所以能在 Docker 里面安装就安装在 Docker，这次 RabbitMQ 我也直接在 Docker 里安装。</p><p>启动 Docker for Mac，如果没安装过的请看我上一篇文章：<a href="http://www.54tianzhisheng.cn/2018/01/25/Docker-install/" target="_blank" rel="noopener">http://www.54tianzhisheng.cn/2018/01/25/Docker-install/</a></p><p>当然你也可以在自己的 Linux 服务器或者虚拟机里启动安装 RabbitMQ 。</p><p>Docker 安装的话很简单，因为 RabbitMQ 官方已经提供了自己的 Docker 容器，只需要一行命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d  -p 15672:15672  -p  5672:5672  -e RABBITMQ_DEFAULT_USER=admin -e RABBITMQ_DEFAULT_PASS=admin --name rabbitmq rabbitmq:3-management</span><br></pre></td></tr></table></figure><p>该镜像拥有一个基于 web 的控制台和 Http API。Http API 可以在地址看到如何使用：<code>http://localhost:15672/api/</code></p><p>讲解下上面命令行：</p><ul><li>15672 ：表示 RabbitMQ 控制台端口号，可以在浏览器中通过控制台来执行 RabbitMQ 的相关操作。</li><li>5672 : 表示 RabbitMQ 所监听的 TCP 端口号，应用程序可通过该端口与 RabbitMQ 建立 TCP 连接，并完成后续的异步消息通信</li><li>RABBITMQ_DEFAULT_USER：用于设置登陆控制台的用户名，这里我设置 admin</li><li>RABBITMQ_DEFAULT_PASS：用于设置登陆控制台的密码，这里我设置 admin</li></ul><p>容器启动成功后，可以在浏览器输入地址：<a href="http://localhost:15672/" target="_blank" rel="noopener">http://localhost:15672/</a>  访问控制台</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fnrqdzkxzoj30js0980t7.jpg" alt="rabbitmq-2"></p><p>登陆后：</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fnrqohaja0j31kw0vr0z3.jpg" alt="rabbitmq-3"></p><p>简单描述下上图中中控制台的列表的作用：</p><ul><li>Overview ：用于查看 RabbitMQ 的一些基本信息（消息队列、消息发送速率、节点、端口和上下文信息等）</li><li>Connections：用于查看 RabbitMQ 客户端的连接信息</li><li>Channels：用户查看 RabbitMQ 的通道信息</li><li>Exchange：用于查看 RabbitMQ 交换机</li><li>Queues：用于查看 RabbitMQ 的队列</li><li>Admin：用于管理用户，可增加用户</li></ul><h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><p>在 IDEA 中创建一个 SpringBoot 项目结构：</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fnrqp4fi3cj30pk12qtcc.jpg" alt="Snip20180124_5"></p><p>SpringBoot 框架中已经内置了对 RabbitMQ 的支持，如果你看过官方文档的话，就可以看到的，我们需要把依赖 spring-boot-starter-amqp 引入就行。</p><p>1、 <strong>pom.xml</strong> 引入依赖后如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span><span class="meta">?&gt;</span></span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.zhisheng<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>rabbitmq<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>rabbitmq<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot RabbitMQ<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.reporting.outputEncoding</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2、<strong>application.properties</strong>  配置修改如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spring.rabbitmq.addresses=localhost:5672</span><br><span class="line">spring.rabbitmq.username=admin</span><br><span class="line">spring.rabbitmq.password=admin</span><br></pre></td></tr></table></figure><p>3、<strong>消息发送类</strong> RabbitMQClient.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhisheng.rabbitmq.client;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by zhisheng_tian on 2018/1/23</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitMQClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">"zhisheng"</span>, message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就这样，发送消息代码就实现了。</p><p>这里关键的代码为 rabbitTemplate.convertAndSend() 方法，<code>zhisheng</code> 这个是路由规则（routingKey），它的值表明将消息发送到指定的队列 <code>zhisheng</code> 中去，这里跟了下源码，发现 convertAndSend() 方法最后调用的方法其实是一个 doSend() 方法。</p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fnrqpy395kj31kw0wkn75.jpg" alt="Snip20180124_7"></p><p>4、<strong>消息接收类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhisheng.rabbitmq.server;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by zhisheng_tian on 2018/1/23</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitMQServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener</span>(queues = <span class="string">"zhisheng"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"收到的 message 是："</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你看，这里就有个 <code>RabbitListener</code> 一直在监听着队列 <code>zhisheng</code> 。</p><p>当然这个队列是必须要我们自己在应用程序中创建好，它不会像我之前写的文章 <a href="http://www.54tianzhisheng.cn/2018/01/05/SpringBoot-Kafka/" target="_blank" rel="noopener">《SpringBoot Kafka 整合使用》</a>  中的 Kafka 一样，Kafka 它会在用到队列的时候动态的创建，不需要我们提前创建好。</p><p>那么在 RabbitMQ 中该如何创建队列呢？</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fnrqqcykkoj31kw0roajh.jpg" alt="Snip20180124_8"></p><p>如上图所示：这样我们就创建好了一个 <code>zhisheng</code> 的队列，当程序开始运行时，消息接收类会持续监听队列 <code>zhisheng</code> 中即将到来的消息。</p><p>5、<strong>运行项目</strong></p><p>需要在启动类中注入发送消息的类，并且提供 init 方法，在 init 方法中调用发送消息类的 send()  方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">rabbitMQClient.send(<span class="string">"发送消息----zhisheng-----"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是：init() 方法带有 @PostConstruct 注解，被 @PostConstruct 修饰的方法会在构造函数之后执行。</p><p>启动项目就可以发现控制台已经接收到消息了。</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fnrqqqr9zlj31kw10qdv6.jpg" alt="Snip20180124_9"></p><p>6、<strong>单线程测试性能</strong></p><p>看到上面图片中注释掉的代码没？那就是用来测试消息发送的性能的，我发送 10000 条消息看看总共耗时多少。</p><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fnrqr3c0wnj31kw0tctgm.jpg" alt="Snip20180124_10"></p><p>10000 条消息发送耗时：215ms。   这是在单线程下，下次可以和其他的 MQ 测试对比下，并且也可以在多线程的环境下测试性能。</p><p>同时从控制台可以看到发送的速率：</p><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fnrqrd94g6j31kw0s1tim.jpg" alt="Snip20180124_11"></p><p>7、<strong>多线程测试性能</strong></p><p>开了10 个线程，每个线程发送 10000 条消息。</p><p>init  方法代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StopWatch stopWatch = <span class="keyword">new</span> StopWatch();</span><br><span class="line">        stopWatch.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> threads = <span class="number">10</span>;</span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(threads);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> CountDownLatch start = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch end = <span class="keyword">new</span> CountDownLatch(threads);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threads; i++) &#123;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    start.await();</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i1 = <span class="number">0</span>; i1 &lt; <span class="number">10000</span>; i1++) &#123;</span><br><span class="line">                        rabbitMQClient.send(<span class="string">"发送消息----zhisheng-----"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    end.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        start.countDown();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            end.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            executorService.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        stopWatch.stop();</span><br><span class="line">        System.out.println(<span class="string">"发送消息耗时："</span> + stopWatch.getTotalTimeMillis());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>耗时：4063ms</p><p>控制台显示如下图：</p><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fnrqrt6ngfj31kw0ul47b.jpg" alt="Snip20180124_12"></p><p>8、<strong>注意</strong></p><p>这里测试发送的消息直接是 String 类型的，你也可以测试下 Bean 类，这需要注意需要序列化。</p><h3 id="关注我"><a href="#关注我" class="headerlink" title="关注我"></a>关注我</h3><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180103/C6LG3mGa12.jpg" alt="mark"></p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>转载请务必注明原创地址为：<a href="http://www.54tianzhisheng.cn/2018/01/26/SpringBoot-RabbitMQ/" target="_blank" rel="noopener">http://www.54tianzhisheng.cn/2018/01/26/SpringBoot-RabbitMQ/</a></p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fp3jkmizmpj30o00didgn.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ohfk1r827.bkt.clouddn.com/blog/180107/6DFKcmCgC7.png-1&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;前提&quot;&gt;&lt;a href=&quot;#前提&quot; class=&quot;headerlink&quot; title=&quot;前提&quot;&gt;&lt;/a&gt;前提&lt;/h3&gt;&lt;p&gt;上次写了篇文章，&lt;a href=&quot;http://www.54tianzhisheng.cn/2018/01/05/SpringBoot-Kafka/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《SpringBoot Kafka 整合使用》&lt;/a&gt;，阅读量还挺高的，于是想想还是把其他几种 MQ 也和 SpringBoot 整合使用下。&lt;/p&gt;
    
    </summary>
    
    
      <category term="RabbitMQ" scheme="http://yoursite.com/tags/RabbitMQ/"/>
    
      <category term="SpringBoot" scheme="http://yoursite.com/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>Docker系列文章（二）：Mac 安装 Docker 及常用命令</title>
    <link href="http://yoursite.com/2018/01/25/Docker-install/"/>
    <id>http://yoursite.com/2018/01/25/Docker-install/</id>
    <published>2018-01-24T16:00:00.000Z</published>
    <updated>2018-03-24T02:30:34.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180107/mALkf4CKA2.png-1" alt="mark"></p><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>微服务 + 容器，完美的一对！必须得好好学习学习。</p><a id="more"></a><h3 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h3><p>Mac 下 Docker 的安装真心建议跟着官方的文档走一遍，官网已经讲的很详细了。</p><p><a href="https://docs.docker.com/docker-for-mac/install/#what-to-know-before-you-install" target="_blank" rel="noopener">https://docs.docker.com/docker-for-mac/install/#what-to-know-before-you-install</a></p><h3 id="使用-Docker-for-Mac"><a href="#使用-Docker-for-Mac" class="headerlink" title="使用 Docker for Mac"></a>使用 Docker for Mac</h3><p><a href="https://docs.docker.com/docker-for-mac/#check-versions-of-docker-engine-compose-and-machine" target="_blank" rel="noopener">https://docs.docker.com/docker-for-mac/#check-versions-of-docker-engine-compose-and-machine</a></p><h3 id="配置-Docker-加速器"><a href="#配置-Docker-加速器" class="headerlink" title="配置 Docker 加速器"></a>配置 Docker 加速器</h3><p>Docker 加速器是什么，我需要使用吗？</p><p>使用 Docker 的时候，需要经常从官方获取镜像，但是由于显而易见的网络原因，拉取镜像的过程非常耗时，严重影响使用 Docker 的体验。因此 DaoCloud 推出了加速器工具解决这个难题，通过智能路由和缓存机制，极大提升了国内网络访问 Docker Hub 的速度，目前已经拥有了广泛的用户群体，并得到了 Docker 官方的大力推荐。如果您是在国内的网络环境使用 Docker，那么 Docker 加速器一定能帮助到您。</p><p>注册 <a href="">daocloud</a>，然后在 mac 标签页复制加速器 url。</p><p><img src="https://upload-images.jianshu.io/upload_images/5225109-54fdf15443d355fd.png?imageMogr2/auto-orient/" alt=""></p><p><img src="https://upload-images.jianshu.io/upload_images/5225109-8dd1076f952fda33.png?imageMogr2/auto-orient/" alt=""></p><h3 id="入门案例"><a href="#入门案例" class="headerlink" title="入门案例"></a>入门案例</h3><p>跟着下面的文章进行敲一遍，熟悉下 Docker 整个的使用。</p><p><a href="https://www.jianshu.com/p/cf6e7248b6c7" target="_blank" rel="noopener">https://www.jianshu.com/p/cf6e7248b6c7</a></p><h3 id="Docker-常用命令"><a href="#Docker-常用命令" class="headerlink" title="Docker 常用命令"></a>Docker 常用命令</h3><p>下面列出些自己常用的命令，目的就是记录下来，以后忘记了，再拿来跟着敲就行！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">docker run -i -t &lt;image_name/continar_id&gt; /bin/bash  启动容器并启动bash（交互方式）</span><br><span class="line"></span><br><span class="line">docker run -d -it  image_name   启动容器以后台方式运行(更通用的方式）</span><br><span class="line"></span><br><span class="line">docker ps   列出当前所有正在运行的container</span><br><span class="line"></span><br><span class="line">docker ps -a  列出所有的container</span><br><span class="line"></span><br><span class="line">docker ps -l   列出最近一次启动的container</span><br><span class="line"></span><br><span class="line">docker images  列出本地所有的镜像</span><br><span class="line"></span><br><span class="line">docker rmi imagesID   删除指定的镜像id</span><br><span class="line"></span><br><span class="line">docker rm CONTAINER ID   删除指定的CONTAINER id</span><br><span class="line"></span><br><span class="line">docker diff 镜像名    查看容器的修改部分</span><br><span class="line"></span><br><span class="line">docker kill CONTAINER ID   杀掉正在运行的容器</span><br><span class="line"></span><br><span class="line">docker logs 容器ID/name   可以查看到容器主程序的输出</span><br><span class="line"></span><br><span class="line">docker pull image_name    下载image</span><br><span class="line"></span><br><span class="line">docker push image_name   发布docker镜像</span><br><span class="line"></span><br><span class="line">docker version   查看docker版本</span><br><span class="line"></span><br><span class="line">docker info   查看docker系统的信息</span><br><span class="line"></span><br><span class="line">docker inspect 容器的id 可以查看更详细的关于某一个容器的信息</span><br><span class="line"></span><br><span class="line">docker run -d  image-name   后台运行镜像</span><br><span class="line"></span><br><span class="line">docker search 镜像名    查找公共的可用镜像</span><br><span class="line"></span><br><span class="line">docker stop 容器名/容器 ID      终止运行的容器</span><br><span class="line"></span><br><span class="line">docker restart 容器名/容器 ID    重启容器</span><br><span class="line"></span><br><span class="line">docker commit  提交，创建个新镜像</span><br><span class="line"></span><br><span class="line">docker build [OPTIONS] PATH | URL | -   利用 Dockerfile 创建新镜像</span><br></pre></td></tr></table></figure><h3 id="关注我"><a href="#关注我" class="headerlink" title="关注我"></a>关注我</h3><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180103/C6LG3mGa12.jpg" alt="mark"></p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>转载请注明地址：<a href="http://www.54tianzhisheng.cn/2018/01/25/Docker-install/" target="_blank" rel="noopener">http://www.54tianzhisheng.cn/2018/01/25/Docker-install/</a></p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fp3jkmizmpj30o00didgn.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ohfk1r827.bkt.clouddn.com/blog/180107/mALkf4CKA2.png-1&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;微服务 + 容器，完美的一对！必须得好好学习学习。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Docker" scheme="http://yoursite.com/tags/Docker/"/>
    
  </entry>
  
</feed>
